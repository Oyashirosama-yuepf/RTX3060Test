/*
 * Copyright (C) HoloMatic Technology(Beijing) Co., Ltd. - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 */

/**
 * @file aceinna.h
 * @brief This header file define the ply format
 * @author guoguangchao@holomatic.com
 * @date 2021-01-08
 */

#ifndef _HOLO_SENSORS_BASE_LIDAR_LIBPLY_LIBPLY_H
#define _HOLO_SENSORS_BASE_LIDAR_LIBPLY_LIBPLY_H

#include <dirent.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include <holo/log/hololog.h>
#include <holo/point_cloud/point_cloud.h>
#include <holo/point_cloud/point_type.h>
#include <fstream>

namespace holo
{
namespace sensors
{
struct PlyConverterStrings
{
    const std::string HEAD               = "ply\n";
    const std::string FORMAT_ASCII       = "format ascii 1.0\n";
    const std::string FORMAT_BINARY      = "format binary_little_endian 1.0\n";
    const std::string COMMENT            = "comment Generated by holomatic sensors library.\n";
    const std::string OBJ_INFO_COORD     = "obj_info coord 0\n";
    const std::string OBJ_INFO_TIMESTAMP = "obj_info timestamp 0 0\n";
    const std::string OBJ_INFO_SIZE      = "obj_info size ";  // 89404 1\n";
    const std::string OBJ_INFO_DENSE     = "obj_info dense 0\n";
    const std::string OBJ_INFO_POSE = "obj_info pose 1.000000 0.000000 0.000000 0.000000 0.000000 0.000000 0.000000\n";
    const std::string ELEMENT       = "element vertex ";
    const std::string PROPERTY_X    = "property float32 x\n";
    const std::string PROPERTY_Y    = "property float32 y\n";
    const std::string PROPERTY_Z    = "property float32 z\n";
    const std::string PROPERTY_I    = "property float32 intensity\n";
    const std::string PROPERTY_R    = "property uint ring\n";
    const std::string PROPERTY_ST   = "property double timestamp\n";
    const std::string TAIL          = "end_header\n";
    const std::string LF            = "\n";
};

static const PlyConverterStrings PLY_CVTR_STRS;

template <typename T>
class PlyConverter
{
public:
    PlyConverter() noexcept = default;
    static size_t Save(const T& pcd, const std::string& ply, const std::string& path = ".", bool_t ascii = false)
    {
        if (0 != makeDirectory(path))
        {
            return 0;
        }
        size_t        size = pcd.GetWidth() * pcd.GetHeight();
        std::ofstream out(path + "/" + ply, std::ios::binary);
        (void)out.write(PLY_CVTR_STRS.HEAD.c_str(), PLY_CVTR_STRS.HEAD.size());
        if (ascii)
        {
            (void)out.write(PLY_CVTR_STRS.FORMAT_ASCII.c_str(), PLY_CVTR_STRS.FORMAT_ASCII.size());
        }
        else
        {
            (void)out.write(PLY_CVTR_STRS.FORMAT_BINARY.c_str(), PLY_CVTR_STRS.FORMAT_BINARY.size());
        }
        (void)out.write(PLY_CVTR_STRS.COMMENT.c_str(), PLY_CVTR_STRS.COMMENT.size());
        (void)out.write(PLY_CVTR_STRS.OBJ_INFO_COORD.c_str(), PLY_CVTR_STRS.OBJ_INFO_COORD.size());
        (void)out.write(PLY_CVTR_STRS.OBJ_INFO_TIMESTAMP.c_str(), PLY_CVTR_STRS.OBJ_INFO_TIMESTAMP.size());
        (void)out.write(PLY_CVTR_STRS.OBJ_INFO_SIZE.c_str(), PLY_CVTR_STRS.OBJ_INFO_SIZE.size());
        out << size << " 1";
        (void)out.write(PLY_CVTR_STRS.LF.c_str(), PLY_CVTR_STRS.LF.size());
        (void)out.write(PLY_CVTR_STRS.OBJ_INFO_DENSE.c_str(), PLY_CVTR_STRS.OBJ_INFO_DENSE.size());
        (void)out.write(PLY_CVTR_STRS.OBJ_INFO_POSE.c_str(), PLY_CVTR_STRS.OBJ_INFO_POSE.size());
        (void)out.write(PLY_CVTR_STRS.ELEMENT.c_str(), PLY_CVTR_STRS.ELEMENT.size());
        out << size;
        (void)out.write(PLY_CVTR_STRS.LF.c_str(), PLY_CVTR_STRS.LF.size());
        (void)out.write(PLY_CVTR_STRS.PROPERTY_X.c_str(), PLY_CVTR_STRS.PROPERTY_X.size());
        (void)out.write(PLY_CVTR_STRS.PROPERTY_Y.c_str(), PLY_CVTR_STRS.PROPERTY_Y.size());
        (void)out.write(PLY_CVTR_STRS.PROPERTY_Z.c_str(), PLY_CVTR_STRS.PROPERTY_Z.size());
        (void)out.write(PLY_CVTR_STRS.PROPERTY_I.c_str(), PLY_CVTR_STRS.PROPERTY_I.size());
        (void)out.write(PLY_CVTR_STRS.PROPERTY_R.c_str(), PLY_CVTR_STRS.PROPERTY_R.size());
        (void)out.write(PLY_CVTR_STRS.PROPERTY_ST.c_str(), PLY_CVTR_STRS.PROPERTY_ST.size());
        (void)out.write(PLY_CVTR_STRS.TAIL.c_str(), PLY_CVTR_STRS.TAIL.size());
        if (ascii)
        {
            for (size_t i = 0; i < size; i++)
            {
                out << std::fixed << std::setprecision(9) << pcd[i].GetX() << " " << pcd[i].GetY() << " "
                    << pcd[i].GetZ() << " " << std::setprecision(0) << pcd[i].GetIntensity() << " " << pcd[i].GetRing()
                    << " " << std::setprecision(9) << pcd[i].GetTimestamp().ToSec() << "\n";
            }
        }
        else  // binary mode
        {
            for (size_t i = 0; i < size; i++)
            {
                float32_t x = pcd[i].GetX();
                float32_t y = pcd[i].GetY();
                float32_t z = pcd[i].GetZ();
                float32_t s = pcd[i].GetIntensity();
                uint32_t  r = pcd[i].GetRing();
                float64_t t = pcd[i].GetTimestamp().ToSec();
                out.write((const char*)&x, sizeof(x));
                out.write((const char*)&y, sizeof(y));
                out.write((const char*)&z, sizeof(z));
                out.write((const char*)&s, sizeof(s));
                out.write((const char*)&r, sizeof(r));
                out.write((const char*)&t, sizeof(t));
            }
        }
        out.close();
        return out.tellp();
    }

private:
    static bool isPathExist(const std::string& path)
    {
        return (access(path.c_str(), 0) == F_OK);
    }

    static bool isFolder(const std::string& path)
    {
        if (!isPathExist(path))
        {
            return false;
        }
        struct stat buffer;
        return (stat(path.c_str(), &buffer) == 0 && S_ISDIR(buffer.st_mode));
    }

    static int absPath(const std::string& input, std::string& output)
    {
        static const size_t MAX_PATH_LENGTH                = 40960u;
        char                resolved_path[MAX_PATH_LENGTH] = {0};
        if (!realpath(input.c_str(), resolved_path))
        {
            if (ENOENT != errno)
            {
                return -1;
            }
        }
        output = std::string(resolved_path);
        return 0;
    }

    static int makeDirectory(const std::string& path, mode_t mode = 0755)
    {
        std::string s;
        if (0 != absPath(path, s))
        {
            return -1;
        }

        if (isFolder(s))
        {
            return 0;
        }

        size_t      pre = 0, pos;
        std::string dir;
        int         mdret = -1;

        if (s[s.size() - 1] != '/')
        {
            s += '/';  // force trailing / so we can handle everything in loop
        }

        while ((pos = s.find_first_of('/', pre)) != std::string::npos)
        {
            dir = s.substr(0, pos++);
            pre = pos;
            if (dir.size() == 0)
                continue;  // if leading / first time is 0 length
            if ((mdret = ::mkdir(dir.c_str(), mode)) && errno != EEXIST)
            {
                return mdret;
            }
            mdret = 0;
        }
        return mdret;
    }
};

}  // namespace sensors
}  // namespace holo

#endif
