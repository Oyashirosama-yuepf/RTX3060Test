// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fusion.proto

#ifndef PROTOBUF_INCLUDED_fusion_2eproto
#define PROTOBUF_INCLUDED_fusion_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_fusion_2eproto 

namespace protobuf_fusion_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[20];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_fusion_2eproto
namespace holo {
namespace perception {
namespace obstacle_fusion {
class AssociationFeature;
class AssociationFeatureDefaultTypeInternal;
extern AssociationFeatureDefaultTypeInternal _AssociationFeature_default_instance_;
class AssociationRule;
class AssociationRuleDefaultTypeInternal;
extern AssociationRuleDefaultTypeInternal _AssociationRule_default_instance_;
class Coords;
class CoordsDefaultTypeInternal;
extern CoordsDefaultTypeInternal _Coords_default_instance_;
class FilterByAreaAndRatio;
class FilterByAreaAndRatioDefaultTypeInternal;
extern FilterByAreaAndRatioDefaultTypeInternal _FilterByAreaAndRatio_default_instance_;
class FilterByClassName;
class FilterByClassNameDefaultTypeInternal;
extern FilterByClassNameDefaultTypeInternal _FilterByClassName_default_instance_;
class FilterByLatency;
class FilterByLatencyDefaultTypeInternal;
extern FilterByLatencyDefaultTypeInternal _FilterByLatency_default_instance_;
class FilterBySize;
class FilterBySizeDefaultTypeInternal;
extern FilterBySizeDefaultTypeInternal _FilterBySize_default_instance_;
class FilterRule;
class FilterRuleDefaultTypeInternal;
extern FilterRuleDefaultTypeInternal _FilterRule_default_instance_;
class FilterRules;
class FilterRulesDefaultTypeInternal;
extern FilterRulesDefaultTypeInternal _FilterRules_default_instance_;
class FusionConfig;
class FusionConfigDefaultTypeInternal;
extern FusionConfigDefaultTypeInternal _FusionConfig_default_instance_;
class IbeoContourPointsSelectRule;
class IbeoContourPointsSelectRuleDefaultTypeInternal;
extern IbeoContourPointsSelectRuleDefaultTypeInternal _IbeoContourPointsSelectRule_default_instance_;
class ObstacleCoord;
class ObstacleCoordDefaultTypeInternal;
extern ObstacleCoordDefaultTypeInternal _ObstacleCoord_default_instance_;
class PointXY;
class PointXYDefaultTypeInternal;
extern PointXYDefaultTypeInternal _PointXY_default_instance_;
class RadarMergeThreshold;
class RadarMergeThresholdDefaultTypeInternal;
extern RadarMergeThresholdDefaultTypeInternal _RadarMergeThreshold_default_instance_;
class RectangularArea;
class RectangularAreaDefaultTypeInternal;
extern RectangularAreaDefaultTypeInternal _RectangularArea_default_instance_;
class SensorAssociationRule;
class SensorAssociationRuleDefaultTypeInternal;
extern SensorAssociationRuleDefaultTypeInternal _SensorAssociationRule_default_instance_;
class SensorFilterRule;
class SensorFilterRuleDefaultTypeInternal;
extern SensorFilterRuleDefaultTypeInternal _SensorFilterRule_default_instance_;
class SensorStageManagementRule;
class SensorStageManagementRuleDefaultTypeInternal;
extern SensorStageManagementRuleDefaultTypeInternal _SensorStageManagementRule_default_instance_;
class StageManagementRule;
class StageManagementRuleDefaultTypeInternal;
extern StageManagementRuleDefaultTypeInternal _StageManagementRule_default_instance_;
class Zone;
class ZoneDefaultTypeInternal;
extern ZoneDefaultTypeInternal _Zone_default_instance_;
}  // namespace obstacle_fusion
}  // namespace perception
}  // namespace holo
namespace google {
namespace protobuf {
template<> ::holo::perception::obstacle_fusion::AssociationFeature* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::AssociationFeature>(Arena*);
template<> ::holo::perception::obstacle_fusion::AssociationRule* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::AssociationRule>(Arena*);
template<> ::holo::perception::obstacle_fusion::Coords* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::Coords>(Arena*);
template<> ::holo::perception::obstacle_fusion::FilterByAreaAndRatio* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterByAreaAndRatio>(Arena*);
template<> ::holo::perception::obstacle_fusion::FilterByClassName* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterByClassName>(Arena*);
template<> ::holo::perception::obstacle_fusion::FilterByLatency* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterByLatency>(Arena*);
template<> ::holo::perception::obstacle_fusion::FilterBySize* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterBySize>(Arena*);
template<> ::holo::perception::obstacle_fusion::FilterRule* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterRule>(Arena*);
template<> ::holo::perception::obstacle_fusion::FilterRules* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterRules>(Arena*);
template<> ::holo::perception::obstacle_fusion::FusionConfig* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::FusionConfig>(Arena*);
template<> ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule>(Arena*);
template<> ::holo::perception::obstacle_fusion::ObstacleCoord* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::ObstacleCoord>(Arena*);
template<> ::holo::perception::obstacle_fusion::PointXY* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::PointXY>(Arena*);
template<> ::holo::perception::obstacle_fusion::RadarMergeThreshold* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::RadarMergeThreshold>(Arena*);
template<> ::holo::perception::obstacle_fusion::RectangularArea* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::RectangularArea>(Arena*);
template<> ::holo::perception::obstacle_fusion::SensorAssociationRule* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::SensorAssociationRule>(Arena*);
template<> ::holo::perception::obstacle_fusion::SensorFilterRule* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::SensorFilterRule>(Arena*);
template<> ::holo::perception::obstacle_fusion::SensorStageManagementRule* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::SensorStageManagementRule>(Arena*);
template<> ::holo::perception::obstacle_fusion::StageManagementRule* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::StageManagementRule>(Arena*);
template<> ::holo::perception::obstacle_fusion::Zone* Arena::CreateMaybeMessage<::holo::perception::obstacle_fusion::Zone>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace holo {
namespace perception {
namespace obstacle_fusion {

// ===================================================================

class PointXY : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.PointXY) */ {
 public:
  PointXY();
  virtual ~PointXY();

  PointXY(const PointXY& from);

  inline PointXY& operator=(const PointXY& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PointXY(PointXY&& from) noexcept
    : PointXY() {
    *this = ::std::move(from);
  }

  inline PointXY& operator=(PointXY&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PointXY& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PointXY* internal_default_instance() {
    return reinterpret_cast<const PointXY*>(
               &_PointXY_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(PointXY* other);
  friend void swap(PointXY& a, PointXY& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PointXY* New() const final {
    return CreateMaybeMessage<PointXY>(NULL);
  }

  PointXY* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PointXY>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PointXY& from);
  void MergeFrom(const PointXY& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PointXY* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.PointXY)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Zone : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.Zone) */ {
 public:
  Zone();
  virtual ~Zone();

  Zone(const Zone& from);

  inline Zone& operator=(const Zone& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Zone(Zone&& from) noexcept
    : Zone() {
    *this = ::std::move(from);
  }

  inline Zone& operator=(Zone&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Zone& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Zone* internal_default_instance() {
    return reinterpret_cast<const Zone*>(
               &_Zone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Zone* other);
  friend void swap(Zone& a, Zone& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Zone* New() const final {
    return CreateMaybeMessage<Zone>(NULL);
  }

  Zone* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Zone>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Zone& from);
  void MergeFrom(const Zone& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Zone* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.perception.obstacle_fusion.PointXY point = 1;
  int point_size() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  ::holo::perception::obstacle_fusion::PointXY* mutable_point(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::PointXY >*
      mutable_point();
  const ::holo::perception::obstacle_fusion::PointXY& point(int index) const;
  ::holo::perception::obstacle_fusion::PointXY* add_point();
  const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::PointXY >&
      point() const;

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.Zone)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::PointXY > point_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FilterBySize : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.FilterBySize) */ {
 public:
  FilterBySize();
  virtual ~FilterBySize();

  FilterBySize(const FilterBySize& from);

  inline FilterBySize& operator=(const FilterBySize& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilterBySize(FilterBySize&& from) noexcept
    : FilterBySize() {
    *this = ::std::move(from);
  }

  inline FilterBySize& operator=(FilterBySize&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterBySize& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterBySize* internal_default_instance() {
    return reinterpret_cast<const FilterBySize*>(
               &_FilterBySize_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FilterBySize* other);
  friend void swap(FilterBySize& a, FilterBySize& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilterBySize* New() const final {
    return CreateMaybeMessage<FilterBySize>(NULL);
  }

  FilterBySize* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FilterBySize>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FilterBySize& from);
  void MergeFrom(const FilterBySize& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterBySize* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool flag_is_max = 1;
  bool has_flag_is_max() const;
  void clear_flag_is_max();
  static const int kFlagIsMaxFieldNumber = 1;
  bool flag_is_max() const;
  void set_flag_is_max(bool value);

  // optional float max_size = 2;
  bool has_max_size() const;
  void clear_max_size();
  static const int kMaxSizeFieldNumber = 2;
  float max_size() const;
  void set_max_size(float value);

  // optional float min_size = 3;
  bool has_min_size() const;
  void clear_min_size();
  static const int kMinSizeFieldNumber = 3;
  float min_size() const;
  void set_min_size(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.FilterBySize)
 private:
  void set_has_flag_is_max();
  void clear_has_flag_is_max();
  void set_has_max_size();
  void clear_has_max_size();
  void set_has_min_size();
  void clear_has_min_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool flag_is_max_;
  float max_size_;
  float min_size_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FilterByLatency : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.FilterByLatency) */ {
 public:
  FilterByLatency();
  virtual ~FilterByLatency();

  FilterByLatency(const FilterByLatency& from);

  inline FilterByLatency& operator=(const FilterByLatency& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilterByLatency(FilterByLatency&& from) noexcept
    : FilterByLatency() {
    *this = ::std::move(from);
  }

  inline FilterByLatency& operator=(FilterByLatency&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterByLatency& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterByLatency* internal_default_instance() {
    return reinterpret_cast<const FilterByLatency*>(
               &_FilterByLatency_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FilterByLatency* other);
  friend void swap(FilterByLatency& a, FilterByLatency& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilterByLatency* New() const final {
    return CreateMaybeMessage<FilterByLatency>(NULL);
  }

  FilterByLatency* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FilterByLatency>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FilterByLatency& from);
  void MergeFrom(const FilterByLatency& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterByLatency* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float max_latency = 1;
  bool has_max_latency() const;
  void clear_max_latency();
  static const int kMaxLatencyFieldNumber = 1;
  float max_latency() const;
  void set_max_latency(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.FilterByLatency)
 private:
  void set_has_max_latency();
  void clear_has_max_latency();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float max_latency_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FilterByAreaAndRatio : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.FilterByAreaAndRatio) */ {
 public:
  FilterByAreaAndRatio();
  virtual ~FilterByAreaAndRatio();

  FilterByAreaAndRatio(const FilterByAreaAndRatio& from);

  inline FilterByAreaAndRatio& operator=(const FilterByAreaAndRatio& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilterByAreaAndRatio(FilterByAreaAndRatio&& from) noexcept
    : FilterByAreaAndRatio() {
    *this = ::std::move(from);
  }

  inline FilterByAreaAndRatio& operator=(FilterByAreaAndRatio&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterByAreaAndRatio& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterByAreaAndRatio* internal_default_instance() {
    return reinterpret_cast<const FilterByAreaAndRatio*>(
               &_FilterByAreaAndRatio_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FilterByAreaAndRatio* other);
  friend void swap(FilterByAreaAndRatio& a, FilterByAreaAndRatio& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilterByAreaAndRatio* New() const final {
    return CreateMaybeMessage<FilterByAreaAndRatio>(NULL);
  }

  FilterByAreaAndRatio* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FilterByAreaAndRatio>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FilterByAreaAndRatio& from);
  void MergeFrom(const FilterByAreaAndRatio& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterByAreaAndRatio* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float max_area = 1;
  bool has_max_area() const;
  void clear_max_area();
  static const int kMaxAreaFieldNumber = 1;
  float max_area() const;
  void set_max_area(float value);

  // optional float max_ratio = 2;
  bool has_max_ratio() const;
  void clear_max_ratio();
  static const int kMaxRatioFieldNumber = 2;
  float max_ratio() const;
  void set_max_ratio(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.FilterByAreaAndRatio)
 private:
  void set_has_max_area();
  void clear_has_max_area();
  void set_has_max_ratio();
  void clear_has_max_ratio();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float max_area_;
  float max_ratio_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FilterByClassName : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.FilterByClassName) */ {
 public:
  FilterByClassName();
  virtual ~FilterByClassName();

  FilterByClassName(const FilterByClassName& from);

  inline FilterByClassName& operator=(const FilterByClassName& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilterByClassName(FilterByClassName&& from) noexcept
    : FilterByClassName() {
    *this = ::std::move(from);
  }

  inline FilterByClassName& operator=(FilterByClassName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterByClassName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterByClassName* internal_default_instance() {
    return reinterpret_cast<const FilterByClassName*>(
               &_FilterByClassName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FilterByClassName* other);
  friend void swap(FilterByClassName& a, FilterByClassName& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilterByClassName* New() const final {
    return CreateMaybeMessage<FilterByClassName>(NULL);
  }

  FilterByClassName* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FilterByClassName>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FilterByClassName& from);
  void MergeFrom(const FilterByClassName& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterByClassName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string class_name = 1;
  bool has_class_name() const;
  void clear_class_name();
  static const int kClassNameFieldNumber = 1;
  const ::std::string& class_name() const;
  void set_class_name(const ::std::string& value);
  #if LANG_CXX11
  void set_class_name(::std::string&& value);
  #endif
  void set_class_name(const char* value);
  void set_class_name(const char* value, size_t size);
  ::std::string* mutable_class_name();
  ::std::string* release_class_name();
  void set_allocated_class_name(::std::string* class_name);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.FilterByClassName)
 private:
  void set_has_class_name();
  void clear_has_class_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr class_name_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FilterRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.FilterRule) */ {
 public:
  FilterRule();
  virtual ~FilterRule();

  FilterRule(const FilterRule& from);

  inline FilterRule& operator=(const FilterRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilterRule(FilterRule&& from) noexcept
    : FilterRule() {
    *this = ::std::move(from);
  }

  inline FilterRule& operator=(FilterRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterRule* internal_default_instance() {
    return reinterpret_cast<const FilterRule*>(
               &_FilterRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FilterRule* other);
  friend void swap(FilterRule& a, FilterRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilterRule* New() const final {
    return CreateMaybeMessage<FilterRule>(NULL);
  }

  FilterRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FilterRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FilterRule& from);
  void MergeFrom(const FilterRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .holo.perception.obstacle_fusion.Zone filter_work_zone = 1;
  bool has_filter_work_zone() const;
  void clear_filter_work_zone();
  static const int kFilterWorkZoneFieldNumber = 1;
  private:
  const ::holo::perception::obstacle_fusion::Zone& _internal_filter_work_zone() const;
  public:
  const ::holo::perception::obstacle_fusion::Zone& filter_work_zone() const;
  ::holo::perception::obstacle_fusion::Zone* release_filter_work_zone();
  ::holo::perception::obstacle_fusion::Zone* mutable_filter_work_zone();
  void set_allocated_filter_work_zone(::holo::perception::obstacle_fusion::Zone* filter_work_zone);

  // optional .holo.perception.obstacle_fusion.FilterBySize filter_by_size = 2;
  bool has_filter_by_size() const;
  void clear_filter_by_size();
  static const int kFilterBySizeFieldNumber = 2;
  private:
  const ::holo::perception::obstacle_fusion::FilterBySize& _internal_filter_by_size() const;
  public:
  const ::holo::perception::obstacle_fusion::FilterBySize& filter_by_size() const;
  ::holo::perception::obstacle_fusion::FilterBySize* release_filter_by_size();
  ::holo::perception::obstacle_fusion::FilterBySize* mutable_filter_by_size();
  void set_allocated_filter_by_size(::holo::perception::obstacle_fusion::FilterBySize* filter_by_size);

  // optional .holo.perception.obstacle_fusion.FilterByLatency filter_by_latency = 3;
  bool has_filter_by_latency() const;
  void clear_filter_by_latency();
  static const int kFilterByLatencyFieldNumber = 3;
  private:
  const ::holo::perception::obstacle_fusion::FilterByLatency& _internal_filter_by_latency() const;
  public:
  const ::holo::perception::obstacle_fusion::FilterByLatency& filter_by_latency() const;
  ::holo::perception::obstacle_fusion::FilterByLatency* release_filter_by_latency();
  ::holo::perception::obstacle_fusion::FilterByLatency* mutable_filter_by_latency();
  void set_allocated_filter_by_latency(::holo::perception::obstacle_fusion::FilterByLatency* filter_by_latency);

  // optional .holo.perception.obstacle_fusion.FilterByAreaAndRatio filter_by_area_and_ratio = 4;
  bool has_filter_by_area_and_ratio() const;
  void clear_filter_by_area_and_ratio();
  static const int kFilterByAreaAndRatioFieldNumber = 4;
  private:
  const ::holo::perception::obstacle_fusion::FilterByAreaAndRatio& _internal_filter_by_area_and_ratio() const;
  public:
  const ::holo::perception::obstacle_fusion::FilterByAreaAndRatio& filter_by_area_and_ratio() const;
  ::holo::perception::obstacle_fusion::FilterByAreaAndRatio* release_filter_by_area_and_ratio();
  ::holo::perception::obstacle_fusion::FilterByAreaAndRatio* mutable_filter_by_area_and_ratio();
  void set_allocated_filter_by_area_and_ratio(::holo::perception::obstacle_fusion::FilterByAreaAndRatio* filter_by_area_and_ratio);

  // optional .holo.perception.obstacle_fusion.FilterByClassName filter_by_class_name = 5;
  bool has_filter_by_class_name() const;
  void clear_filter_by_class_name();
  static const int kFilterByClassNameFieldNumber = 5;
  private:
  const ::holo::perception::obstacle_fusion::FilterByClassName& _internal_filter_by_class_name() const;
  public:
  const ::holo::perception::obstacle_fusion::FilterByClassName& filter_by_class_name() const;
  ::holo::perception::obstacle_fusion::FilterByClassName* release_filter_by_class_name();
  ::holo::perception::obstacle_fusion::FilterByClassName* mutable_filter_by_class_name();
  void set_allocated_filter_by_class_name(::holo::perception::obstacle_fusion::FilterByClassName* filter_by_class_name);

  // optional bool filter_by_flag = 6;
  bool has_filter_by_flag() const;
  void clear_filter_by_flag();
  static const int kFilterByFlagFieldNumber = 6;
  bool filter_by_flag() const;
  void set_filter_by_flag(bool value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.FilterRule)
 private:
  void set_has_filter_work_zone();
  void clear_has_filter_work_zone();
  void set_has_filter_by_size();
  void clear_has_filter_by_size();
  void set_has_filter_by_latency();
  void clear_has_filter_by_latency();
  void set_has_filter_by_area_and_ratio();
  void clear_has_filter_by_area_and_ratio();
  void set_has_filter_by_class_name();
  void clear_has_filter_by_class_name();
  void set_has_filter_by_flag();
  void clear_has_filter_by_flag();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::perception::obstacle_fusion::Zone* filter_work_zone_;
  ::holo::perception::obstacle_fusion::FilterBySize* filter_by_size_;
  ::holo::perception::obstacle_fusion::FilterByLatency* filter_by_latency_;
  ::holo::perception::obstacle_fusion::FilterByAreaAndRatio* filter_by_area_and_ratio_;
  ::holo::perception::obstacle_fusion::FilterByClassName* filter_by_class_name_;
  bool filter_by_flag_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorFilterRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.SensorFilterRule) */ {
 public:
  SensorFilterRule();
  virtual ~SensorFilterRule();

  SensorFilterRule(const SensorFilterRule& from);

  inline SensorFilterRule& operator=(const SensorFilterRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorFilterRule(SensorFilterRule&& from) noexcept
    : SensorFilterRule() {
    *this = ::std::move(from);
  }

  inline SensorFilterRule& operator=(SensorFilterRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorFilterRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorFilterRule* internal_default_instance() {
    return reinterpret_cast<const SensorFilterRule*>(
               &_SensorFilterRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(SensorFilterRule* other);
  friend void swap(SensorFilterRule& a, SensorFilterRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorFilterRule* New() const final {
    return CreateMaybeMessage<SensorFilterRule>(NULL);
  }

  SensorFilterRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorFilterRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorFilterRule& from);
  void MergeFrom(const SensorFilterRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorFilterRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.perception.obstacle_fusion.FilterRule filter_rule = 4;
  int filter_rule_size() const;
  void clear_filter_rule();
  static const int kFilterRuleFieldNumber = 4;
  ::holo::perception::obstacle_fusion::FilterRule* mutable_filter_rule(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::FilterRule >*
      mutable_filter_rule();
  const ::holo::perception::obstacle_fusion::FilterRule& filter_rule(int index) const;
  ::holo::perception::obstacle_fusion::FilterRule* add_filter_rule();
  const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::FilterRule >&
      filter_rule() const;

  // optional string sensor_type = 1;
  bool has_sensor_type() const;
  void clear_sensor_type();
  static const int kSensorTypeFieldNumber = 1;
  const ::std::string& sensor_type() const;
  void set_sensor_type(const ::std::string& value);
  #if LANG_CXX11
  void set_sensor_type(::std::string&& value);
  #endif
  void set_sensor_type(const char* value);
  void set_sensor_type(const char* value, size_t size);
  ::std::string* mutable_sensor_type();
  ::std::string* release_sensor_type();
  void set_allocated_sensor_type(::std::string* sensor_type);

  // optional string sensor_location = 2;
  bool has_sensor_location() const;
  void clear_sensor_location();
  static const int kSensorLocationFieldNumber = 2;
  const ::std::string& sensor_location() const;
  void set_sensor_location(const ::std::string& value);
  #if LANG_CXX11
  void set_sensor_location(::std::string&& value);
  #endif
  void set_sensor_location(const char* value);
  void set_sensor_location(const char* value, size_t size);
  ::std::string* mutable_sensor_location();
  ::std::string* release_sensor_location();
  void set_allocated_sensor_location(::std::string* sensor_location);

  // optional .holo.perception.obstacle_fusion.Zone sensor_work_zone = 3;
  bool has_sensor_work_zone() const;
  void clear_sensor_work_zone();
  static const int kSensorWorkZoneFieldNumber = 3;
  private:
  const ::holo::perception::obstacle_fusion::Zone& _internal_sensor_work_zone() const;
  public:
  const ::holo::perception::obstacle_fusion::Zone& sensor_work_zone() const;
  ::holo::perception::obstacle_fusion::Zone* release_sensor_work_zone();
  ::holo::perception::obstacle_fusion::Zone* mutable_sensor_work_zone();
  void set_allocated_sensor_work_zone(::holo::perception::obstacle_fusion::Zone* sensor_work_zone);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.SensorFilterRule)
 private:
  void set_has_sensor_type();
  void clear_has_sensor_type();
  void set_has_sensor_location();
  void clear_has_sensor_location();
  void set_has_sensor_work_zone();
  void clear_has_sensor_work_zone();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::FilterRule > filter_rule_;
  ::google::protobuf::internal::ArenaStringPtr sensor_type_;
  ::google::protobuf::internal::ArenaStringPtr sensor_location_;
  ::holo::perception::obstacle_fusion::Zone* sensor_work_zone_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FilterRules : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.FilterRules) */ {
 public:
  FilterRules();
  virtual ~FilterRules();

  FilterRules(const FilterRules& from);

  inline FilterRules& operator=(const FilterRules& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FilterRules(FilterRules&& from) noexcept
    : FilterRules() {
    *this = ::std::move(from);
  }

  inline FilterRules& operator=(FilterRules&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FilterRules& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FilterRules* internal_default_instance() {
    return reinterpret_cast<const FilterRules*>(
               &_FilterRules_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(FilterRules* other);
  friend void swap(FilterRules& a, FilterRules& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FilterRules* New() const final {
    return CreateMaybeMessage<FilterRules>(NULL);
  }

  FilterRules* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FilterRules>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FilterRules& from);
  void MergeFrom(const FilterRules& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FilterRules* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.perception.obstacle_fusion.SensorFilterRule sensor_filter_rule = 2;
  int sensor_filter_rule_size() const;
  void clear_sensor_filter_rule();
  static const int kSensorFilterRuleFieldNumber = 2;
  ::holo::perception::obstacle_fusion::SensorFilterRule* mutable_sensor_filter_rule(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorFilterRule >*
      mutable_sensor_filter_rule();
  const ::holo::perception::obstacle_fusion::SensorFilterRule& sensor_filter_rule(int index) const;
  ::holo::perception::obstacle_fusion::SensorFilterRule* add_sensor_filter_rule();
  const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorFilterRule >&
      sensor_filter_rule() const;

  // optional string filter_rules_name = 1;
  bool has_filter_rules_name() const;
  void clear_filter_rules_name();
  static const int kFilterRulesNameFieldNumber = 1;
  const ::std::string& filter_rules_name() const;
  void set_filter_rules_name(const ::std::string& value);
  #if LANG_CXX11
  void set_filter_rules_name(::std::string&& value);
  #endif
  void set_filter_rules_name(const char* value);
  void set_filter_rules_name(const char* value, size_t size);
  ::std::string* mutable_filter_rules_name();
  ::std::string* release_filter_rules_name();
  void set_allocated_filter_rules_name(::std::string* filter_rules_name);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.FilterRules)
 private:
  void set_has_filter_rules_name();
  void clear_has_filter_rules_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorFilterRule > sensor_filter_rule_;
  ::google::protobuf::internal::ArenaStringPtr filter_rules_name_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssociationFeature : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.AssociationFeature) */ {
 public:
  AssociationFeature();
  virtual ~AssociationFeature();

  AssociationFeature(const AssociationFeature& from);

  inline AssociationFeature& operator=(const AssociationFeature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssociationFeature(AssociationFeature&& from) noexcept
    : AssociationFeature() {
    *this = ::std::move(from);
  }

  inline AssociationFeature& operator=(AssociationFeature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssociationFeature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssociationFeature* internal_default_instance() {
    return reinterpret_cast<const AssociationFeature*>(
               &_AssociationFeature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(AssociationFeature* other);
  friend void swap(AssociationFeature& a, AssociationFeature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssociationFeature* New() const final {
    return CreateMaybeMessage<AssociationFeature>(NULL);
  }

  AssociationFeature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssociationFeature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssociationFeature& from);
  void MergeFrom(const AssociationFeature& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssociationFeature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float delta_x = 1;
  bool has_delta_x() const;
  void clear_delta_x();
  static const int kDeltaXFieldNumber = 1;
  float delta_x() const;
  void set_delta_x(float value);

  // optional float delta_y = 2;
  bool has_delta_y() const;
  void clear_delta_y();
  static const int kDeltaYFieldNumber = 2;
  float delta_y() const;
  void set_delta_y(float value);

  // optional float delta_vx = 3;
  bool has_delta_vx() const;
  void clear_delta_vx();
  static const int kDeltaVxFieldNumber = 3;
  float delta_vx() const;
  void set_delta_vx(float value);

  // optional float delta_vy = 4;
  bool has_delta_vy() const;
  void clear_delta_vy();
  static const int kDeltaVyFieldNumber = 4;
  float delta_vy() const;
  void set_delta_vy(float value);

  // optional float var_x = 5;
  bool has_var_x() const;
  void clear_var_x();
  static const int kVarXFieldNumber = 5;
  float var_x() const;
  void set_var_x(float value);

  // optional float var_y = 6;
  bool has_var_y() const;
  void clear_var_y();
  static const int kVarYFieldNumber = 6;
  float var_y() const;
  void set_var_y(float value);

  // optional float var_vx = 7;
  bool has_var_vx() const;
  void clear_var_vx();
  static const int kVarVxFieldNumber = 7;
  float var_vx() const;
  void set_var_vx(float value);

  // optional float var_vy = 8;
  bool has_var_vy() const;
  void clear_var_vy();
  static const int kVarVyFieldNumber = 8;
  float var_vy() const;
  void set_var_vy(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.AssociationFeature)
 private:
  void set_has_delta_x();
  void clear_has_delta_x();
  void set_has_delta_y();
  void clear_has_delta_y();
  void set_has_delta_vx();
  void clear_has_delta_vx();
  void set_has_delta_vy();
  void clear_has_delta_vy();
  void set_has_var_x();
  void clear_has_var_x();
  void set_has_var_y();
  void clear_has_var_y();
  void set_has_var_vx();
  void clear_has_var_vx();
  void set_has_var_vy();
  void clear_has_var_vy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float delta_x_;
  float delta_y_;
  float delta_vx_;
  float delta_vy_;
  float var_x_;
  float var_y_;
  float var_vx_;
  float var_vy_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RectangularArea : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.RectangularArea) */ {
 public:
  RectangularArea();
  virtual ~RectangularArea();

  RectangularArea(const RectangularArea& from);

  inline RectangularArea& operator=(const RectangularArea& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RectangularArea(RectangularArea&& from) noexcept
    : RectangularArea() {
    *this = ::std::move(from);
  }

  inline RectangularArea& operator=(RectangularArea&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RectangularArea& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RectangularArea* internal_default_instance() {
    return reinterpret_cast<const RectangularArea*>(
               &_RectangularArea_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(RectangularArea* other);
  friend void swap(RectangularArea& a, RectangularArea& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RectangularArea* New() const final {
    return CreateMaybeMessage<RectangularArea>(NULL);
  }

  RectangularArea* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RectangularArea>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RectangularArea& from);
  void MergeFrom(const RectangularArea& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RectangularArea* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float w = 3;
  bool has_w() const;
  void clear_w();
  static const int kWFieldNumber = 3;
  float w() const;
  void set_w(float value);

  // optional float h = 4;
  bool has_h() const;
  void clear_h();
  static const int kHFieldNumber = 4;
  float h() const;
  void set_h(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.RectangularArea)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_w();
  void clear_has_w();
  void set_has_h();
  void clear_has_h();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float w_;
  float h_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorAssociationRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.SensorAssociationRule) */ {
 public:
  SensorAssociationRule();
  virtual ~SensorAssociationRule();

  SensorAssociationRule(const SensorAssociationRule& from);

  inline SensorAssociationRule& operator=(const SensorAssociationRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorAssociationRule(SensorAssociationRule&& from) noexcept
    : SensorAssociationRule() {
    *this = ::std::move(from);
  }

  inline SensorAssociationRule& operator=(SensorAssociationRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorAssociationRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorAssociationRule* internal_default_instance() {
    return reinterpret_cast<const SensorAssociationRule*>(
               &_SensorAssociationRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SensorAssociationRule* other);
  friend void swap(SensorAssociationRule& a, SensorAssociationRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorAssociationRule* New() const final {
    return CreateMaybeMessage<SensorAssociationRule>(NULL);
  }

  SensorAssociationRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorAssociationRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorAssociationRule& from);
  void MergeFrom(const SensorAssociationRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorAssociationRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string sensor_type = 2;
  bool has_sensor_type() const;
  void clear_sensor_type();
  static const int kSensorTypeFieldNumber = 2;
  const ::std::string& sensor_type() const;
  void set_sensor_type(const ::std::string& value);
  #if LANG_CXX11
  void set_sensor_type(::std::string&& value);
  #endif
  void set_sensor_type(const char* value);
  void set_sensor_type(const char* value, size_t size);
  ::std::string* mutable_sensor_type();
  ::std::string* release_sensor_type();
  void set_allocated_sensor_type(::std::string* sensor_type);

  // optional string sensor_location = 3;
  bool has_sensor_location() const;
  void clear_sensor_location();
  static const int kSensorLocationFieldNumber = 3;
  const ::std::string& sensor_location() const;
  void set_sensor_location(const ::std::string& value);
  #if LANG_CXX11
  void set_sensor_location(::std::string&& value);
  #endif
  void set_sensor_location(const char* value);
  void set_sensor_location(const char* value, size_t size);
  ::std::string* mutable_sensor_location();
  ::std::string* release_sensor_location();
  void set_allocated_sensor_location(::std::string* sensor_location);

  // optional .holo.perception.obstacle_fusion.RectangularArea area = 4;
  bool has_area() const;
  void clear_area();
  static const int kAreaFieldNumber = 4;
  private:
  const ::holo::perception::obstacle_fusion::RectangularArea& _internal_area() const;
  public:
  const ::holo::perception::obstacle_fusion::RectangularArea& area() const;
  ::holo::perception::obstacle_fusion::RectangularArea* release_area();
  ::holo::perception::obstacle_fusion::RectangularArea* mutable_area();
  void set_allocated_area(::holo::perception::obstacle_fusion::RectangularArea* area);

  // optional .holo.perception.obstacle_fusion.AssociationFeature feature = 5;
  bool has_feature() const;
  void clear_feature();
  static const int kFeatureFieldNumber = 5;
  private:
  const ::holo::perception::obstacle_fusion::AssociationFeature& _internal_feature() const;
  public:
  const ::holo::perception::obstacle_fusion::AssociationFeature& feature() const;
  ::holo::perception::obstacle_fusion::AssociationFeature* release_feature();
  ::holo::perception::obstacle_fusion::AssociationFeature* mutable_feature();
  void set_allocated_feature(::holo::perception::obstacle_fusion::AssociationFeature* feature);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.SensorAssociationRule)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_sensor_type();
  void clear_has_sensor_type();
  void set_has_sensor_location();
  void clear_has_sensor_location();
  void set_has_area();
  void clear_has_area();
  void set_has_feature();
  void clear_has_feature();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr sensor_type_;
  ::google::protobuf::internal::ArenaStringPtr sensor_location_;
  ::holo::perception::obstacle_fusion::RectangularArea* area_;
  ::holo::perception::obstacle_fusion::AssociationFeature* feature_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AssociationRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.AssociationRule) */ {
 public:
  AssociationRule();
  virtual ~AssociationRule();

  AssociationRule(const AssociationRule& from);

  inline AssociationRule& operator=(const AssociationRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AssociationRule(AssociationRule&& from) noexcept
    : AssociationRule() {
    *this = ::std::move(from);
  }

  inline AssociationRule& operator=(AssociationRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AssociationRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AssociationRule* internal_default_instance() {
    return reinterpret_cast<const AssociationRule*>(
               &_AssociationRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(AssociationRule* other);
  friend void swap(AssociationRule& a, AssociationRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AssociationRule* New() const final {
    return CreateMaybeMessage<AssociationRule>(NULL);
  }

  AssociationRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AssociationRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AssociationRule& from);
  void MergeFrom(const AssociationRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AssociationRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.perception.obstacle_fusion.SensorAssociationRule sensor_association_rule = 1;
  int sensor_association_rule_size() const;
  void clear_sensor_association_rule();
  static const int kSensorAssociationRuleFieldNumber = 1;
  ::holo::perception::obstacle_fusion::SensorAssociationRule* mutable_sensor_association_rule(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorAssociationRule >*
      mutable_sensor_association_rule();
  const ::holo::perception::obstacle_fusion::SensorAssociationRule& sensor_association_rule(int index) const;
  ::holo::perception::obstacle_fusion::SensorAssociationRule* add_sensor_association_rule();
  const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorAssociationRule >&
      sensor_association_rule() const;

  // optional uint64 num = 2;
  bool has_num() const;
  void clear_num();
  static const int kNumFieldNumber = 2;
  ::google::protobuf::uint64 num() const;
  void set_num(::google::protobuf::uint64 value);

  // optional float duration = 3;
  bool has_duration() const;
  void clear_duration();
  static const int kDurationFieldNumber = 3;
  float duration() const;
  void set_duration(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.AssociationRule)
 private:
  void set_has_num();
  void clear_has_num();
  void set_has_duration();
  void clear_has_duration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorAssociationRule > sensor_association_rule_;
  ::google::protobuf::uint64 num_;
  float duration_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SensorStageManagementRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.SensorStageManagementRule) */ {
 public:
  SensorStageManagementRule();
  virtual ~SensorStageManagementRule();

  SensorStageManagementRule(const SensorStageManagementRule& from);

  inline SensorStageManagementRule& operator=(const SensorStageManagementRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SensorStageManagementRule(SensorStageManagementRule&& from) noexcept
    : SensorStageManagementRule() {
    *this = ::std::move(from);
  }

  inline SensorStageManagementRule& operator=(SensorStageManagementRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SensorStageManagementRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SensorStageManagementRule* internal_default_instance() {
    return reinterpret_cast<const SensorStageManagementRule*>(
               &_SensorStageManagementRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(SensorStageManagementRule* other);
  friend void swap(SensorStageManagementRule& a, SensorStageManagementRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SensorStageManagementRule* New() const final {
    return CreateMaybeMessage<SensorStageManagementRule>(NULL);
  }

  SensorStageManagementRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SensorStageManagementRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SensorStageManagementRule& from);
  void MergeFrom(const SensorStageManagementRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorStageManagementRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string sensor_type = 1;
  bool has_sensor_type() const;
  void clear_sensor_type();
  static const int kSensorTypeFieldNumber = 1;
  const ::std::string& sensor_type() const;
  void set_sensor_type(const ::std::string& value);
  #if LANG_CXX11
  void set_sensor_type(::std::string&& value);
  #endif
  void set_sensor_type(const char* value);
  void set_sensor_type(const char* value, size_t size);
  ::std::string* mutable_sensor_type();
  ::std::string* release_sensor_type();
  void set_allocated_sensor_type(::std::string* sensor_type);

  // optional string sensor_location = 2;
  bool has_sensor_location() const;
  void clear_sensor_location();
  static const int kSensorLocationFieldNumber = 2;
  const ::std::string& sensor_location() const;
  void set_sensor_location(const ::std::string& value);
  #if LANG_CXX11
  void set_sensor_location(::std::string&& value);
  #endif
  void set_sensor_location(const char* value);
  void set_sensor_location(const char* value, size_t size);
  ::std::string* mutable_sensor_location();
  ::std::string* release_sensor_location();
  void set_allocated_sensor_location(::std::string* sensor_location);

  // optional uint64 value_to_confirm = 3;
  bool has_value_to_confirm() const;
  void clear_value_to_confirm();
  static const int kValueToConfirmFieldNumber = 3;
  ::google::protobuf::uint64 value_to_confirm() const;
  void set_value_to_confirm(::google::protobuf::uint64 value);

  // optional uint64 value_to_terminate = 4;
  bool has_value_to_terminate() const;
  void clear_value_to_terminate();
  static const int kValueToTerminateFieldNumber = 4;
  ::google::protobuf::uint64 value_to_terminate() const;
  void set_value_to_terminate(::google::protobuf::uint64 value);

  // optional float suspend_duration = 5;
  bool has_suspend_duration() const;
  void clear_suspend_duration();
  static const int kSuspendDurationFieldNumber = 5;
  float suspend_duration() const;
  void set_suspend_duration(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.SensorStageManagementRule)
 private:
  void set_has_sensor_type();
  void clear_has_sensor_type();
  void set_has_sensor_location();
  void clear_has_sensor_location();
  void set_has_value_to_confirm();
  void clear_has_value_to_confirm();
  void set_has_value_to_terminate();
  void clear_has_value_to_terminate();
  void set_has_suspend_duration();
  void clear_has_suspend_duration();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr sensor_type_;
  ::google::protobuf::internal::ArenaStringPtr sensor_location_;
  ::google::protobuf::uint64 value_to_confirm_;
  ::google::protobuf::uint64 value_to_terminate_;
  float suspend_duration_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StageManagementRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.StageManagementRule) */ {
 public:
  StageManagementRule();
  virtual ~StageManagementRule();

  StageManagementRule(const StageManagementRule& from);

  inline StageManagementRule& operator=(const StageManagementRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StageManagementRule(StageManagementRule&& from) noexcept
    : StageManagementRule() {
    *this = ::std::move(from);
  }

  inline StageManagementRule& operator=(StageManagementRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StageManagementRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StageManagementRule* internal_default_instance() {
    return reinterpret_cast<const StageManagementRule*>(
               &_StageManagementRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(StageManagementRule* other);
  friend void swap(StageManagementRule& a, StageManagementRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StageManagementRule* New() const final {
    return CreateMaybeMessage<StageManagementRule>(NULL);
  }

  StageManagementRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StageManagementRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StageManagementRule& from);
  void MergeFrom(const StageManagementRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StageManagementRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.perception.obstacle_fusion.SensorStageManagementRule sensor_management_rule = 1;
  int sensor_management_rule_size() const;
  void clear_sensor_management_rule();
  static const int kSensorManagementRuleFieldNumber = 1;
  ::holo::perception::obstacle_fusion::SensorStageManagementRule* mutable_sensor_management_rule(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorStageManagementRule >*
      mutable_sensor_management_rule();
  const ::holo::perception::obstacle_fusion::SensorStageManagementRule& sensor_management_rule(int index) const;
  ::holo::perception::obstacle_fusion::SensorStageManagementRule* add_sensor_management_rule();
  const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorStageManagementRule >&
      sensor_management_rule() const;

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.StageManagementRule)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorStageManagementRule > sensor_management_rule_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ObstacleCoord : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.ObstacleCoord) */ {
 public:
  ObstacleCoord();
  virtual ~ObstacleCoord();

  ObstacleCoord(const ObstacleCoord& from);

  inline ObstacleCoord& operator=(const ObstacleCoord& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObstacleCoord(ObstacleCoord&& from) noexcept
    : ObstacleCoord() {
    *this = ::std::move(from);
  }

  inline ObstacleCoord& operator=(ObstacleCoord&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObstacleCoord& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObstacleCoord* internal_default_instance() {
    return reinterpret_cast<const ObstacleCoord*>(
               &_ObstacleCoord_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ObstacleCoord* other);
  friend void swap(ObstacleCoord& a, ObstacleCoord& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObstacleCoord* New() const final {
    return CreateMaybeMessage<ObstacleCoord>(NULL);
  }

  ObstacleCoord* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObstacleCoord>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObstacleCoord& from);
  void MergeFrom(const ObstacleCoord& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObstacleCoord* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string coord_name = 1;
  bool has_coord_name() const;
  void clear_coord_name();
  static const int kCoordNameFieldNumber = 1;
  const ::std::string& coord_name() const;
  void set_coord_name(const ::std::string& value);
  #if LANG_CXX11
  void set_coord_name(::std::string&& value);
  #endif
  void set_coord_name(const char* value);
  void set_coord_name(const char* value, size_t size);
  ::std::string* mutable_coord_name();
  ::std::string* release_coord_name();
  void set_allocated_coord_name(::std::string* coord_name);

  // optional float x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // optional float y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // optional float z = 4;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // optional float yaw = 5;
  bool has_yaw() const;
  void clear_yaw();
  static const int kYawFieldNumber = 5;
  float yaw() const;
  void set_yaw(float value);

  // optional float pitch = 6;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 6;
  float pitch() const;
  void set_pitch(float value);

  // optional float roll = 7;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 7;
  float roll() const;
  void set_roll(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.ObstacleCoord)
 private:
  void set_has_coord_name();
  void clear_has_coord_name();
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();
  void set_has_yaw();
  void clear_has_yaw();
  void set_has_pitch();
  void clear_has_pitch();
  void set_has_roll();
  void clear_has_roll();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr coord_name_;
  float x_;
  float y_;
  float z_;
  float yaw_;
  float pitch_;
  float roll_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Coords : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.Coords) */ {
 public:
  Coords();
  virtual ~Coords();

  Coords(const Coords& from);

  inline Coords& operator=(const Coords& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Coords(Coords&& from) noexcept
    : Coords() {
    *this = ::std::move(from);
  }

  inline Coords& operator=(Coords&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Coords& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Coords* internal_default_instance() {
    return reinterpret_cast<const Coords*>(
               &_Coords_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Coords* other);
  friend void swap(Coords& a, Coords& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Coords* New() const final {
    return CreateMaybeMessage<Coords>(NULL);
  }

  Coords* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Coords>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Coords& from);
  void MergeFrom(const Coords& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Coords* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.perception.obstacle_fusion.ObstacleCoord coord = 1;
  int coord_size() const;
  void clear_coord();
  static const int kCoordFieldNumber = 1;
  ::holo::perception::obstacle_fusion::ObstacleCoord* mutable_coord(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::ObstacleCoord >*
      mutable_coord();
  const ::holo::perception::obstacle_fusion::ObstacleCoord& coord(int index) const;
  ::holo::perception::obstacle_fusion::ObstacleCoord* add_coord();
  const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::ObstacleCoord >&
      coord() const;

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.Coords)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::ObstacleCoord > coord_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RadarMergeThreshold : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.RadarMergeThreshold) */ {
 public:
  RadarMergeThreshold();
  virtual ~RadarMergeThreshold();

  RadarMergeThreshold(const RadarMergeThreshold& from);

  inline RadarMergeThreshold& operator=(const RadarMergeThreshold& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RadarMergeThreshold(RadarMergeThreshold&& from) noexcept
    : RadarMergeThreshold() {
    *this = ::std::move(from);
  }

  inline RadarMergeThreshold& operator=(RadarMergeThreshold&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RadarMergeThreshold& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RadarMergeThreshold* internal_default_instance() {
    return reinterpret_cast<const RadarMergeThreshold*>(
               &_RadarMergeThreshold_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(RadarMergeThreshold* other);
  friend void swap(RadarMergeThreshold& a, RadarMergeThreshold& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RadarMergeThreshold* New() const final {
    return CreateMaybeMessage<RadarMergeThreshold>(NULL);
  }

  RadarMergeThreshold* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RadarMergeThreshold>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RadarMergeThreshold& from);
  void MergeFrom(const RadarMergeThreshold& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RadarMergeThreshold* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float delta_x = 1;
  bool has_delta_x() const;
  void clear_delta_x();
  static const int kDeltaXFieldNumber = 1;
  float delta_x() const;
  void set_delta_x(float value);

  // optional float delta_y = 2;
  bool has_delta_y() const;
  void clear_delta_y();
  static const int kDeltaYFieldNumber = 2;
  float delta_y() const;
  void set_delta_y(float value);

  // optional float delta_vx = 3;
  bool has_delta_vx() const;
  void clear_delta_vx();
  static const int kDeltaVxFieldNumber = 3;
  float delta_vx() const;
  void set_delta_vx(float value);

  // optional float delta_vy = 4;
  bool has_delta_vy() const;
  void clear_delta_vy();
  static const int kDeltaVyFieldNumber = 4;
  float delta_vy() const;
  void set_delta_vy(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.RadarMergeThreshold)
 private:
  void set_has_delta_x();
  void clear_has_delta_x();
  void set_has_delta_y();
  void clear_has_delta_y();
  void set_has_delta_vx();
  void clear_has_delta_vx();
  void set_has_delta_vy();
  void clear_has_delta_vy();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float delta_x_;
  float delta_y_;
  float delta_vx_;
  float delta_vy_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IbeoContourPointsSelectRule : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule) */ {
 public:
  IbeoContourPointsSelectRule();
  virtual ~IbeoContourPointsSelectRule();

  IbeoContourPointsSelectRule(const IbeoContourPointsSelectRule& from);

  inline IbeoContourPointsSelectRule& operator=(const IbeoContourPointsSelectRule& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IbeoContourPointsSelectRule(IbeoContourPointsSelectRule&& from) noexcept
    : IbeoContourPointsSelectRule() {
    *this = ::std::move(from);
  }

  inline IbeoContourPointsSelectRule& operator=(IbeoContourPointsSelectRule&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IbeoContourPointsSelectRule& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IbeoContourPointsSelectRule* internal_default_instance() {
    return reinterpret_cast<const IbeoContourPointsSelectRule*>(
               &_IbeoContourPointsSelectRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(IbeoContourPointsSelectRule* other);
  friend void swap(IbeoContourPointsSelectRule& a, IbeoContourPointsSelectRule& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IbeoContourPointsSelectRule* New() const final {
    return CreateMaybeMessage<IbeoContourPointsSelectRule>(NULL);
  }

  IbeoContourPointsSelectRule* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IbeoContourPointsSelectRule>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IbeoContourPointsSelectRule& from);
  void MergeFrom(const IbeoContourPointsSelectRule& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IbeoContourPointsSelectRule* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float min_dimension = 1;
  bool has_min_dimension() const;
  void clear_min_dimension();
  static const int kMinDimensionFieldNumber = 1;
  float min_dimension() const;
  void set_min_dimension(float value);

  // optional float max_dimension = 2;
  bool has_max_dimension() const;
  void clear_max_dimension();
  static const int kMaxDimensionFieldNumber = 2;
  float max_dimension() const;
  void set_max_dimension(float value);

  // optional float max_area = 3;
  bool has_max_area() const;
  void clear_max_area();
  static const int kMaxAreaFieldNumber = 3;
  float max_area() const;
  void set_max_area(float value);

  // optional float min_abs_velocity = 4;
  bool has_min_abs_velocity() const;
  void clear_min_abs_velocity();
  static const int kMinAbsVelocityFieldNumber = 4;
  float min_abs_velocity() const;
  void set_min_abs_velocity(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule)
 private:
  void set_has_min_dimension();
  void clear_has_min_dimension();
  void set_has_max_dimension();
  void clear_has_max_dimension();
  void set_has_max_area();
  void clear_has_max_area();
  void set_has_min_abs_velocity();
  void clear_has_min_abs_velocity();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float min_dimension_;
  float max_dimension_;
  float max_area_;
  float min_abs_velocity_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FusionConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.perception.obstacle_fusion.FusionConfig) */ {
 public:
  FusionConfig();
  virtual ~FusionConfig();

  FusionConfig(const FusionConfig& from);

  inline FusionConfig& operator=(const FusionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FusionConfig(FusionConfig&& from) noexcept
    : FusionConfig() {
    *this = ::std::move(from);
  }

  inline FusionConfig& operator=(FusionConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FusionConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FusionConfig* internal_default_instance() {
    return reinterpret_cast<const FusionConfig*>(
               &_FusionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(FusionConfig* other);
  friend void swap(FusionConfig& a, FusionConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FusionConfig* New() const final {
    return CreateMaybeMessage<FusionConfig>(NULL);
  }

  FusionConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FusionConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FusionConfig& from);
  void MergeFrom(const FusionConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FusionConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fusion_config_name = 1;
  bool has_fusion_config_name() const;
  void clear_fusion_config_name();
  static const int kFusionConfigNameFieldNumber = 1;
  const ::std::string& fusion_config_name() const;
  void set_fusion_config_name(const ::std::string& value);
  #if LANG_CXX11
  void set_fusion_config_name(::std::string&& value);
  #endif
  void set_fusion_config_name(const char* value);
  void set_fusion_config_name(const char* value, size_t size);
  ::std::string* mutable_fusion_config_name();
  ::std::string* release_fusion_config_name();
  void set_allocated_fusion_config_name(::std::string* fusion_config_name);

  // optional string roi_config = 15;
  bool has_roi_config() const;
  void clear_roi_config();
  static const int kRoiConfigFieldNumber = 15;
  const ::std::string& roi_config() const;
  void set_roi_config(const ::std::string& value);
  #if LANG_CXX11
  void set_roi_config(::std::string&& value);
  #endif
  void set_roi_config(const char* value);
  void set_roi_config(const char* value, size_t size);
  ::std::string* mutable_roi_config();
  ::std::string* release_roi_config();
  void set_allocated_roi_config(::std::string* roi_config);

  // optional .holo.perception.obstacle_fusion.Coords coords = 2;
  bool has_coords() const;
  void clear_coords();
  static const int kCoordsFieldNumber = 2;
  private:
  const ::holo::perception::obstacle_fusion::Coords& _internal_coords() const;
  public:
  const ::holo::perception::obstacle_fusion::Coords& coords() const;
  ::holo::perception::obstacle_fusion::Coords* release_coords();
  ::holo::perception::obstacle_fusion::Coords* mutable_coords();
  void set_allocated_coords(::holo::perception::obstacle_fusion::Coords* coords);

  // optional .holo.perception.obstacle_fusion.FilterRules filter_rules = 4;
  bool has_filter_rules() const;
  void clear_filter_rules();
  static const int kFilterRulesFieldNumber = 4;
  private:
  const ::holo::perception::obstacle_fusion::FilterRules& _internal_filter_rules() const;
  public:
  const ::holo::perception::obstacle_fusion::FilterRules& filter_rules() const;
  ::holo::perception::obstacle_fusion::FilterRules* release_filter_rules();
  ::holo::perception::obstacle_fusion::FilterRules* mutable_filter_rules();
  void set_allocated_filter_rules(::holo::perception::obstacle_fusion::FilterRules* filter_rules);

  // optional .holo.perception.obstacle_fusion.AssociationRule association_rule = 5;
  bool has_association_rule() const;
  void clear_association_rule();
  static const int kAssociationRuleFieldNumber = 5;
  private:
  const ::holo::perception::obstacle_fusion::AssociationRule& _internal_association_rule() const;
  public:
  const ::holo::perception::obstacle_fusion::AssociationRule& association_rule() const;
  ::holo::perception::obstacle_fusion::AssociationRule* release_association_rule();
  ::holo::perception::obstacle_fusion::AssociationRule* mutable_association_rule();
  void set_allocated_association_rule(::holo::perception::obstacle_fusion::AssociationRule* association_rule);

  // optional .holo.perception.obstacle_fusion.StageManagementRule stage_management_rule = 6;
  bool has_stage_management_rule() const;
  void clear_stage_management_rule();
  static const int kStageManagementRuleFieldNumber = 6;
  private:
  const ::holo::perception::obstacle_fusion::StageManagementRule& _internal_stage_management_rule() const;
  public:
  const ::holo::perception::obstacle_fusion::StageManagementRule& stage_management_rule() const;
  ::holo::perception::obstacle_fusion::StageManagementRule* release_stage_management_rule();
  ::holo::perception::obstacle_fusion::StageManagementRule* mutable_stage_management_rule();
  void set_allocated_stage_management_rule(::holo::perception::obstacle_fusion::StageManagementRule* stage_management_rule);

  // optional .holo.perception.obstacle_fusion.Zone front_view_area = 9;
  bool has_front_view_area() const;
  void clear_front_view_area();
  static const int kFrontViewAreaFieldNumber = 9;
  private:
  const ::holo::perception::obstacle_fusion::Zone& _internal_front_view_area() const;
  public:
  const ::holo::perception::obstacle_fusion::Zone& front_view_area() const;
  ::holo::perception::obstacle_fusion::Zone* release_front_view_area();
  ::holo::perception::obstacle_fusion::Zone* mutable_front_view_area();
  void set_allocated_front_view_area(::holo::perception::obstacle_fusion::Zone* front_view_area);

  // optional .holo.perception.obstacle_fusion.RadarMergeThreshold radar_merge_threshold = 10;
  bool has_radar_merge_threshold() const;
  void clear_radar_merge_threshold();
  static const int kRadarMergeThresholdFieldNumber = 10;
  private:
  const ::holo::perception::obstacle_fusion::RadarMergeThreshold& _internal_radar_merge_threshold() const;
  public:
  const ::holo::perception::obstacle_fusion::RadarMergeThreshold& radar_merge_threshold() const;
  ::holo::perception::obstacle_fusion::RadarMergeThreshold* release_radar_merge_threshold();
  ::holo::perception::obstacle_fusion::RadarMergeThreshold* mutable_radar_merge_threshold();
  void set_allocated_radar_merge_threshold(::holo::perception::obstacle_fusion::RadarMergeThreshold* radar_merge_threshold);

  // optional .holo.perception.obstacle_fusion.IbeoContourPointsSelectRule ibeo_contour_select_rule = 21;
  bool has_ibeo_contour_select_rule() const;
  void clear_ibeo_contour_select_rule();
  static const int kIbeoContourSelectRuleFieldNumber = 21;
  private:
  const ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule& _internal_ibeo_contour_select_rule() const;
  public:
  const ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule& ibeo_contour_select_rule() const;
  ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* release_ibeo_contour_select_rule();
  ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* mutable_ibeo_contour_select_rule();
  void set_allocated_ibeo_contour_select_rule(::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* ibeo_contour_select_rule);

  // optional float snapshot_keep_duration = 3;
  bool has_snapshot_keep_duration() const;
  void clear_snapshot_keep_duration();
  static const int kSnapshotKeepDurationFieldNumber = 3;
  float snapshot_keep_duration() const;
  void set_snapshot_keep_duration(float value);

  // optional float obs_fast_velocity = 7;
  bool has_obs_fast_velocity() const;
  void clear_obs_fast_velocity();
  static const int kObsFastVelocityFieldNumber = 7;
  float obs_fast_velocity() const;
  void set_obs_fast_velocity(float value);

  // optional float obs_slow_velocity = 8;
  bool has_obs_slow_velocity() const;
  void clear_obs_slow_velocity();
  static const int kObsSlowVelocityFieldNumber = 8;
  float obs_slow_velocity() const;
  void set_obs_slow_velocity(float value);

  // optional float obs_min_size = 11;
  bool has_obs_min_size() const;
  void clear_obs_min_size();
  static const int kObsMinSizeFieldNumber = 11;
  float obs_min_size() const;
  void set_obs_min_size(float value);

  // optional uint64 max_deque_size = 12;
  bool has_max_deque_size() const;
  void clear_max_deque_size();
  static const int kMaxDequeSizeFieldNumber = 12;
  ::google::protobuf::uint64 max_deque_size() const;
  void set_max_deque_size(::google::protobuf::uint64 value);

  // optional float max_ibeo_conti_x_diff = 13;
  bool has_max_ibeo_conti_x_diff() const;
  void clear_max_ibeo_conti_x_diff();
  static const int kMaxIbeoContiXDiffFieldNumber = 13;
  float max_ibeo_conti_x_diff() const;
  void set_max_ibeo_conti_x_diff(float value);

  // optional float track_outlier_dt = 14;
  bool has_track_outlier_dt() const;
  void clear_track_outlier_dt();
  static const int kTrackOutlierDtFieldNumber = 14;
  float track_outlier_dt() const;
  void set_track_outlier_dt(float value);

  // optional float overlaped_obs_x = 16;
  bool has_overlaped_obs_x() const;
  void clear_overlaped_obs_x();
  static const int kOverlapedObsXFieldNumber = 16;
  float overlaped_obs_x() const;
  void set_overlaped_obs_x(float value);

  // optional float overlaped_obs_y = 17;
  bool has_overlaped_obs_y() const;
  void clear_overlaped_obs_y();
  static const int kOverlapedObsYFieldNumber = 17;
  float overlaped_obs_y() const;
  void set_overlaped_obs_y(float value);

  // optional float ibeo_double_check_x = 18;
  bool has_ibeo_double_check_x() const;
  void clear_ibeo_double_check_x();
  static const int kIbeoDoubleCheckXFieldNumber = 18;
  float ibeo_double_check_x() const;
  void set_ibeo_double_check_x(float value);

  // optional float ibeo_double_check_big_area = 19;
  bool has_ibeo_double_check_big_area() const;
  void clear_ibeo_double_check_big_area();
  static const int kIbeoDoubleCheckBigAreaFieldNumber = 19;
  float ibeo_double_check_big_area() const;
  void set_ibeo_double_check_big_area(float value);

  // optional float half_lane_width = 20;
  bool has_half_lane_width() const;
  void clear_half_lane_width();
  static const int kHalfLaneWidthFieldNumber = 20;
  float half_lane_width() const;
  void set_half_lane_width(float value);

  // optional float eq3_distant_x = 22;
  bool has_eq3_distant_x() const;
  void clear_eq3_distant_x();
  static const int kEq3DistantXFieldNumber = 22;
  float eq3_distant_x() const;
  void set_eq3_distant_x(float value);

  // optional float eq3_distant_y = 23;
  bool has_eq3_distant_y() const;
  void clear_eq3_distant_y();
  static const int kEq3DistantYFieldNumber = 23;
  float eq3_distant_y() const;
  void set_eq3_distant_y(float value);

  // optional float tjp_mode_speed = 24;
  bool has_tjp_mode_speed() const;
  void clear_tjp_mode_speed();
  static const int kTjpModeSpeedFieldNumber = 24;
  float tjp_mode_speed() const;
  void set_tjp_mode_speed(float value);

  // @@protoc_insertion_point(class_scope:holo.perception.obstacle_fusion.FusionConfig)
 private:
  void set_has_fusion_config_name();
  void clear_has_fusion_config_name();
  void set_has_coords();
  void clear_has_coords();
  void set_has_snapshot_keep_duration();
  void clear_has_snapshot_keep_duration();
  void set_has_filter_rules();
  void clear_has_filter_rules();
  void set_has_association_rule();
  void clear_has_association_rule();
  void set_has_stage_management_rule();
  void clear_has_stage_management_rule();
  void set_has_obs_fast_velocity();
  void clear_has_obs_fast_velocity();
  void set_has_obs_slow_velocity();
  void clear_has_obs_slow_velocity();
  void set_has_front_view_area();
  void clear_has_front_view_area();
  void set_has_radar_merge_threshold();
  void clear_has_radar_merge_threshold();
  void set_has_obs_min_size();
  void clear_has_obs_min_size();
  void set_has_max_deque_size();
  void clear_has_max_deque_size();
  void set_has_max_ibeo_conti_x_diff();
  void clear_has_max_ibeo_conti_x_diff();
  void set_has_track_outlier_dt();
  void clear_has_track_outlier_dt();
  void set_has_roi_config();
  void clear_has_roi_config();
  void set_has_overlaped_obs_x();
  void clear_has_overlaped_obs_x();
  void set_has_overlaped_obs_y();
  void clear_has_overlaped_obs_y();
  void set_has_ibeo_double_check_x();
  void clear_has_ibeo_double_check_x();
  void set_has_ibeo_double_check_big_area();
  void clear_has_ibeo_double_check_big_area();
  void set_has_half_lane_width();
  void clear_has_half_lane_width();
  void set_has_ibeo_contour_select_rule();
  void clear_has_ibeo_contour_select_rule();
  void set_has_eq3_distant_x();
  void clear_has_eq3_distant_x();
  void set_has_eq3_distant_y();
  void clear_has_eq3_distant_y();
  void set_has_tjp_mode_speed();
  void clear_has_tjp_mode_speed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr fusion_config_name_;
  ::google::protobuf::internal::ArenaStringPtr roi_config_;
  ::holo::perception::obstacle_fusion::Coords* coords_;
  ::holo::perception::obstacle_fusion::FilterRules* filter_rules_;
  ::holo::perception::obstacle_fusion::AssociationRule* association_rule_;
  ::holo::perception::obstacle_fusion::StageManagementRule* stage_management_rule_;
  ::holo::perception::obstacle_fusion::Zone* front_view_area_;
  ::holo::perception::obstacle_fusion::RadarMergeThreshold* radar_merge_threshold_;
  ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* ibeo_contour_select_rule_;
  float snapshot_keep_duration_;
  float obs_fast_velocity_;
  float obs_slow_velocity_;
  float obs_min_size_;
  ::google::protobuf::uint64 max_deque_size_;
  float max_ibeo_conti_x_diff_;
  float track_outlier_dt_;
  float overlaped_obs_x_;
  float overlaped_obs_y_;
  float ibeo_double_check_x_;
  float ibeo_double_check_big_area_;
  float half_lane_width_;
  float eq3_distant_x_;
  float eq3_distant_y_;
  float tjp_mode_speed_;
  friend struct ::protobuf_fusion_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PointXY

// optional float x = 1;
inline bool PointXY::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PointXY::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PointXY::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PointXY::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float PointXY::x() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.PointXY.x)
  return x_;
}
inline void PointXY::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.PointXY.x)
}

// optional float y = 2;
inline bool PointXY::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PointXY::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PointXY::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PointXY::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float PointXY::y() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.PointXY.y)
  return y_;
}
inline void PointXY::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.PointXY.y)
}

// -------------------------------------------------------------------

// Zone

// repeated .holo.perception.obstacle_fusion.PointXY point = 1;
inline int Zone::point_size() const {
  return point_.size();
}
inline void Zone::clear_point() {
  point_.Clear();
}
inline ::holo::perception::obstacle_fusion::PointXY* Zone::mutable_point(int index) {
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.Zone.point)
  return point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::PointXY >*
Zone::mutable_point() {
  // @@protoc_insertion_point(field_mutable_list:holo.perception.obstacle_fusion.Zone.point)
  return &point_;
}
inline const ::holo::perception::obstacle_fusion::PointXY& Zone::point(int index) const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.Zone.point)
  return point_.Get(index);
}
inline ::holo::perception::obstacle_fusion::PointXY* Zone::add_point() {
  // @@protoc_insertion_point(field_add:holo.perception.obstacle_fusion.Zone.point)
  return point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::PointXY >&
Zone::point() const {
  // @@protoc_insertion_point(field_list:holo.perception.obstacle_fusion.Zone.point)
  return point_;
}

// -------------------------------------------------------------------

// FilterBySize

// optional bool flag_is_max = 1;
inline bool FilterBySize::has_flag_is_max() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterBySize::set_has_flag_is_max() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterBySize::clear_has_flag_is_max() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterBySize::clear_flag_is_max() {
  flag_is_max_ = false;
  clear_has_flag_is_max();
}
inline bool FilterBySize::flag_is_max() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterBySize.flag_is_max)
  return flag_is_max_;
}
inline void FilterBySize::set_flag_is_max(bool value) {
  set_has_flag_is_max();
  flag_is_max_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FilterBySize.flag_is_max)
}

// optional float max_size = 2;
inline bool FilterBySize::has_max_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterBySize::set_has_max_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterBySize::clear_has_max_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterBySize::clear_max_size() {
  max_size_ = 0;
  clear_has_max_size();
}
inline float FilterBySize::max_size() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterBySize.max_size)
  return max_size_;
}
inline void FilterBySize::set_max_size(float value) {
  set_has_max_size();
  max_size_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FilterBySize.max_size)
}

// optional float min_size = 3;
inline bool FilterBySize::has_min_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterBySize::set_has_min_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterBySize::clear_has_min_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterBySize::clear_min_size() {
  min_size_ = 0;
  clear_has_min_size();
}
inline float FilterBySize::min_size() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterBySize.min_size)
  return min_size_;
}
inline void FilterBySize::set_min_size(float value) {
  set_has_min_size();
  min_size_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FilterBySize.min_size)
}

// -------------------------------------------------------------------

// FilterByLatency

// optional float max_latency = 1;
inline bool FilterByLatency::has_max_latency() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterByLatency::set_has_max_latency() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterByLatency::clear_has_max_latency() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterByLatency::clear_max_latency() {
  max_latency_ = 0;
  clear_has_max_latency();
}
inline float FilterByLatency::max_latency() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterByLatency.max_latency)
  return max_latency_;
}
inline void FilterByLatency::set_max_latency(float value) {
  set_has_max_latency();
  max_latency_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FilterByLatency.max_latency)
}

// -------------------------------------------------------------------

// FilterByAreaAndRatio

// optional float max_area = 1;
inline bool FilterByAreaAndRatio::has_max_area() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterByAreaAndRatio::set_has_max_area() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterByAreaAndRatio::clear_has_max_area() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterByAreaAndRatio::clear_max_area() {
  max_area_ = 0;
  clear_has_max_area();
}
inline float FilterByAreaAndRatio::max_area() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterByAreaAndRatio.max_area)
  return max_area_;
}
inline void FilterByAreaAndRatio::set_max_area(float value) {
  set_has_max_area();
  max_area_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FilterByAreaAndRatio.max_area)
}

// optional float max_ratio = 2;
inline bool FilterByAreaAndRatio::has_max_ratio() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterByAreaAndRatio::set_has_max_ratio() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterByAreaAndRatio::clear_has_max_ratio() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterByAreaAndRatio::clear_max_ratio() {
  max_ratio_ = 0;
  clear_has_max_ratio();
}
inline float FilterByAreaAndRatio::max_ratio() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterByAreaAndRatio.max_ratio)
  return max_ratio_;
}
inline void FilterByAreaAndRatio::set_max_ratio(float value) {
  set_has_max_ratio();
  max_ratio_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FilterByAreaAndRatio.max_ratio)
}

// -------------------------------------------------------------------

// FilterByClassName

// optional string class_name = 1;
inline bool FilterByClassName::has_class_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterByClassName::set_has_class_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterByClassName::clear_has_class_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterByClassName::clear_class_name() {
  class_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_class_name();
}
inline const ::std::string& FilterByClassName::class_name() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterByClassName.class_name)
  return class_name_.GetNoArena();
}
inline void FilterByClassName::set_class_name(const ::std::string& value) {
  set_has_class_name();
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FilterByClassName.class_name)
}
#if LANG_CXX11
inline void FilterByClassName::set_class_name(::std::string&& value) {
  set_has_class_name();
  class_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.FilterByClassName.class_name)
}
#endif
inline void FilterByClassName::set_class_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_class_name();
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.FilterByClassName.class_name)
}
inline void FilterByClassName::set_class_name(const char* value, size_t size) {
  set_has_class_name();
  class_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.FilterByClassName.class_name)
}
inline ::std::string* FilterByClassName::mutable_class_name() {
  set_has_class_name();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FilterByClassName.class_name)
  return class_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FilterByClassName::release_class_name() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FilterByClassName.class_name)
  if (!has_class_name()) {
    return NULL;
  }
  clear_has_class_name();
  return class_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FilterByClassName::set_allocated_class_name(::std::string* class_name) {
  if (class_name != NULL) {
    set_has_class_name();
  } else {
    clear_has_class_name();
  }
  class_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), class_name);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FilterByClassName.class_name)
}

// -------------------------------------------------------------------

// FilterRule

// optional .holo.perception.obstacle_fusion.Zone filter_work_zone = 1;
inline bool FilterRule::has_filter_work_zone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterRule::set_has_filter_work_zone() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterRule::clear_has_filter_work_zone() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterRule::clear_filter_work_zone() {
  if (filter_work_zone_ != NULL) filter_work_zone_->Clear();
  clear_has_filter_work_zone();
}
inline const ::holo::perception::obstacle_fusion::Zone& FilterRule::_internal_filter_work_zone() const {
  return *filter_work_zone_;
}
inline const ::holo::perception::obstacle_fusion::Zone& FilterRule::filter_work_zone() const {
  const ::holo::perception::obstacle_fusion::Zone* p = filter_work_zone_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterRule.filter_work_zone)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::Zone*>(
      &::holo::perception::obstacle_fusion::_Zone_default_instance_);
}
inline ::holo::perception::obstacle_fusion::Zone* FilterRule::release_filter_work_zone() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FilterRule.filter_work_zone)
  clear_has_filter_work_zone();
  ::holo::perception::obstacle_fusion::Zone* temp = filter_work_zone_;
  filter_work_zone_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::Zone* FilterRule::mutable_filter_work_zone() {
  set_has_filter_work_zone();
  if (filter_work_zone_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::Zone>(GetArenaNoVirtual());
    filter_work_zone_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FilterRule.filter_work_zone)
  return filter_work_zone_;
}
inline void FilterRule::set_allocated_filter_work_zone(::holo::perception::obstacle_fusion::Zone* filter_work_zone) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_work_zone_;
  }
  if (filter_work_zone) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter_work_zone = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter_work_zone, submessage_arena);
    }
    set_has_filter_work_zone();
  } else {
    clear_has_filter_work_zone();
  }
  filter_work_zone_ = filter_work_zone;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FilterRule.filter_work_zone)
}

// optional .holo.perception.obstacle_fusion.FilterBySize filter_by_size = 2;
inline bool FilterRule::has_filter_by_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilterRule::set_has_filter_by_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilterRule::clear_has_filter_by_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilterRule::clear_filter_by_size() {
  if (filter_by_size_ != NULL) filter_by_size_->Clear();
  clear_has_filter_by_size();
}
inline const ::holo::perception::obstacle_fusion::FilterBySize& FilterRule::_internal_filter_by_size() const {
  return *filter_by_size_;
}
inline const ::holo::perception::obstacle_fusion::FilterBySize& FilterRule::filter_by_size() const {
  const ::holo::perception::obstacle_fusion::FilterBySize* p = filter_by_size_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterRule.filter_by_size)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::FilterBySize*>(
      &::holo::perception::obstacle_fusion::_FilterBySize_default_instance_);
}
inline ::holo::perception::obstacle_fusion::FilterBySize* FilterRule::release_filter_by_size() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FilterRule.filter_by_size)
  clear_has_filter_by_size();
  ::holo::perception::obstacle_fusion::FilterBySize* temp = filter_by_size_;
  filter_by_size_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::FilterBySize* FilterRule::mutable_filter_by_size() {
  set_has_filter_by_size();
  if (filter_by_size_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterBySize>(GetArenaNoVirtual());
    filter_by_size_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FilterRule.filter_by_size)
  return filter_by_size_;
}
inline void FilterRule::set_allocated_filter_by_size(::holo::perception::obstacle_fusion::FilterBySize* filter_by_size) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_by_size_;
  }
  if (filter_by_size) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter_by_size = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter_by_size, submessage_arena);
    }
    set_has_filter_by_size();
  } else {
    clear_has_filter_by_size();
  }
  filter_by_size_ = filter_by_size;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FilterRule.filter_by_size)
}

// optional .holo.perception.obstacle_fusion.FilterByLatency filter_by_latency = 3;
inline bool FilterRule::has_filter_by_latency() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FilterRule::set_has_filter_by_latency() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FilterRule::clear_has_filter_by_latency() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FilterRule::clear_filter_by_latency() {
  if (filter_by_latency_ != NULL) filter_by_latency_->Clear();
  clear_has_filter_by_latency();
}
inline const ::holo::perception::obstacle_fusion::FilterByLatency& FilterRule::_internal_filter_by_latency() const {
  return *filter_by_latency_;
}
inline const ::holo::perception::obstacle_fusion::FilterByLatency& FilterRule::filter_by_latency() const {
  const ::holo::perception::obstacle_fusion::FilterByLatency* p = filter_by_latency_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterRule.filter_by_latency)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::FilterByLatency*>(
      &::holo::perception::obstacle_fusion::_FilterByLatency_default_instance_);
}
inline ::holo::perception::obstacle_fusion::FilterByLatency* FilterRule::release_filter_by_latency() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FilterRule.filter_by_latency)
  clear_has_filter_by_latency();
  ::holo::perception::obstacle_fusion::FilterByLatency* temp = filter_by_latency_;
  filter_by_latency_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::FilterByLatency* FilterRule::mutable_filter_by_latency() {
  set_has_filter_by_latency();
  if (filter_by_latency_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterByLatency>(GetArenaNoVirtual());
    filter_by_latency_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FilterRule.filter_by_latency)
  return filter_by_latency_;
}
inline void FilterRule::set_allocated_filter_by_latency(::holo::perception::obstacle_fusion::FilterByLatency* filter_by_latency) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_by_latency_;
  }
  if (filter_by_latency) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter_by_latency = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter_by_latency, submessage_arena);
    }
    set_has_filter_by_latency();
  } else {
    clear_has_filter_by_latency();
  }
  filter_by_latency_ = filter_by_latency;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FilterRule.filter_by_latency)
}

// optional .holo.perception.obstacle_fusion.FilterByAreaAndRatio filter_by_area_and_ratio = 4;
inline bool FilterRule::has_filter_by_area_and_ratio() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FilterRule::set_has_filter_by_area_and_ratio() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FilterRule::clear_has_filter_by_area_and_ratio() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FilterRule::clear_filter_by_area_and_ratio() {
  if (filter_by_area_and_ratio_ != NULL) filter_by_area_and_ratio_->Clear();
  clear_has_filter_by_area_and_ratio();
}
inline const ::holo::perception::obstacle_fusion::FilterByAreaAndRatio& FilterRule::_internal_filter_by_area_and_ratio() const {
  return *filter_by_area_and_ratio_;
}
inline const ::holo::perception::obstacle_fusion::FilterByAreaAndRatio& FilterRule::filter_by_area_and_ratio() const {
  const ::holo::perception::obstacle_fusion::FilterByAreaAndRatio* p = filter_by_area_and_ratio_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterRule.filter_by_area_and_ratio)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::FilterByAreaAndRatio*>(
      &::holo::perception::obstacle_fusion::_FilterByAreaAndRatio_default_instance_);
}
inline ::holo::perception::obstacle_fusion::FilterByAreaAndRatio* FilterRule::release_filter_by_area_and_ratio() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FilterRule.filter_by_area_and_ratio)
  clear_has_filter_by_area_and_ratio();
  ::holo::perception::obstacle_fusion::FilterByAreaAndRatio* temp = filter_by_area_and_ratio_;
  filter_by_area_and_ratio_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::FilterByAreaAndRatio* FilterRule::mutable_filter_by_area_and_ratio() {
  set_has_filter_by_area_and_ratio();
  if (filter_by_area_and_ratio_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterByAreaAndRatio>(GetArenaNoVirtual());
    filter_by_area_and_ratio_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FilterRule.filter_by_area_and_ratio)
  return filter_by_area_and_ratio_;
}
inline void FilterRule::set_allocated_filter_by_area_and_ratio(::holo::perception::obstacle_fusion::FilterByAreaAndRatio* filter_by_area_and_ratio) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_by_area_and_ratio_;
  }
  if (filter_by_area_and_ratio) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter_by_area_and_ratio = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter_by_area_and_ratio, submessage_arena);
    }
    set_has_filter_by_area_and_ratio();
  } else {
    clear_has_filter_by_area_and_ratio();
  }
  filter_by_area_and_ratio_ = filter_by_area_and_ratio;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FilterRule.filter_by_area_and_ratio)
}

// optional .holo.perception.obstacle_fusion.FilterByClassName filter_by_class_name = 5;
inline bool FilterRule::has_filter_by_class_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FilterRule::set_has_filter_by_class_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FilterRule::clear_has_filter_by_class_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FilterRule::clear_filter_by_class_name() {
  if (filter_by_class_name_ != NULL) filter_by_class_name_->Clear();
  clear_has_filter_by_class_name();
}
inline const ::holo::perception::obstacle_fusion::FilterByClassName& FilterRule::_internal_filter_by_class_name() const {
  return *filter_by_class_name_;
}
inline const ::holo::perception::obstacle_fusion::FilterByClassName& FilterRule::filter_by_class_name() const {
  const ::holo::perception::obstacle_fusion::FilterByClassName* p = filter_by_class_name_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterRule.filter_by_class_name)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::FilterByClassName*>(
      &::holo::perception::obstacle_fusion::_FilterByClassName_default_instance_);
}
inline ::holo::perception::obstacle_fusion::FilterByClassName* FilterRule::release_filter_by_class_name() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FilterRule.filter_by_class_name)
  clear_has_filter_by_class_name();
  ::holo::perception::obstacle_fusion::FilterByClassName* temp = filter_by_class_name_;
  filter_by_class_name_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::FilterByClassName* FilterRule::mutable_filter_by_class_name() {
  set_has_filter_by_class_name();
  if (filter_by_class_name_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterByClassName>(GetArenaNoVirtual());
    filter_by_class_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FilterRule.filter_by_class_name)
  return filter_by_class_name_;
}
inline void FilterRule::set_allocated_filter_by_class_name(::holo::perception::obstacle_fusion::FilterByClassName* filter_by_class_name) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_by_class_name_;
  }
  if (filter_by_class_name) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter_by_class_name = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter_by_class_name, submessage_arena);
    }
    set_has_filter_by_class_name();
  } else {
    clear_has_filter_by_class_name();
  }
  filter_by_class_name_ = filter_by_class_name;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FilterRule.filter_by_class_name)
}

// optional bool filter_by_flag = 6;
inline bool FilterRule::has_filter_by_flag() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FilterRule::set_has_filter_by_flag() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FilterRule::clear_has_filter_by_flag() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FilterRule::clear_filter_by_flag() {
  filter_by_flag_ = false;
  clear_has_filter_by_flag();
}
inline bool FilterRule::filter_by_flag() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterRule.filter_by_flag)
  return filter_by_flag_;
}
inline void FilterRule::set_filter_by_flag(bool value) {
  set_has_filter_by_flag();
  filter_by_flag_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FilterRule.filter_by_flag)
}

// -------------------------------------------------------------------

// SensorFilterRule

// optional string sensor_type = 1;
inline bool SensorFilterRule::has_sensor_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorFilterRule::set_has_sensor_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorFilterRule::clear_has_sensor_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorFilterRule::clear_sensor_type() {
  sensor_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensor_type();
}
inline const ::std::string& SensorFilterRule::sensor_type() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorFilterRule.sensor_type)
  return sensor_type_.GetNoArena();
}
inline void SensorFilterRule::set_sensor_type(const ::std::string& value) {
  set_has_sensor_type();
  sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorFilterRule.sensor_type)
}
#if LANG_CXX11
inline void SensorFilterRule::set_sensor_type(::std::string&& value) {
  set_has_sensor_type();
  sensor_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.SensorFilterRule.sensor_type)
}
#endif
inline void SensorFilterRule::set_sensor_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sensor_type();
  sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.SensorFilterRule.sensor_type)
}
inline void SensorFilterRule::set_sensor_type(const char* value, size_t size) {
  set_has_sensor_type();
  sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.SensorFilterRule.sensor_type)
}
inline ::std::string* SensorFilterRule::mutable_sensor_type() {
  set_has_sensor_type();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorFilterRule.sensor_type)
  return sensor_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorFilterRule::release_sensor_type() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorFilterRule.sensor_type)
  if (!has_sensor_type()) {
    return NULL;
  }
  clear_has_sensor_type();
  return sensor_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorFilterRule::set_allocated_sensor_type(::std::string* sensor_type) {
  if (sensor_type != NULL) {
    set_has_sensor_type();
  } else {
    clear_has_sensor_type();
  }
  sensor_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_type);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorFilterRule.sensor_type)
}

// optional string sensor_location = 2;
inline bool SensorFilterRule::has_sensor_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorFilterRule::set_has_sensor_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorFilterRule::clear_has_sensor_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorFilterRule::clear_sensor_location() {
  sensor_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensor_location();
}
inline const ::std::string& SensorFilterRule::sensor_location() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorFilterRule.sensor_location)
  return sensor_location_.GetNoArena();
}
inline void SensorFilterRule::set_sensor_location(const ::std::string& value) {
  set_has_sensor_location();
  sensor_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorFilterRule.sensor_location)
}
#if LANG_CXX11
inline void SensorFilterRule::set_sensor_location(::std::string&& value) {
  set_has_sensor_location();
  sensor_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.SensorFilterRule.sensor_location)
}
#endif
inline void SensorFilterRule::set_sensor_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sensor_location();
  sensor_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.SensorFilterRule.sensor_location)
}
inline void SensorFilterRule::set_sensor_location(const char* value, size_t size) {
  set_has_sensor_location();
  sensor_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.SensorFilterRule.sensor_location)
}
inline ::std::string* SensorFilterRule::mutable_sensor_location() {
  set_has_sensor_location();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorFilterRule.sensor_location)
  return sensor_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorFilterRule::release_sensor_location() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorFilterRule.sensor_location)
  if (!has_sensor_location()) {
    return NULL;
  }
  clear_has_sensor_location();
  return sensor_location_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorFilterRule::set_allocated_sensor_location(::std::string* sensor_location) {
  if (sensor_location != NULL) {
    set_has_sensor_location();
  } else {
    clear_has_sensor_location();
  }
  sensor_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_location);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorFilterRule.sensor_location)
}

// optional .holo.perception.obstacle_fusion.Zone sensor_work_zone = 3;
inline bool SensorFilterRule::has_sensor_work_zone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorFilterRule::set_has_sensor_work_zone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorFilterRule::clear_has_sensor_work_zone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorFilterRule::clear_sensor_work_zone() {
  if (sensor_work_zone_ != NULL) sensor_work_zone_->Clear();
  clear_has_sensor_work_zone();
}
inline const ::holo::perception::obstacle_fusion::Zone& SensorFilterRule::_internal_sensor_work_zone() const {
  return *sensor_work_zone_;
}
inline const ::holo::perception::obstacle_fusion::Zone& SensorFilterRule::sensor_work_zone() const {
  const ::holo::perception::obstacle_fusion::Zone* p = sensor_work_zone_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorFilterRule.sensor_work_zone)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::Zone*>(
      &::holo::perception::obstacle_fusion::_Zone_default_instance_);
}
inline ::holo::perception::obstacle_fusion::Zone* SensorFilterRule::release_sensor_work_zone() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorFilterRule.sensor_work_zone)
  clear_has_sensor_work_zone();
  ::holo::perception::obstacle_fusion::Zone* temp = sensor_work_zone_;
  sensor_work_zone_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::Zone* SensorFilterRule::mutable_sensor_work_zone() {
  set_has_sensor_work_zone();
  if (sensor_work_zone_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::Zone>(GetArenaNoVirtual());
    sensor_work_zone_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorFilterRule.sensor_work_zone)
  return sensor_work_zone_;
}
inline void SensorFilterRule::set_allocated_sensor_work_zone(::holo::perception::obstacle_fusion::Zone* sensor_work_zone) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete sensor_work_zone_;
  }
  if (sensor_work_zone) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      sensor_work_zone = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, sensor_work_zone, submessage_arena);
    }
    set_has_sensor_work_zone();
  } else {
    clear_has_sensor_work_zone();
  }
  sensor_work_zone_ = sensor_work_zone;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorFilterRule.sensor_work_zone)
}

// repeated .holo.perception.obstacle_fusion.FilterRule filter_rule = 4;
inline int SensorFilterRule::filter_rule_size() const {
  return filter_rule_.size();
}
inline void SensorFilterRule::clear_filter_rule() {
  filter_rule_.Clear();
}
inline ::holo::perception::obstacle_fusion::FilterRule* SensorFilterRule::mutable_filter_rule(int index) {
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorFilterRule.filter_rule)
  return filter_rule_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::FilterRule >*
SensorFilterRule::mutable_filter_rule() {
  // @@protoc_insertion_point(field_mutable_list:holo.perception.obstacle_fusion.SensorFilterRule.filter_rule)
  return &filter_rule_;
}
inline const ::holo::perception::obstacle_fusion::FilterRule& SensorFilterRule::filter_rule(int index) const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorFilterRule.filter_rule)
  return filter_rule_.Get(index);
}
inline ::holo::perception::obstacle_fusion::FilterRule* SensorFilterRule::add_filter_rule() {
  // @@protoc_insertion_point(field_add:holo.perception.obstacle_fusion.SensorFilterRule.filter_rule)
  return filter_rule_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::FilterRule >&
SensorFilterRule::filter_rule() const {
  // @@protoc_insertion_point(field_list:holo.perception.obstacle_fusion.SensorFilterRule.filter_rule)
  return filter_rule_;
}

// -------------------------------------------------------------------

// FilterRules

// optional string filter_rules_name = 1;
inline bool FilterRules::has_filter_rules_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilterRules::set_has_filter_rules_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilterRules::clear_has_filter_rules_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilterRules::clear_filter_rules_name() {
  filter_rules_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_filter_rules_name();
}
inline const ::std::string& FilterRules::filter_rules_name() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterRules.filter_rules_name)
  return filter_rules_name_.GetNoArena();
}
inline void FilterRules::set_filter_rules_name(const ::std::string& value) {
  set_has_filter_rules_name();
  filter_rules_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FilterRules.filter_rules_name)
}
#if LANG_CXX11
inline void FilterRules::set_filter_rules_name(::std::string&& value) {
  set_has_filter_rules_name();
  filter_rules_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.FilterRules.filter_rules_name)
}
#endif
inline void FilterRules::set_filter_rules_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_filter_rules_name();
  filter_rules_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.FilterRules.filter_rules_name)
}
inline void FilterRules::set_filter_rules_name(const char* value, size_t size) {
  set_has_filter_rules_name();
  filter_rules_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.FilterRules.filter_rules_name)
}
inline ::std::string* FilterRules::mutable_filter_rules_name() {
  set_has_filter_rules_name();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FilterRules.filter_rules_name)
  return filter_rules_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FilterRules::release_filter_rules_name() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FilterRules.filter_rules_name)
  if (!has_filter_rules_name()) {
    return NULL;
  }
  clear_has_filter_rules_name();
  return filter_rules_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FilterRules::set_allocated_filter_rules_name(::std::string* filter_rules_name) {
  if (filter_rules_name != NULL) {
    set_has_filter_rules_name();
  } else {
    clear_has_filter_rules_name();
  }
  filter_rules_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filter_rules_name);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FilterRules.filter_rules_name)
}

// repeated .holo.perception.obstacle_fusion.SensorFilterRule sensor_filter_rule = 2;
inline int FilterRules::sensor_filter_rule_size() const {
  return sensor_filter_rule_.size();
}
inline void FilterRules::clear_sensor_filter_rule() {
  sensor_filter_rule_.Clear();
}
inline ::holo::perception::obstacle_fusion::SensorFilterRule* FilterRules::mutable_sensor_filter_rule(int index) {
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FilterRules.sensor_filter_rule)
  return sensor_filter_rule_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorFilterRule >*
FilterRules::mutable_sensor_filter_rule() {
  // @@protoc_insertion_point(field_mutable_list:holo.perception.obstacle_fusion.FilterRules.sensor_filter_rule)
  return &sensor_filter_rule_;
}
inline const ::holo::perception::obstacle_fusion::SensorFilterRule& FilterRules::sensor_filter_rule(int index) const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FilterRules.sensor_filter_rule)
  return sensor_filter_rule_.Get(index);
}
inline ::holo::perception::obstacle_fusion::SensorFilterRule* FilterRules::add_sensor_filter_rule() {
  // @@protoc_insertion_point(field_add:holo.perception.obstacle_fusion.FilterRules.sensor_filter_rule)
  return sensor_filter_rule_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorFilterRule >&
FilterRules::sensor_filter_rule() const {
  // @@protoc_insertion_point(field_list:holo.perception.obstacle_fusion.FilterRules.sensor_filter_rule)
  return sensor_filter_rule_;
}

// -------------------------------------------------------------------

// AssociationFeature

// optional float delta_x = 1;
inline bool AssociationFeature::has_delta_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssociationFeature::set_has_delta_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssociationFeature::clear_has_delta_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssociationFeature::clear_delta_x() {
  delta_x_ = 0;
  clear_has_delta_x();
}
inline float AssociationFeature::delta_x() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationFeature.delta_x)
  return delta_x_;
}
inline void AssociationFeature::set_delta_x(float value) {
  set_has_delta_x();
  delta_x_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationFeature.delta_x)
}

// optional float delta_y = 2;
inline bool AssociationFeature::has_delta_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssociationFeature::set_has_delta_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssociationFeature::clear_has_delta_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssociationFeature::clear_delta_y() {
  delta_y_ = 0;
  clear_has_delta_y();
}
inline float AssociationFeature::delta_y() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationFeature.delta_y)
  return delta_y_;
}
inline void AssociationFeature::set_delta_y(float value) {
  set_has_delta_y();
  delta_y_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationFeature.delta_y)
}

// optional float delta_vx = 3;
inline bool AssociationFeature::has_delta_vx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AssociationFeature::set_has_delta_vx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AssociationFeature::clear_has_delta_vx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AssociationFeature::clear_delta_vx() {
  delta_vx_ = 0;
  clear_has_delta_vx();
}
inline float AssociationFeature::delta_vx() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationFeature.delta_vx)
  return delta_vx_;
}
inline void AssociationFeature::set_delta_vx(float value) {
  set_has_delta_vx();
  delta_vx_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationFeature.delta_vx)
}

// optional float delta_vy = 4;
inline bool AssociationFeature::has_delta_vy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AssociationFeature::set_has_delta_vy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AssociationFeature::clear_has_delta_vy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AssociationFeature::clear_delta_vy() {
  delta_vy_ = 0;
  clear_has_delta_vy();
}
inline float AssociationFeature::delta_vy() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationFeature.delta_vy)
  return delta_vy_;
}
inline void AssociationFeature::set_delta_vy(float value) {
  set_has_delta_vy();
  delta_vy_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationFeature.delta_vy)
}

// optional float var_x = 5;
inline bool AssociationFeature::has_var_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AssociationFeature::set_has_var_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AssociationFeature::clear_has_var_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AssociationFeature::clear_var_x() {
  var_x_ = 0;
  clear_has_var_x();
}
inline float AssociationFeature::var_x() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationFeature.var_x)
  return var_x_;
}
inline void AssociationFeature::set_var_x(float value) {
  set_has_var_x();
  var_x_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationFeature.var_x)
}

// optional float var_y = 6;
inline bool AssociationFeature::has_var_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AssociationFeature::set_has_var_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AssociationFeature::clear_has_var_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AssociationFeature::clear_var_y() {
  var_y_ = 0;
  clear_has_var_y();
}
inline float AssociationFeature::var_y() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationFeature.var_y)
  return var_y_;
}
inline void AssociationFeature::set_var_y(float value) {
  set_has_var_y();
  var_y_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationFeature.var_y)
}

// optional float var_vx = 7;
inline bool AssociationFeature::has_var_vx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AssociationFeature::set_has_var_vx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AssociationFeature::clear_has_var_vx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AssociationFeature::clear_var_vx() {
  var_vx_ = 0;
  clear_has_var_vx();
}
inline float AssociationFeature::var_vx() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationFeature.var_vx)
  return var_vx_;
}
inline void AssociationFeature::set_var_vx(float value) {
  set_has_var_vx();
  var_vx_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationFeature.var_vx)
}

// optional float var_vy = 8;
inline bool AssociationFeature::has_var_vy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AssociationFeature::set_has_var_vy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AssociationFeature::clear_has_var_vy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AssociationFeature::clear_var_vy() {
  var_vy_ = 0;
  clear_has_var_vy();
}
inline float AssociationFeature::var_vy() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationFeature.var_vy)
  return var_vy_;
}
inline void AssociationFeature::set_var_vy(float value) {
  set_has_var_vy();
  var_vy_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationFeature.var_vy)
}

// -------------------------------------------------------------------

// RectangularArea

// optional float x = 1;
inline bool RectangularArea::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RectangularArea::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RectangularArea::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RectangularArea::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float RectangularArea::x() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.RectangularArea.x)
  return x_;
}
inline void RectangularArea::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.RectangularArea.x)
}

// optional float y = 2;
inline bool RectangularArea::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RectangularArea::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RectangularArea::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RectangularArea::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float RectangularArea::y() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.RectangularArea.y)
  return y_;
}
inline void RectangularArea::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.RectangularArea.y)
}

// optional float w = 3;
inline bool RectangularArea::has_w() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RectangularArea::set_has_w() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RectangularArea::clear_has_w() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RectangularArea::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float RectangularArea::w() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.RectangularArea.w)
  return w_;
}
inline void RectangularArea::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.RectangularArea.w)
}

// optional float h = 4;
inline bool RectangularArea::has_h() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RectangularArea::set_has_h() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RectangularArea::clear_has_h() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RectangularArea::clear_h() {
  h_ = 0;
  clear_has_h();
}
inline float RectangularArea::h() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.RectangularArea.h)
  return h_;
}
inline void RectangularArea::set_h(float value) {
  set_has_h();
  h_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.RectangularArea.h)
}

// -------------------------------------------------------------------

// SensorAssociationRule

// optional string name = 1;
inline bool SensorAssociationRule::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorAssociationRule::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorAssociationRule::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorAssociationRule::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& SensorAssociationRule::name() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorAssociationRule.name)
  return name_.GetNoArena();
}
inline void SensorAssociationRule::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorAssociationRule.name)
}
#if LANG_CXX11
inline void SensorAssociationRule::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.SensorAssociationRule.name)
}
#endif
inline void SensorAssociationRule::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.SensorAssociationRule.name)
}
inline void SensorAssociationRule::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.SensorAssociationRule.name)
}
inline ::std::string* SensorAssociationRule::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorAssociationRule.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorAssociationRule::release_name() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorAssociationRule.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorAssociationRule::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorAssociationRule.name)
}

// optional string sensor_type = 2;
inline bool SensorAssociationRule::has_sensor_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorAssociationRule::set_has_sensor_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorAssociationRule::clear_has_sensor_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorAssociationRule::clear_sensor_type() {
  sensor_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensor_type();
}
inline const ::std::string& SensorAssociationRule::sensor_type() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_type)
  return sensor_type_.GetNoArena();
}
inline void SensorAssociationRule::set_sensor_type(const ::std::string& value) {
  set_has_sensor_type();
  sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_type)
}
#if LANG_CXX11
inline void SensorAssociationRule::set_sensor_type(::std::string&& value) {
  set_has_sensor_type();
  sensor_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_type)
}
#endif
inline void SensorAssociationRule::set_sensor_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sensor_type();
  sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_type)
}
inline void SensorAssociationRule::set_sensor_type(const char* value, size_t size) {
  set_has_sensor_type();
  sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_type)
}
inline ::std::string* SensorAssociationRule::mutable_sensor_type() {
  set_has_sensor_type();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_type)
  return sensor_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorAssociationRule::release_sensor_type() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_type)
  if (!has_sensor_type()) {
    return NULL;
  }
  clear_has_sensor_type();
  return sensor_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorAssociationRule::set_allocated_sensor_type(::std::string* sensor_type) {
  if (sensor_type != NULL) {
    set_has_sensor_type();
  } else {
    clear_has_sensor_type();
  }
  sensor_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_type);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_type)
}

// optional string sensor_location = 3;
inline bool SensorAssociationRule::has_sensor_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorAssociationRule::set_has_sensor_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorAssociationRule::clear_has_sensor_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorAssociationRule::clear_sensor_location() {
  sensor_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensor_location();
}
inline const ::std::string& SensorAssociationRule::sensor_location() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_location)
  return sensor_location_.GetNoArena();
}
inline void SensorAssociationRule::set_sensor_location(const ::std::string& value) {
  set_has_sensor_location();
  sensor_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_location)
}
#if LANG_CXX11
inline void SensorAssociationRule::set_sensor_location(::std::string&& value) {
  set_has_sensor_location();
  sensor_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_location)
}
#endif
inline void SensorAssociationRule::set_sensor_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sensor_location();
  sensor_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_location)
}
inline void SensorAssociationRule::set_sensor_location(const char* value, size_t size) {
  set_has_sensor_location();
  sensor_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_location)
}
inline ::std::string* SensorAssociationRule::mutable_sensor_location() {
  set_has_sensor_location();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_location)
  return sensor_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorAssociationRule::release_sensor_location() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_location)
  if (!has_sensor_location()) {
    return NULL;
  }
  clear_has_sensor_location();
  return sensor_location_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorAssociationRule::set_allocated_sensor_location(::std::string* sensor_location) {
  if (sensor_location != NULL) {
    set_has_sensor_location();
  } else {
    clear_has_sensor_location();
  }
  sensor_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_location);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorAssociationRule.sensor_location)
}

// optional .holo.perception.obstacle_fusion.RectangularArea area = 4;
inline bool SensorAssociationRule::has_area() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorAssociationRule::set_has_area() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorAssociationRule::clear_has_area() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorAssociationRule::clear_area() {
  if (area_ != NULL) area_->Clear();
  clear_has_area();
}
inline const ::holo::perception::obstacle_fusion::RectangularArea& SensorAssociationRule::_internal_area() const {
  return *area_;
}
inline const ::holo::perception::obstacle_fusion::RectangularArea& SensorAssociationRule::area() const {
  const ::holo::perception::obstacle_fusion::RectangularArea* p = area_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorAssociationRule.area)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::RectangularArea*>(
      &::holo::perception::obstacle_fusion::_RectangularArea_default_instance_);
}
inline ::holo::perception::obstacle_fusion::RectangularArea* SensorAssociationRule::release_area() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorAssociationRule.area)
  clear_has_area();
  ::holo::perception::obstacle_fusion::RectangularArea* temp = area_;
  area_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::RectangularArea* SensorAssociationRule::mutable_area() {
  set_has_area();
  if (area_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::RectangularArea>(GetArenaNoVirtual());
    area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorAssociationRule.area)
  return area_;
}
inline void SensorAssociationRule::set_allocated_area(::holo::perception::obstacle_fusion::RectangularArea* area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete area_;
  }
  if (area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, area, submessage_arena);
    }
    set_has_area();
  } else {
    clear_has_area();
  }
  area_ = area;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorAssociationRule.area)
}

// optional .holo.perception.obstacle_fusion.AssociationFeature feature = 5;
inline bool SensorAssociationRule::has_feature() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorAssociationRule::set_has_feature() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorAssociationRule::clear_has_feature() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorAssociationRule::clear_feature() {
  if (feature_ != NULL) feature_->Clear();
  clear_has_feature();
}
inline const ::holo::perception::obstacle_fusion::AssociationFeature& SensorAssociationRule::_internal_feature() const {
  return *feature_;
}
inline const ::holo::perception::obstacle_fusion::AssociationFeature& SensorAssociationRule::feature() const {
  const ::holo::perception::obstacle_fusion::AssociationFeature* p = feature_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorAssociationRule.feature)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::AssociationFeature*>(
      &::holo::perception::obstacle_fusion::_AssociationFeature_default_instance_);
}
inline ::holo::perception::obstacle_fusion::AssociationFeature* SensorAssociationRule::release_feature() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorAssociationRule.feature)
  clear_has_feature();
  ::holo::perception::obstacle_fusion::AssociationFeature* temp = feature_;
  feature_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::AssociationFeature* SensorAssociationRule::mutable_feature() {
  set_has_feature();
  if (feature_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::AssociationFeature>(GetArenaNoVirtual());
    feature_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorAssociationRule.feature)
  return feature_;
}
inline void SensorAssociationRule::set_allocated_feature(::holo::perception::obstacle_fusion::AssociationFeature* feature) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete feature_;
  }
  if (feature) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      feature = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, feature, submessage_arena);
    }
    set_has_feature();
  } else {
    clear_has_feature();
  }
  feature_ = feature;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorAssociationRule.feature)
}

// -------------------------------------------------------------------

// AssociationRule

// repeated .holo.perception.obstacle_fusion.SensorAssociationRule sensor_association_rule = 1;
inline int AssociationRule::sensor_association_rule_size() const {
  return sensor_association_rule_.size();
}
inline void AssociationRule::clear_sensor_association_rule() {
  sensor_association_rule_.Clear();
}
inline ::holo::perception::obstacle_fusion::SensorAssociationRule* AssociationRule::mutable_sensor_association_rule(int index) {
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.AssociationRule.sensor_association_rule)
  return sensor_association_rule_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorAssociationRule >*
AssociationRule::mutable_sensor_association_rule() {
  // @@protoc_insertion_point(field_mutable_list:holo.perception.obstacle_fusion.AssociationRule.sensor_association_rule)
  return &sensor_association_rule_;
}
inline const ::holo::perception::obstacle_fusion::SensorAssociationRule& AssociationRule::sensor_association_rule(int index) const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationRule.sensor_association_rule)
  return sensor_association_rule_.Get(index);
}
inline ::holo::perception::obstacle_fusion::SensorAssociationRule* AssociationRule::add_sensor_association_rule() {
  // @@protoc_insertion_point(field_add:holo.perception.obstacle_fusion.AssociationRule.sensor_association_rule)
  return sensor_association_rule_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorAssociationRule >&
AssociationRule::sensor_association_rule() const {
  // @@protoc_insertion_point(field_list:holo.perception.obstacle_fusion.AssociationRule.sensor_association_rule)
  return sensor_association_rule_;
}

// optional uint64 num = 2;
inline bool AssociationRule::has_num() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AssociationRule::set_has_num() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AssociationRule::clear_has_num() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AssociationRule::clear_num() {
  num_ = GOOGLE_ULONGLONG(0);
  clear_has_num();
}
inline ::google::protobuf::uint64 AssociationRule::num() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationRule.num)
  return num_;
}
inline void AssociationRule::set_num(::google::protobuf::uint64 value) {
  set_has_num();
  num_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationRule.num)
}

// optional float duration = 3;
inline bool AssociationRule::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AssociationRule::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AssociationRule::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AssociationRule::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline float AssociationRule::duration() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.AssociationRule.duration)
  return duration_;
}
inline void AssociationRule::set_duration(float value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.AssociationRule.duration)
}

// -------------------------------------------------------------------

// SensorStageManagementRule

// optional string sensor_type = 1;
inline bool SensorStageManagementRule::has_sensor_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SensorStageManagementRule::set_has_sensor_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SensorStageManagementRule::clear_has_sensor_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SensorStageManagementRule::clear_sensor_type() {
  sensor_type_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensor_type();
}
inline const ::std::string& SensorStageManagementRule::sensor_type() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_type)
  return sensor_type_.GetNoArena();
}
inline void SensorStageManagementRule::set_sensor_type(const ::std::string& value) {
  set_has_sensor_type();
  sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_type)
}
#if LANG_CXX11
inline void SensorStageManagementRule::set_sensor_type(::std::string&& value) {
  set_has_sensor_type();
  sensor_type_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_type)
}
#endif
inline void SensorStageManagementRule::set_sensor_type(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sensor_type();
  sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_type)
}
inline void SensorStageManagementRule::set_sensor_type(const char* value, size_t size) {
  set_has_sensor_type();
  sensor_type_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_type)
}
inline ::std::string* SensorStageManagementRule::mutable_sensor_type() {
  set_has_sensor_type();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_type)
  return sensor_type_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorStageManagementRule::release_sensor_type() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_type)
  if (!has_sensor_type()) {
    return NULL;
  }
  clear_has_sensor_type();
  return sensor_type_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorStageManagementRule::set_allocated_sensor_type(::std::string* sensor_type) {
  if (sensor_type != NULL) {
    set_has_sensor_type();
  } else {
    clear_has_sensor_type();
  }
  sensor_type_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_type);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_type)
}

// optional string sensor_location = 2;
inline bool SensorStageManagementRule::has_sensor_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SensorStageManagementRule::set_has_sensor_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SensorStageManagementRule::clear_has_sensor_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SensorStageManagementRule::clear_sensor_location() {
  sensor_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_sensor_location();
}
inline const ::std::string& SensorStageManagementRule::sensor_location() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_location)
  return sensor_location_.GetNoArena();
}
inline void SensorStageManagementRule::set_sensor_location(const ::std::string& value) {
  set_has_sensor_location();
  sensor_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_location)
}
#if LANG_CXX11
inline void SensorStageManagementRule::set_sensor_location(::std::string&& value) {
  set_has_sensor_location();
  sensor_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_location)
}
#endif
inline void SensorStageManagementRule::set_sensor_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_sensor_location();
  sensor_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_location)
}
inline void SensorStageManagementRule::set_sensor_location(const char* value, size_t size) {
  set_has_sensor_location();
  sensor_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_location)
}
inline ::std::string* SensorStageManagementRule::mutable_sensor_location() {
  set_has_sensor_location();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_location)
  return sensor_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SensorStageManagementRule::release_sensor_location() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_location)
  if (!has_sensor_location()) {
    return NULL;
  }
  clear_has_sensor_location();
  return sensor_location_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SensorStageManagementRule::set_allocated_sensor_location(::std::string* sensor_location) {
  if (sensor_location != NULL) {
    set_has_sensor_location();
  } else {
    clear_has_sensor_location();
  }
  sensor_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sensor_location);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.SensorStageManagementRule.sensor_location)
}

// optional uint64 value_to_confirm = 3;
inline bool SensorStageManagementRule::has_value_to_confirm() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SensorStageManagementRule::set_has_value_to_confirm() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SensorStageManagementRule::clear_has_value_to_confirm() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SensorStageManagementRule::clear_value_to_confirm() {
  value_to_confirm_ = GOOGLE_ULONGLONG(0);
  clear_has_value_to_confirm();
}
inline ::google::protobuf::uint64 SensorStageManagementRule::value_to_confirm() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorStageManagementRule.value_to_confirm)
  return value_to_confirm_;
}
inline void SensorStageManagementRule::set_value_to_confirm(::google::protobuf::uint64 value) {
  set_has_value_to_confirm();
  value_to_confirm_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorStageManagementRule.value_to_confirm)
}

// optional uint64 value_to_terminate = 4;
inline bool SensorStageManagementRule::has_value_to_terminate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SensorStageManagementRule::set_has_value_to_terminate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SensorStageManagementRule::clear_has_value_to_terminate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SensorStageManagementRule::clear_value_to_terminate() {
  value_to_terminate_ = GOOGLE_ULONGLONG(0);
  clear_has_value_to_terminate();
}
inline ::google::protobuf::uint64 SensorStageManagementRule::value_to_terminate() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorStageManagementRule.value_to_terminate)
  return value_to_terminate_;
}
inline void SensorStageManagementRule::set_value_to_terminate(::google::protobuf::uint64 value) {
  set_has_value_to_terminate();
  value_to_terminate_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorStageManagementRule.value_to_terminate)
}

// optional float suspend_duration = 5;
inline bool SensorStageManagementRule::has_suspend_duration() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SensorStageManagementRule::set_has_suspend_duration() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SensorStageManagementRule::clear_has_suspend_duration() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SensorStageManagementRule::clear_suspend_duration() {
  suspend_duration_ = 0;
  clear_has_suspend_duration();
}
inline float SensorStageManagementRule::suspend_duration() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.SensorStageManagementRule.suspend_duration)
  return suspend_duration_;
}
inline void SensorStageManagementRule::set_suspend_duration(float value) {
  set_has_suspend_duration();
  suspend_duration_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.SensorStageManagementRule.suspend_duration)
}

// -------------------------------------------------------------------

// StageManagementRule

// repeated .holo.perception.obstacle_fusion.SensorStageManagementRule sensor_management_rule = 1;
inline int StageManagementRule::sensor_management_rule_size() const {
  return sensor_management_rule_.size();
}
inline void StageManagementRule::clear_sensor_management_rule() {
  sensor_management_rule_.Clear();
}
inline ::holo::perception::obstacle_fusion::SensorStageManagementRule* StageManagementRule::mutable_sensor_management_rule(int index) {
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.StageManagementRule.sensor_management_rule)
  return sensor_management_rule_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorStageManagementRule >*
StageManagementRule::mutable_sensor_management_rule() {
  // @@protoc_insertion_point(field_mutable_list:holo.perception.obstacle_fusion.StageManagementRule.sensor_management_rule)
  return &sensor_management_rule_;
}
inline const ::holo::perception::obstacle_fusion::SensorStageManagementRule& StageManagementRule::sensor_management_rule(int index) const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.StageManagementRule.sensor_management_rule)
  return sensor_management_rule_.Get(index);
}
inline ::holo::perception::obstacle_fusion::SensorStageManagementRule* StageManagementRule::add_sensor_management_rule() {
  // @@protoc_insertion_point(field_add:holo.perception.obstacle_fusion.StageManagementRule.sensor_management_rule)
  return sensor_management_rule_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::SensorStageManagementRule >&
StageManagementRule::sensor_management_rule() const {
  // @@protoc_insertion_point(field_list:holo.perception.obstacle_fusion.StageManagementRule.sensor_management_rule)
  return sensor_management_rule_;
}

// -------------------------------------------------------------------

// ObstacleCoord

// optional string coord_name = 1;
inline bool ObstacleCoord::has_coord_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObstacleCoord::set_has_coord_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObstacleCoord::clear_has_coord_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObstacleCoord::clear_coord_name() {
  coord_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_coord_name();
}
inline const ::std::string& ObstacleCoord::coord_name() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.ObstacleCoord.coord_name)
  return coord_name_.GetNoArena();
}
inline void ObstacleCoord::set_coord_name(const ::std::string& value) {
  set_has_coord_name();
  coord_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.ObstacleCoord.coord_name)
}
#if LANG_CXX11
inline void ObstacleCoord::set_coord_name(::std::string&& value) {
  set_has_coord_name();
  coord_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.ObstacleCoord.coord_name)
}
#endif
inline void ObstacleCoord::set_coord_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_coord_name();
  coord_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.ObstacleCoord.coord_name)
}
inline void ObstacleCoord::set_coord_name(const char* value, size_t size) {
  set_has_coord_name();
  coord_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.ObstacleCoord.coord_name)
}
inline ::std::string* ObstacleCoord::mutable_coord_name() {
  set_has_coord_name();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.ObstacleCoord.coord_name)
  return coord_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ObstacleCoord::release_coord_name() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.ObstacleCoord.coord_name)
  if (!has_coord_name()) {
    return NULL;
  }
  clear_has_coord_name();
  return coord_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ObstacleCoord::set_allocated_coord_name(::std::string* coord_name) {
  if (coord_name != NULL) {
    set_has_coord_name();
  } else {
    clear_has_coord_name();
  }
  coord_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), coord_name);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.ObstacleCoord.coord_name)
}

// optional float x = 2;
inline bool ObstacleCoord::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObstacleCoord::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObstacleCoord::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObstacleCoord::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float ObstacleCoord::x() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.ObstacleCoord.x)
  return x_;
}
inline void ObstacleCoord::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.ObstacleCoord.x)
}

// optional float y = 3;
inline bool ObstacleCoord::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObstacleCoord::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObstacleCoord::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObstacleCoord::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float ObstacleCoord::y() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.ObstacleCoord.y)
  return y_;
}
inline void ObstacleCoord::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.ObstacleCoord.y)
}

// optional float z = 4;
inline bool ObstacleCoord::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObstacleCoord::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObstacleCoord::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObstacleCoord::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float ObstacleCoord::z() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.ObstacleCoord.z)
  return z_;
}
inline void ObstacleCoord::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.ObstacleCoord.z)
}

// optional float yaw = 5;
inline bool ObstacleCoord::has_yaw() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObstacleCoord::set_has_yaw() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObstacleCoord::clear_has_yaw() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObstacleCoord::clear_yaw() {
  yaw_ = 0;
  clear_has_yaw();
}
inline float ObstacleCoord::yaw() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.ObstacleCoord.yaw)
  return yaw_;
}
inline void ObstacleCoord::set_yaw(float value) {
  set_has_yaw();
  yaw_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.ObstacleCoord.yaw)
}

// optional float pitch = 6;
inline bool ObstacleCoord::has_pitch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObstacleCoord::set_has_pitch() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObstacleCoord::clear_has_pitch() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObstacleCoord::clear_pitch() {
  pitch_ = 0;
  clear_has_pitch();
}
inline float ObstacleCoord::pitch() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.ObstacleCoord.pitch)
  return pitch_;
}
inline void ObstacleCoord::set_pitch(float value) {
  set_has_pitch();
  pitch_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.ObstacleCoord.pitch)
}

// optional float roll = 7;
inline bool ObstacleCoord::has_roll() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObstacleCoord::set_has_roll() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObstacleCoord::clear_has_roll() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObstacleCoord::clear_roll() {
  roll_ = 0;
  clear_has_roll();
}
inline float ObstacleCoord::roll() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.ObstacleCoord.roll)
  return roll_;
}
inline void ObstacleCoord::set_roll(float value) {
  set_has_roll();
  roll_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.ObstacleCoord.roll)
}

// -------------------------------------------------------------------

// Coords

// repeated .holo.perception.obstacle_fusion.ObstacleCoord coord = 1;
inline int Coords::coord_size() const {
  return coord_.size();
}
inline void Coords::clear_coord() {
  coord_.Clear();
}
inline ::holo::perception::obstacle_fusion::ObstacleCoord* Coords::mutable_coord(int index) {
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.Coords.coord)
  return coord_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::ObstacleCoord >*
Coords::mutable_coord() {
  // @@protoc_insertion_point(field_mutable_list:holo.perception.obstacle_fusion.Coords.coord)
  return &coord_;
}
inline const ::holo::perception::obstacle_fusion::ObstacleCoord& Coords::coord(int index) const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.Coords.coord)
  return coord_.Get(index);
}
inline ::holo::perception::obstacle_fusion::ObstacleCoord* Coords::add_coord() {
  // @@protoc_insertion_point(field_add:holo.perception.obstacle_fusion.Coords.coord)
  return coord_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::perception::obstacle_fusion::ObstacleCoord >&
Coords::coord() const {
  // @@protoc_insertion_point(field_list:holo.perception.obstacle_fusion.Coords.coord)
  return coord_;
}

// -------------------------------------------------------------------

// RadarMergeThreshold

// optional float delta_x = 1;
inline bool RadarMergeThreshold::has_delta_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RadarMergeThreshold::set_has_delta_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RadarMergeThreshold::clear_has_delta_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RadarMergeThreshold::clear_delta_x() {
  delta_x_ = 0;
  clear_has_delta_x();
}
inline float RadarMergeThreshold::delta_x() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.RadarMergeThreshold.delta_x)
  return delta_x_;
}
inline void RadarMergeThreshold::set_delta_x(float value) {
  set_has_delta_x();
  delta_x_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.RadarMergeThreshold.delta_x)
}

// optional float delta_y = 2;
inline bool RadarMergeThreshold::has_delta_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RadarMergeThreshold::set_has_delta_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RadarMergeThreshold::clear_has_delta_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RadarMergeThreshold::clear_delta_y() {
  delta_y_ = 0;
  clear_has_delta_y();
}
inline float RadarMergeThreshold::delta_y() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.RadarMergeThreshold.delta_y)
  return delta_y_;
}
inline void RadarMergeThreshold::set_delta_y(float value) {
  set_has_delta_y();
  delta_y_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.RadarMergeThreshold.delta_y)
}

// optional float delta_vx = 3;
inline bool RadarMergeThreshold::has_delta_vx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RadarMergeThreshold::set_has_delta_vx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RadarMergeThreshold::clear_has_delta_vx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RadarMergeThreshold::clear_delta_vx() {
  delta_vx_ = 0;
  clear_has_delta_vx();
}
inline float RadarMergeThreshold::delta_vx() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.RadarMergeThreshold.delta_vx)
  return delta_vx_;
}
inline void RadarMergeThreshold::set_delta_vx(float value) {
  set_has_delta_vx();
  delta_vx_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.RadarMergeThreshold.delta_vx)
}

// optional float delta_vy = 4;
inline bool RadarMergeThreshold::has_delta_vy() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RadarMergeThreshold::set_has_delta_vy() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RadarMergeThreshold::clear_has_delta_vy() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RadarMergeThreshold::clear_delta_vy() {
  delta_vy_ = 0;
  clear_has_delta_vy();
}
inline float RadarMergeThreshold::delta_vy() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.RadarMergeThreshold.delta_vy)
  return delta_vy_;
}
inline void RadarMergeThreshold::set_delta_vy(float value) {
  set_has_delta_vy();
  delta_vy_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.RadarMergeThreshold.delta_vy)
}

// -------------------------------------------------------------------

// IbeoContourPointsSelectRule

// optional float min_dimension = 1;
inline bool IbeoContourPointsSelectRule::has_min_dimension() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IbeoContourPointsSelectRule::set_has_min_dimension() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IbeoContourPointsSelectRule::clear_has_min_dimension() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IbeoContourPointsSelectRule::clear_min_dimension() {
  min_dimension_ = 0;
  clear_has_min_dimension();
}
inline float IbeoContourPointsSelectRule::min_dimension() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule.min_dimension)
  return min_dimension_;
}
inline void IbeoContourPointsSelectRule::set_min_dimension(float value) {
  set_has_min_dimension();
  min_dimension_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule.min_dimension)
}

// optional float max_dimension = 2;
inline bool IbeoContourPointsSelectRule::has_max_dimension() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IbeoContourPointsSelectRule::set_has_max_dimension() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IbeoContourPointsSelectRule::clear_has_max_dimension() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IbeoContourPointsSelectRule::clear_max_dimension() {
  max_dimension_ = 0;
  clear_has_max_dimension();
}
inline float IbeoContourPointsSelectRule::max_dimension() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule.max_dimension)
  return max_dimension_;
}
inline void IbeoContourPointsSelectRule::set_max_dimension(float value) {
  set_has_max_dimension();
  max_dimension_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule.max_dimension)
}

// optional float max_area = 3;
inline bool IbeoContourPointsSelectRule::has_max_area() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IbeoContourPointsSelectRule::set_has_max_area() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IbeoContourPointsSelectRule::clear_has_max_area() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IbeoContourPointsSelectRule::clear_max_area() {
  max_area_ = 0;
  clear_has_max_area();
}
inline float IbeoContourPointsSelectRule::max_area() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule.max_area)
  return max_area_;
}
inline void IbeoContourPointsSelectRule::set_max_area(float value) {
  set_has_max_area();
  max_area_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule.max_area)
}

// optional float min_abs_velocity = 4;
inline bool IbeoContourPointsSelectRule::has_min_abs_velocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IbeoContourPointsSelectRule::set_has_min_abs_velocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IbeoContourPointsSelectRule::clear_has_min_abs_velocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IbeoContourPointsSelectRule::clear_min_abs_velocity() {
  min_abs_velocity_ = 0;
  clear_has_min_abs_velocity();
}
inline float IbeoContourPointsSelectRule::min_abs_velocity() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule.min_abs_velocity)
  return min_abs_velocity_;
}
inline void IbeoContourPointsSelectRule::set_min_abs_velocity(float value) {
  set_has_min_abs_velocity();
  min_abs_velocity_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.IbeoContourPointsSelectRule.min_abs_velocity)
}

// -------------------------------------------------------------------

// FusionConfig

// optional string fusion_config_name = 1;
inline bool FusionConfig::has_fusion_config_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FusionConfig::set_has_fusion_config_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FusionConfig::clear_has_fusion_config_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FusionConfig::clear_fusion_config_name() {
  fusion_config_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fusion_config_name();
}
inline const ::std::string& FusionConfig::fusion_config_name() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.fusion_config_name)
  return fusion_config_name_.GetNoArena();
}
inline void FusionConfig::set_fusion_config_name(const ::std::string& value) {
  set_has_fusion_config_name();
  fusion_config_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.fusion_config_name)
}
#if LANG_CXX11
inline void FusionConfig::set_fusion_config_name(::std::string&& value) {
  set_has_fusion_config_name();
  fusion_config_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.FusionConfig.fusion_config_name)
}
#endif
inline void FusionConfig::set_fusion_config_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_fusion_config_name();
  fusion_config_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.FusionConfig.fusion_config_name)
}
inline void FusionConfig::set_fusion_config_name(const char* value, size_t size) {
  set_has_fusion_config_name();
  fusion_config_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.FusionConfig.fusion_config_name)
}
inline ::std::string* FusionConfig::mutable_fusion_config_name() {
  set_has_fusion_config_name();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FusionConfig.fusion_config_name)
  return fusion_config_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FusionConfig::release_fusion_config_name() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FusionConfig.fusion_config_name)
  if (!has_fusion_config_name()) {
    return NULL;
  }
  clear_has_fusion_config_name();
  return fusion_config_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionConfig::set_allocated_fusion_config_name(::std::string* fusion_config_name) {
  if (fusion_config_name != NULL) {
    set_has_fusion_config_name();
  } else {
    clear_has_fusion_config_name();
  }
  fusion_config_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fusion_config_name);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FusionConfig.fusion_config_name)
}

// optional .holo.perception.obstacle_fusion.Coords coords = 2;
inline bool FusionConfig::has_coords() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FusionConfig::set_has_coords() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FusionConfig::clear_has_coords() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FusionConfig::clear_coords() {
  if (coords_ != NULL) coords_->Clear();
  clear_has_coords();
}
inline const ::holo::perception::obstacle_fusion::Coords& FusionConfig::_internal_coords() const {
  return *coords_;
}
inline const ::holo::perception::obstacle_fusion::Coords& FusionConfig::coords() const {
  const ::holo::perception::obstacle_fusion::Coords* p = coords_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.coords)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::Coords*>(
      &::holo::perception::obstacle_fusion::_Coords_default_instance_);
}
inline ::holo::perception::obstacle_fusion::Coords* FusionConfig::release_coords() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FusionConfig.coords)
  clear_has_coords();
  ::holo::perception::obstacle_fusion::Coords* temp = coords_;
  coords_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::Coords* FusionConfig::mutable_coords() {
  set_has_coords();
  if (coords_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::Coords>(GetArenaNoVirtual());
    coords_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FusionConfig.coords)
  return coords_;
}
inline void FusionConfig::set_allocated_coords(::holo::perception::obstacle_fusion::Coords* coords) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete coords_;
  }
  if (coords) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      coords = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, coords, submessage_arena);
    }
    set_has_coords();
  } else {
    clear_has_coords();
  }
  coords_ = coords;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FusionConfig.coords)
}

// optional float snapshot_keep_duration = 3;
inline bool FusionConfig::has_snapshot_keep_duration() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void FusionConfig::set_has_snapshot_keep_duration() {
  _has_bits_[0] |= 0x00000200u;
}
inline void FusionConfig::clear_has_snapshot_keep_duration() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void FusionConfig::clear_snapshot_keep_duration() {
  snapshot_keep_duration_ = 0;
  clear_has_snapshot_keep_duration();
}
inline float FusionConfig::snapshot_keep_duration() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.snapshot_keep_duration)
  return snapshot_keep_duration_;
}
inline void FusionConfig::set_snapshot_keep_duration(float value) {
  set_has_snapshot_keep_duration();
  snapshot_keep_duration_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.snapshot_keep_duration)
}

// optional .holo.perception.obstacle_fusion.FilterRules filter_rules = 4;
inline bool FusionConfig::has_filter_rules() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FusionConfig::set_has_filter_rules() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FusionConfig::clear_has_filter_rules() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FusionConfig::clear_filter_rules() {
  if (filter_rules_ != NULL) filter_rules_->Clear();
  clear_has_filter_rules();
}
inline const ::holo::perception::obstacle_fusion::FilterRules& FusionConfig::_internal_filter_rules() const {
  return *filter_rules_;
}
inline const ::holo::perception::obstacle_fusion::FilterRules& FusionConfig::filter_rules() const {
  const ::holo::perception::obstacle_fusion::FilterRules* p = filter_rules_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.filter_rules)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::FilterRules*>(
      &::holo::perception::obstacle_fusion::_FilterRules_default_instance_);
}
inline ::holo::perception::obstacle_fusion::FilterRules* FusionConfig::release_filter_rules() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FusionConfig.filter_rules)
  clear_has_filter_rules();
  ::holo::perception::obstacle_fusion::FilterRules* temp = filter_rules_;
  filter_rules_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::FilterRules* FusionConfig::mutable_filter_rules() {
  set_has_filter_rules();
  if (filter_rules_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::FilterRules>(GetArenaNoVirtual());
    filter_rules_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FusionConfig.filter_rules)
  return filter_rules_;
}
inline void FusionConfig::set_allocated_filter_rules(::holo::perception::obstacle_fusion::FilterRules* filter_rules) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete filter_rules_;
  }
  if (filter_rules) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      filter_rules = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, filter_rules, submessage_arena);
    }
    set_has_filter_rules();
  } else {
    clear_has_filter_rules();
  }
  filter_rules_ = filter_rules;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FusionConfig.filter_rules)
}

// optional .holo.perception.obstacle_fusion.AssociationRule association_rule = 5;
inline bool FusionConfig::has_association_rule() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FusionConfig::set_has_association_rule() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FusionConfig::clear_has_association_rule() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FusionConfig::clear_association_rule() {
  if (association_rule_ != NULL) association_rule_->Clear();
  clear_has_association_rule();
}
inline const ::holo::perception::obstacle_fusion::AssociationRule& FusionConfig::_internal_association_rule() const {
  return *association_rule_;
}
inline const ::holo::perception::obstacle_fusion::AssociationRule& FusionConfig::association_rule() const {
  const ::holo::perception::obstacle_fusion::AssociationRule* p = association_rule_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.association_rule)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::AssociationRule*>(
      &::holo::perception::obstacle_fusion::_AssociationRule_default_instance_);
}
inline ::holo::perception::obstacle_fusion::AssociationRule* FusionConfig::release_association_rule() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FusionConfig.association_rule)
  clear_has_association_rule();
  ::holo::perception::obstacle_fusion::AssociationRule* temp = association_rule_;
  association_rule_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::AssociationRule* FusionConfig::mutable_association_rule() {
  set_has_association_rule();
  if (association_rule_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::AssociationRule>(GetArenaNoVirtual());
    association_rule_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FusionConfig.association_rule)
  return association_rule_;
}
inline void FusionConfig::set_allocated_association_rule(::holo::perception::obstacle_fusion::AssociationRule* association_rule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete association_rule_;
  }
  if (association_rule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      association_rule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, association_rule, submessage_arena);
    }
    set_has_association_rule();
  } else {
    clear_has_association_rule();
  }
  association_rule_ = association_rule;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FusionConfig.association_rule)
}

// optional .holo.perception.obstacle_fusion.StageManagementRule stage_management_rule = 6;
inline bool FusionConfig::has_stage_management_rule() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FusionConfig::set_has_stage_management_rule() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FusionConfig::clear_has_stage_management_rule() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FusionConfig::clear_stage_management_rule() {
  if (stage_management_rule_ != NULL) stage_management_rule_->Clear();
  clear_has_stage_management_rule();
}
inline const ::holo::perception::obstacle_fusion::StageManagementRule& FusionConfig::_internal_stage_management_rule() const {
  return *stage_management_rule_;
}
inline const ::holo::perception::obstacle_fusion::StageManagementRule& FusionConfig::stage_management_rule() const {
  const ::holo::perception::obstacle_fusion::StageManagementRule* p = stage_management_rule_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.stage_management_rule)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::StageManagementRule*>(
      &::holo::perception::obstacle_fusion::_StageManagementRule_default_instance_);
}
inline ::holo::perception::obstacle_fusion::StageManagementRule* FusionConfig::release_stage_management_rule() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FusionConfig.stage_management_rule)
  clear_has_stage_management_rule();
  ::holo::perception::obstacle_fusion::StageManagementRule* temp = stage_management_rule_;
  stage_management_rule_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::StageManagementRule* FusionConfig::mutable_stage_management_rule() {
  set_has_stage_management_rule();
  if (stage_management_rule_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::StageManagementRule>(GetArenaNoVirtual());
    stage_management_rule_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FusionConfig.stage_management_rule)
  return stage_management_rule_;
}
inline void FusionConfig::set_allocated_stage_management_rule(::holo::perception::obstacle_fusion::StageManagementRule* stage_management_rule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stage_management_rule_;
  }
  if (stage_management_rule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stage_management_rule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stage_management_rule, submessage_arena);
    }
    set_has_stage_management_rule();
  } else {
    clear_has_stage_management_rule();
  }
  stage_management_rule_ = stage_management_rule;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FusionConfig.stage_management_rule)
}

// optional float obs_fast_velocity = 7;
inline bool FusionConfig::has_obs_fast_velocity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void FusionConfig::set_has_obs_fast_velocity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void FusionConfig::clear_has_obs_fast_velocity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void FusionConfig::clear_obs_fast_velocity() {
  obs_fast_velocity_ = 0;
  clear_has_obs_fast_velocity();
}
inline float FusionConfig::obs_fast_velocity() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.obs_fast_velocity)
  return obs_fast_velocity_;
}
inline void FusionConfig::set_obs_fast_velocity(float value) {
  set_has_obs_fast_velocity();
  obs_fast_velocity_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.obs_fast_velocity)
}

// optional float obs_slow_velocity = 8;
inline bool FusionConfig::has_obs_slow_velocity() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void FusionConfig::set_has_obs_slow_velocity() {
  _has_bits_[0] |= 0x00000800u;
}
inline void FusionConfig::clear_has_obs_slow_velocity() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void FusionConfig::clear_obs_slow_velocity() {
  obs_slow_velocity_ = 0;
  clear_has_obs_slow_velocity();
}
inline float FusionConfig::obs_slow_velocity() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.obs_slow_velocity)
  return obs_slow_velocity_;
}
inline void FusionConfig::set_obs_slow_velocity(float value) {
  set_has_obs_slow_velocity();
  obs_slow_velocity_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.obs_slow_velocity)
}

// optional .holo.perception.obstacle_fusion.Zone front_view_area = 9;
inline bool FusionConfig::has_front_view_area() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void FusionConfig::set_has_front_view_area() {
  _has_bits_[0] |= 0x00000040u;
}
inline void FusionConfig::clear_has_front_view_area() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void FusionConfig::clear_front_view_area() {
  if (front_view_area_ != NULL) front_view_area_->Clear();
  clear_has_front_view_area();
}
inline const ::holo::perception::obstacle_fusion::Zone& FusionConfig::_internal_front_view_area() const {
  return *front_view_area_;
}
inline const ::holo::perception::obstacle_fusion::Zone& FusionConfig::front_view_area() const {
  const ::holo::perception::obstacle_fusion::Zone* p = front_view_area_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.front_view_area)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::Zone*>(
      &::holo::perception::obstacle_fusion::_Zone_default_instance_);
}
inline ::holo::perception::obstacle_fusion::Zone* FusionConfig::release_front_view_area() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FusionConfig.front_view_area)
  clear_has_front_view_area();
  ::holo::perception::obstacle_fusion::Zone* temp = front_view_area_;
  front_view_area_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::Zone* FusionConfig::mutable_front_view_area() {
  set_has_front_view_area();
  if (front_view_area_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::Zone>(GetArenaNoVirtual());
    front_view_area_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FusionConfig.front_view_area)
  return front_view_area_;
}
inline void FusionConfig::set_allocated_front_view_area(::holo::perception::obstacle_fusion::Zone* front_view_area) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete front_view_area_;
  }
  if (front_view_area) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      front_view_area = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, front_view_area, submessage_arena);
    }
    set_has_front_view_area();
  } else {
    clear_has_front_view_area();
  }
  front_view_area_ = front_view_area;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FusionConfig.front_view_area)
}

// optional .holo.perception.obstacle_fusion.RadarMergeThreshold radar_merge_threshold = 10;
inline bool FusionConfig::has_radar_merge_threshold() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void FusionConfig::set_has_radar_merge_threshold() {
  _has_bits_[0] |= 0x00000080u;
}
inline void FusionConfig::clear_has_radar_merge_threshold() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void FusionConfig::clear_radar_merge_threshold() {
  if (radar_merge_threshold_ != NULL) radar_merge_threshold_->Clear();
  clear_has_radar_merge_threshold();
}
inline const ::holo::perception::obstacle_fusion::RadarMergeThreshold& FusionConfig::_internal_radar_merge_threshold() const {
  return *radar_merge_threshold_;
}
inline const ::holo::perception::obstacle_fusion::RadarMergeThreshold& FusionConfig::radar_merge_threshold() const {
  const ::holo::perception::obstacle_fusion::RadarMergeThreshold* p = radar_merge_threshold_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.radar_merge_threshold)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::RadarMergeThreshold*>(
      &::holo::perception::obstacle_fusion::_RadarMergeThreshold_default_instance_);
}
inline ::holo::perception::obstacle_fusion::RadarMergeThreshold* FusionConfig::release_radar_merge_threshold() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FusionConfig.radar_merge_threshold)
  clear_has_radar_merge_threshold();
  ::holo::perception::obstacle_fusion::RadarMergeThreshold* temp = radar_merge_threshold_;
  radar_merge_threshold_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::RadarMergeThreshold* FusionConfig::mutable_radar_merge_threshold() {
  set_has_radar_merge_threshold();
  if (radar_merge_threshold_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::RadarMergeThreshold>(GetArenaNoVirtual());
    radar_merge_threshold_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FusionConfig.radar_merge_threshold)
  return radar_merge_threshold_;
}
inline void FusionConfig::set_allocated_radar_merge_threshold(::holo::perception::obstacle_fusion::RadarMergeThreshold* radar_merge_threshold) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete radar_merge_threshold_;
  }
  if (radar_merge_threshold) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      radar_merge_threshold = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, radar_merge_threshold, submessage_arena);
    }
    set_has_radar_merge_threshold();
  } else {
    clear_has_radar_merge_threshold();
  }
  radar_merge_threshold_ = radar_merge_threshold;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FusionConfig.radar_merge_threshold)
}

// optional float obs_min_size = 11;
inline bool FusionConfig::has_obs_min_size() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void FusionConfig::set_has_obs_min_size() {
  _has_bits_[0] |= 0x00001000u;
}
inline void FusionConfig::clear_has_obs_min_size() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void FusionConfig::clear_obs_min_size() {
  obs_min_size_ = 0;
  clear_has_obs_min_size();
}
inline float FusionConfig::obs_min_size() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.obs_min_size)
  return obs_min_size_;
}
inline void FusionConfig::set_obs_min_size(float value) {
  set_has_obs_min_size();
  obs_min_size_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.obs_min_size)
}

// optional uint64 max_deque_size = 12;
inline bool FusionConfig::has_max_deque_size() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void FusionConfig::set_has_max_deque_size() {
  _has_bits_[0] |= 0x00002000u;
}
inline void FusionConfig::clear_has_max_deque_size() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void FusionConfig::clear_max_deque_size() {
  max_deque_size_ = GOOGLE_ULONGLONG(0);
  clear_has_max_deque_size();
}
inline ::google::protobuf::uint64 FusionConfig::max_deque_size() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.max_deque_size)
  return max_deque_size_;
}
inline void FusionConfig::set_max_deque_size(::google::protobuf::uint64 value) {
  set_has_max_deque_size();
  max_deque_size_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.max_deque_size)
}

// optional float max_ibeo_conti_x_diff = 13;
inline bool FusionConfig::has_max_ibeo_conti_x_diff() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void FusionConfig::set_has_max_ibeo_conti_x_diff() {
  _has_bits_[0] |= 0x00004000u;
}
inline void FusionConfig::clear_has_max_ibeo_conti_x_diff() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void FusionConfig::clear_max_ibeo_conti_x_diff() {
  max_ibeo_conti_x_diff_ = 0;
  clear_has_max_ibeo_conti_x_diff();
}
inline float FusionConfig::max_ibeo_conti_x_diff() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.max_ibeo_conti_x_diff)
  return max_ibeo_conti_x_diff_;
}
inline void FusionConfig::set_max_ibeo_conti_x_diff(float value) {
  set_has_max_ibeo_conti_x_diff();
  max_ibeo_conti_x_diff_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.max_ibeo_conti_x_diff)
}

// optional float track_outlier_dt = 14;
inline bool FusionConfig::has_track_outlier_dt() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void FusionConfig::set_has_track_outlier_dt() {
  _has_bits_[0] |= 0x00008000u;
}
inline void FusionConfig::clear_has_track_outlier_dt() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void FusionConfig::clear_track_outlier_dt() {
  track_outlier_dt_ = 0;
  clear_has_track_outlier_dt();
}
inline float FusionConfig::track_outlier_dt() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.track_outlier_dt)
  return track_outlier_dt_;
}
inline void FusionConfig::set_track_outlier_dt(float value) {
  set_has_track_outlier_dt();
  track_outlier_dt_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.track_outlier_dt)
}

// optional string roi_config = 15;
inline bool FusionConfig::has_roi_config() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FusionConfig::set_has_roi_config() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FusionConfig::clear_has_roi_config() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FusionConfig::clear_roi_config() {
  roi_config_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_roi_config();
}
inline const ::std::string& FusionConfig::roi_config() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.roi_config)
  return roi_config_.GetNoArena();
}
inline void FusionConfig::set_roi_config(const ::std::string& value) {
  set_has_roi_config();
  roi_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.roi_config)
}
#if LANG_CXX11
inline void FusionConfig::set_roi_config(::std::string&& value) {
  set_has_roi_config();
  roi_config_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:holo.perception.obstacle_fusion.FusionConfig.roi_config)
}
#endif
inline void FusionConfig::set_roi_config(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_roi_config();
  roi_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:holo.perception.obstacle_fusion.FusionConfig.roi_config)
}
inline void FusionConfig::set_roi_config(const char* value, size_t size) {
  set_has_roi_config();
  roi_config_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:holo.perception.obstacle_fusion.FusionConfig.roi_config)
}
inline ::std::string* FusionConfig::mutable_roi_config() {
  set_has_roi_config();
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FusionConfig.roi_config)
  return roi_config_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FusionConfig::release_roi_config() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FusionConfig.roi_config)
  if (!has_roi_config()) {
    return NULL;
  }
  clear_has_roi_config();
  return roi_config_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FusionConfig::set_allocated_roi_config(::std::string* roi_config) {
  if (roi_config != NULL) {
    set_has_roi_config();
  } else {
    clear_has_roi_config();
  }
  roi_config_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roi_config);
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FusionConfig.roi_config)
}

// optional float overlaped_obs_x = 16;
inline bool FusionConfig::has_overlaped_obs_x() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void FusionConfig::set_has_overlaped_obs_x() {
  _has_bits_[0] |= 0x00010000u;
}
inline void FusionConfig::clear_has_overlaped_obs_x() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void FusionConfig::clear_overlaped_obs_x() {
  overlaped_obs_x_ = 0;
  clear_has_overlaped_obs_x();
}
inline float FusionConfig::overlaped_obs_x() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.overlaped_obs_x)
  return overlaped_obs_x_;
}
inline void FusionConfig::set_overlaped_obs_x(float value) {
  set_has_overlaped_obs_x();
  overlaped_obs_x_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.overlaped_obs_x)
}

// optional float overlaped_obs_y = 17;
inline bool FusionConfig::has_overlaped_obs_y() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void FusionConfig::set_has_overlaped_obs_y() {
  _has_bits_[0] |= 0x00020000u;
}
inline void FusionConfig::clear_has_overlaped_obs_y() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void FusionConfig::clear_overlaped_obs_y() {
  overlaped_obs_y_ = 0;
  clear_has_overlaped_obs_y();
}
inline float FusionConfig::overlaped_obs_y() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.overlaped_obs_y)
  return overlaped_obs_y_;
}
inline void FusionConfig::set_overlaped_obs_y(float value) {
  set_has_overlaped_obs_y();
  overlaped_obs_y_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.overlaped_obs_y)
}

// optional float ibeo_double_check_x = 18;
inline bool FusionConfig::has_ibeo_double_check_x() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void FusionConfig::set_has_ibeo_double_check_x() {
  _has_bits_[0] |= 0x00040000u;
}
inline void FusionConfig::clear_has_ibeo_double_check_x() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void FusionConfig::clear_ibeo_double_check_x() {
  ibeo_double_check_x_ = 0;
  clear_has_ibeo_double_check_x();
}
inline float FusionConfig::ibeo_double_check_x() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.ibeo_double_check_x)
  return ibeo_double_check_x_;
}
inline void FusionConfig::set_ibeo_double_check_x(float value) {
  set_has_ibeo_double_check_x();
  ibeo_double_check_x_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.ibeo_double_check_x)
}

// optional float ibeo_double_check_big_area = 19;
inline bool FusionConfig::has_ibeo_double_check_big_area() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void FusionConfig::set_has_ibeo_double_check_big_area() {
  _has_bits_[0] |= 0x00080000u;
}
inline void FusionConfig::clear_has_ibeo_double_check_big_area() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void FusionConfig::clear_ibeo_double_check_big_area() {
  ibeo_double_check_big_area_ = 0;
  clear_has_ibeo_double_check_big_area();
}
inline float FusionConfig::ibeo_double_check_big_area() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.ibeo_double_check_big_area)
  return ibeo_double_check_big_area_;
}
inline void FusionConfig::set_ibeo_double_check_big_area(float value) {
  set_has_ibeo_double_check_big_area();
  ibeo_double_check_big_area_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.ibeo_double_check_big_area)
}

// optional float half_lane_width = 20;
inline bool FusionConfig::has_half_lane_width() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void FusionConfig::set_has_half_lane_width() {
  _has_bits_[0] |= 0x00100000u;
}
inline void FusionConfig::clear_has_half_lane_width() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void FusionConfig::clear_half_lane_width() {
  half_lane_width_ = 0;
  clear_has_half_lane_width();
}
inline float FusionConfig::half_lane_width() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.half_lane_width)
  return half_lane_width_;
}
inline void FusionConfig::set_half_lane_width(float value) {
  set_has_half_lane_width();
  half_lane_width_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.half_lane_width)
}

// optional .holo.perception.obstacle_fusion.IbeoContourPointsSelectRule ibeo_contour_select_rule = 21;
inline bool FusionConfig::has_ibeo_contour_select_rule() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void FusionConfig::set_has_ibeo_contour_select_rule() {
  _has_bits_[0] |= 0x00000100u;
}
inline void FusionConfig::clear_has_ibeo_contour_select_rule() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void FusionConfig::clear_ibeo_contour_select_rule() {
  if (ibeo_contour_select_rule_ != NULL) ibeo_contour_select_rule_->Clear();
  clear_has_ibeo_contour_select_rule();
}
inline const ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule& FusionConfig::_internal_ibeo_contour_select_rule() const {
  return *ibeo_contour_select_rule_;
}
inline const ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule& FusionConfig::ibeo_contour_select_rule() const {
  const ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* p = ibeo_contour_select_rule_;
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.ibeo_contour_select_rule)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule*>(
      &::holo::perception::obstacle_fusion::_IbeoContourPointsSelectRule_default_instance_);
}
inline ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* FusionConfig::release_ibeo_contour_select_rule() {
  // @@protoc_insertion_point(field_release:holo.perception.obstacle_fusion.FusionConfig.ibeo_contour_select_rule)
  clear_has_ibeo_contour_select_rule();
  ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* temp = ibeo_contour_select_rule_;
  ibeo_contour_select_rule_ = NULL;
  return temp;
}
inline ::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* FusionConfig::mutable_ibeo_contour_select_rule() {
  set_has_ibeo_contour_select_rule();
  if (ibeo_contour_select_rule_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule>(GetArenaNoVirtual());
    ibeo_contour_select_rule_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.perception.obstacle_fusion.FusionConfig.ibeo_contour_select_rule)
  return ibeo_contour_select_rule_;
}
inline void FusionConfig::set_allocated_ibeo_contour_select_rule(::holo::perception::obstacle_fusion::IbeoContourPointsSelectRule* ibeo_contour_select_rule) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete ibeo_contour_select_rule_;
  }
  if (ibeo_contour_select_rule) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      ibeo_contour_select_rule = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ibeo_contour_select_rule, submessage_arena);
    }
    set_has_ibeo_contour_select_rule();
  } else {
    clear_has_ibeo_contour_select_rule();
  }
  ibeo_contour_select_rule_ = ibeo_contour_select_rule;
  // @@protoc_insertion_point(field_set_allocated:holo.perception.obstacle_fusion.FusionConfig.ibeo_contour_select_rule)
}

// optional float eq3_distant_x = 22;
inline bool FusionConfig::has_eq3_distant_x() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void FusionConfig::set_has_eq3_distant_x() {
  _has_bits_[0] |= 0x00200000u;
}
inline void FusionConfig::clear_has_eq3_distant_x() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void FusionConfig::clear_eq3_distant_x() {
  eq3_distant_x_ = 0;
  clear_has_eq3_distant_x();
}
inline float FusionConfig::eq3_distant_x() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.eq3_distant_x)
  return eq3_distant_x_;
}
inline void FusionConfig::set_eq3_distant_x(float value) {
  set_has_eq3_distant_x();
  eq3_distant_x_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.eq3_distant_x)
}

// optional float eq3_distant_y = 23;
inline bool FusionConfig::has_eq3_distant_y() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void FusionConfig::set_has_eq3_distant_y() {
  _has_bits_[0] |= 0x00400000u;
}
inline void FusionConfig::clear_has_eq3_distant_y() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void FusionConfig::clear_eq3_distant_y() {
  eq3_distant_y_ = 0;
  clear_has_eq3_distant_y();
}
inline float FusionConfig::eq3_distant_y() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.eq3_distant_y)
  return eq3_distant_y_;
}
inline void FusionConfig::set_eq3_distant_y(float value) {
  set_has_eq3_distant_y();
  eq3_distant_y_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.eq3_distant_y)
}

// optional float tjp_mode_speed = 24;
inline bool FusionConfig::has_tjp_mode_speed() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void FusionConfig::set_has_tjp_mode_speed() {
  _has_bits_[0] |= 0x00800000u;
}
inline void FusionConfig::clear_has_tjp_mode_speed() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void FusionConfig::clear_tjp_mode_speed() {
  tjp_mode_speed_ = 0;
  clear_has_tjp_mode_speed();
}
inline float FusionConfig::tjp_mode_speed() const {
  // @@protoc_insertion_point(field_get:holo.perception.obstacle_fusion.FusionConfig.tjp_mode_speed)
  return tjp_mode_speed_;
}
inline void FusionConfig::set_tjp_mode_speed(float value) {
  set_has_tjp_mode_speed();
  tjp_mode_speed_ = value;
  // @@protoc_insertion_point(field_set:holo.perception.obstacle_fusion.FusionConfig.tjp_mode_speed)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace obstacle_fusion
}  // namespace perception
}  // namespace holo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_fusion_2eproto
