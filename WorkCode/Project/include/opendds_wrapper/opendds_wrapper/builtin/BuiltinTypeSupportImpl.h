/* -*- C++ -*- */
/* Generated by /home/yuepf/Documents/code/Apa_Project/output/tda4_ubuntu-18.04/debug/host/bin/opendds_idl version 3.16 (ACE version 6.2a_p19) running on input file /home/yuepf/Documents/code/Apa_Project/src/holo_cmw/opendds_wrapper/message/opendds_wrapper/builtin/Builtin.idl */
#ifndef OPENDDS_IDL_GENERATED_BUILTINTYPESUPPORTIMPL_H_J837Z9
#define OPENDDS_IDL_GENERATED_BUILTINTYPESUPPORTIMPL_H_J837Z9
#include "BuiltinC.h"
#include "dds/DCPS/Definitions.h"
#include "dds/DdsDcpsC.h"
#include "dds/Version.h"
#if DDS_MAJOR_VERSION != 3 || DDS_MINOR_VERSION != 16 || DDS_MICRO_VERSION != 0
#error This file should be regenerated with opendds_idl
#endif
#include "BuiltinTypeSupportC.h"
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/TypeSupportImpl.h"
#include "dds/DCPS/ValueWriter.h"
#include "dds/DCPS/XTypes/TypeObject.h"
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL



/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: opendds_wrapper */



/* Begin STRUCT: BuiltinTimestamp */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void set_default(opendds_wrapper::BuiltinTimestamp& stru);

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::BuiltinTimestamp& stru);

bool operator<<(Serializer& strm, const opendds_wrapper::BuiltinTimestamp& stru);

bool operator>>(Serializer& strm, opendds_wrapper::BuiltinTimestamp& stru);

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const opendds_wrapper::BuiltinTimestamp>& stru);

bool operator<<(Serializer& strm, const NestedKeyOnly<const opendds_wrapper::BuiltinTimestamp>& stru);

bool operator>>(Serializer& strm, const NestedKeyOnly<opendds_wrapper::BuiltinTimestamp>& stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const opendds_wrapper::BuiltinTimestamp& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

class MetaStruct;

template<typename T>
const MetaStruct& getMetaStruct();

template<>
const MetaStruct& getMetaStruct<opendds_wrapper::BuiltinTimestamp>();
bool gen_skip_over(Serializer& ser, opendds_wrapper::BuiltinTimestamp*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_BuiltinTimestamp_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_BuiltinTimestamp_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_BuiltinTimestamp_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BuiltinTimestamp */


/* Begin STRUCT: BuiltinUint8 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void set_default(opendds_wrapper::BuiltinUint8& stru);

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::BuiltinUint8& stru);

bool operator<<(Serializer& strm, const opendds_wrapper::BuiltinUint8& stru);

bool operator>>(Serializer& strm, opendds_wrapper::BuiltinUint8& stru);

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const opendds_wrapper::BuiltinUint8>& stru);

bool operator<<(Serializer& strm, const NestedKeyOnly<const opendds_wrapper::BuiltinUint8>& stru);

bool operator>>(Serializer& strm, const NestedKeyOnly<opendds_wrapper::BuiltinUint8>& stru);

template <>
struct MarshalTraits<opendds_wrapper::BuiltinUint8> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(3);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(1);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const opendds_wrapper::BuiltinUint8&) { return false; }
  static bool from_message_block(opendds_wrapper::BuiltinUint8&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const opendds_wrapper::BuiltinUint8> stru);

bool operator<<(Serializer& strm, KeyOnly<const opendds_wrapper::BuiltinUint8> stru);

bool operator>>(Serializer& strm, KeyOnly<opendds_wrapper::BuiltinUint8> stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
/// This structure supports use of std::map with one or more keys.
struct  BuiltinUint8_OpenDDS_KeyLessThan {
  bool operator()(const opendds_wrapper::BuiltinUint8&, const opendds_wrapper::BuiltinUint8&) const
  {
    // With no keys, return false to allow use of
    // map with just one entry
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const opendds_wrapper::BuiltinUint8& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class BuiltinUint8TypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits<opendds_wrapper::BuiltinUint8> {
  typedef opendds_wrapper::BuiltinUint8 MessageType;
  typedef opendds_wrapper::BuiltinUint8Seq MessageSequenceType;
  typedef opendds_wrapper::BuiltinUint8TypeSupport TypeSupportType;
  typedef opendds_wrapper::BuiltinUint8TypeSupportImpl TypeSupportTypeImpl;
  typedef opendds_wrapper::BuiltinUint8DataWriter DataWriterType;
  typedef opendds_wrapper::BuiltinUint8DataReader DataReaderType;
  typedef opendds_wrapper::BuiltinUint8_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const opendds_wrapper::BuiltinUint8> KeyOnlyType;

  static const char* type_name() { return "opendds_wrapper::BuiltinUint8"; }
  static bool gen_has_key() { return false; }
  static size_t key_count() { return 0; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class  BuiltinUint8TypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BuiltinUint8TypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BuiltinUint8> TraitsType;
  typedef OpenDDS::DCPS::MarshalTraits<BuiltinUint8> MarshalTraitsType;
  typedef BuiltinUint8TypeSupport TypeSupportType;
  typedef BuiltinUint8TypeSupport::_var_type _var_type;
  typedef BuiltinUint8TypeSupport::_ptr_type _ptr_type;

  BuiltinUint8TypeSupportImpl() {}
  virtual ~BuiltinUint8TypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;

  void representations_allowed_by_type(::DDS::DataRepresentationIdSeq& seq);

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual OpenDDS::DCPS::Extensibility getExtensibility() const;

  static BuiltinUint8TypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<opendds_wrapper::BuiltinUint8>();
bool gen_skip_over(Serializer& ser, opendds_wrapper::BuiltinUint8*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_BuiltinUint8_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_BuiltinUint8_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_BuiltinUint8_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BuiltinUint8 */


/* Begin STRUCT: BuiltinUint16 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void set_default(opendds_wrapper::BuiltinUint16& stru);

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::BuiltinUint16& stru);

bool operator<<(Serializer& strm, const opendds_wrapper::BuiltinUint16& stru);

bool operator>>(Serializer& strm, opendds_wrapper::BuiltinUint16& stru);

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const opendds_wrapper::BuiltinUint16>& stru);

bool operator<<(Serializer& strm, const NestedKeyOnly<const opendds_wrapper::BuiltinUint16>& stru);

bool operator>>(Serializer& strm, const NestedKeyOnly<opendds_wrapper::BuiltinUint16>& stru);

template <>
struct MarshalTraits<opendds_wrapper::BuiltinUint16> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(3);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(2);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const opendds_wrapper::BuiltinUint16&) { return false; }
  static bool from_message_block(opendds_wrapper::BuiltinUint16&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const opendds_wrapper::BuiltinUint16> stru);

bool operator<<(Serializer& strm, KeyOnly<const opendds_wrapper::BuiltinUint16> stru);

bool operator>>(Serializer& strm, KeyOnly<opendds_wrapper::BuiltinUint16> stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
/// This structure supports use of std::map with one or more keys.
struct  BuiltinUint16_OpenDDS_KeyLessThan {
  bool operator()(const opendds_wrapper::BuiltinUint16&, const opendds_wrapper::BuiltinUint16&) const
  {
    // With no keys, return false to allow use of
    // map with just one entry
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const opendds_wrapper::BuiltinUint16& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class BuiltinUint16TypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits<opendds_wrapper::BuiltinUint16> {
  typedef opendds_wrapper::BuiltinUint16 MessageType;
  typedef opendds_wrapper::BuiltinUint16Seq MessageSequenceType;
  typedef opendds_wrapper::BuiltinUint16TypeSupport TypeSupportType;
  typedef opendds_wrapper::BuiltinUint16TypeSupportImpl TypeSupportTypeImpl;
  typedef opendds_wrapper::BuiltinUint16DataWriter DataWriterType;
  typedef opendds_wrapper::BuiltinUint16DataReader DataReaderType;
  typedef opendds_wrapper::BuiltinUint16_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const opendds_wrapper::BuiltinUint16> KeyOnlyType;

  static const char* type_name() { return "opendds_wrapper::BuiltinUint16"; }
  static bool gen_has_key() { return false; }
  static size_t key_count() { return 0; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class  BuiltinUint16TypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BuiltinUint16TypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BuiltinUint16> TraitsType;
  typedef OpenDDS::DCPS::MarshalTraits<BuiltinUint16> MarshalTraitsType;
  typedef BuiltinUint16TypeSupport TypeSupportType;
  typedef BuiltinUint16TypeSupport::_var_type _var_type;
  typedef BuiltinUint16TypeSupport::_ptr_type _ptr_type;

  BuiltinUint16TypeSupportImpl() {}
  virtual ~BuiltinUint16TypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;

  void representations_allowed_by_type(::DDS::DataRepresentationIdSeq& seq);

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual OpenDDS::DCPS::Extensibility getExtensibility() const;

  static BuiltinUint16TypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<opendds_wrapper::BuiltinUint16>();
bool gen_skip_over(Serializer& ser, opendds_wrapper::BuiltinUint16*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_BuiltinUint16_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_BuiltinUint16_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_BuiltinUint16_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BuiltinUint16 */


/* Begin STRUCT: BuiltinUint32 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void set_default(opendds_wrapper::BuiltinUint32& stru);

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::BuiltinUint32& stru);

bool operator<<(Serializer& strm, const opendds_wrapper::BuiltinUint32& stru);

bool operator>>(Serializer& strm, opendds_wrapper::BuiltinUint32& stru);

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const opendds_wrapper::BuiltinUint32>& stru);

bool operator<<(Serializer& strm, const NestedKeyOnly<const opendds_wrapper::BuiltinUint32>& stru);

bool operator>>(Serializer& strm, const NestedKeyOnly<opendds_wrapper::BuiltinUint32>& stru);

template <>
struct MarshalTraits<opendds_wrapper::BuiltinUint32> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(3);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(4);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const opendds_wrapper::BuiltinUint32&) { return false; }
  static bool from_message_block(opendds_wrapper::BuiltinUint32&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const opendds_wrapper::BuiltinUint32> stru);

bool operator<<(Serializer& strm, KeyOnly<const opendds_wrapper::BuiltinUint32> stru);

bool operator>>(Serializer& strm, KeyOnly<opendds_wrapper::BuiltinUint32> stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
/// This structure supports use of std::map with one or more keys.
struct  BuiltinUint32_OpenDDS_KeyLessThan {
  bool operator()(const opendds_wrapper::BuiltinUint32&, const opendds_wrapper::BuiltinUint32&) const
  {
    // With no keys, return false to allow use of
    // map with just one entry
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const opendds_wrapper::BuiltinUint32& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class BuiltinUint32TypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits<opendds_wrapper::BuiltinUint32> {
  typedef opendds_wrapper::BuiltinUint32 MessageType;
  typedef opendds_wrapper::BuiltinUint32Seq MessageSequenceType;
  typedef opendds_wrapper::BuiltinUint32TypeSupport TypeSupportType;
  typedef opendds_wrapper::BuiltinUint32TypeSupportImpl TypeSupportTypeImpl;
  typedef opendds_wrapper::BuiltinUint32DataWriter DataWriterType;
  typedef opendds_wrapper::BuiltinUint32DataReader DataReaderType;
  typedef opendds_wrapper::BuiltinUint32_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const opendds_wrapper::BuiltinUint32> KeyOnlyType;

  static const char* type_name() { return "opendds_wrapper::BuiltinUint32"; }
  static bool gen_has_key() { return false; }
  static size_t key_count() { return 0; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class  BuiltinUint32TypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BuiltinUint32TypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BuiltinUint32> TraitsType;
  typedef OpenDDS::DCPS::MarshalTraits<BuiltinUint32> MarshalTraitsType;
  typedef BuiltinUint32TypeSupport TypeSupportType;
  typedef BuiltinUint32TypeSupport::_var_type _var_type;
  typedef BuiltinUint32TypeSupport::_ptr_type _ptr_type;

  BuiltinUint32TypeSupportImpl() {}
  virtual ~BuiltinUint32TypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;

  void representations_allowed_by_type(::DDS::DataRepresentationIdSeq& seq);

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual OpenDDS::DCPS::Extensibility getExtensibility() const;

  static BuiltinUint32TypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<opendds_wrapper::BuiltinUint32>();
bool gen_skip_over(Serializer& ser, opendds_wrapper::BuiltinUint32*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_BuiltinUint32_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_BuiltinUint32_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_BuiltinUint32_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BuiltinUint32 */


/* Begin STRUCT: BuiltinUint64 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void set_default(opendds_wrapper::BuiltinUint64& stru);

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::BuiltinUint64& stru);

bool operator<<(Serializer& strm, const opendds_wrapper::BuiltinUint64& stru);

bool operator>>(Serializer& strm, opendds_wrapper::BuiltinUint64& stru);

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const opendds_wrapper::BuiltinUint64>& stru);

bool operator<<(Serializer& strm, const NestedKeyOnly<const opendds_wrapper::BuiltinUint64>& stru);

bool operator>>(Serializer& strm, const NestedKeyOnly<opendds_wrapper::BuiltinUint64>& stru);

template <>
struct MarshalTraits<opendds_wrapper::BuiltinUint64> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(3);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(8);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const opendds_wrapper::BuiltinUint64&) { return false; }
  static bool from_message_block(opendds_wrapper::BuiltinUint64&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const opendds_wrapper::BuiltinUint64> stru);

bool operator<<(Serializer& strm, KeyOnly<const opendds_wrapper::BuiltinUint64> stru);

bool operator>>(Serializer& strm, KeyOnly<opendds_wrapper::BuiltinUint64> stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
/// This structure supports use of std::map with one or more keys.
struct  BuiltinUint64_OpenDDS_KeyLessThan {
  bool operator()(const opendds_wrapper::BuiltinUint64&, const opendds_wrapper::BuiltinUint64&) const
  {
    // With no keys, return false to allow use of
    // map with just one entry
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const opendds_wrapper::BuiltinUint64& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class BuiltinUint64TypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits<opendds_wrapper::BuiltinUint64> {
  typedef opendds_wrapper::BuiltinUint64 MessageType;
  typedef opendds_wrapper::BuiltinUint64Seq MessageSequenceType;
  typedef opendds_wrapper::BuiltinUint64TypeSupport TypeSupportType;
  typedef opendds_wrapper::BuiltinUint64TypeSupportImpl TypeSupportTypeImpl;
  typedef opendds_wrapper::BuiltinUint64DataWriter DataWriterType;
  typedef opendds_wrapper::BuiltinUint64DataReader DataReaderType;
  typedef opendds_wrapper::BuiltinUint64_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const opendds_wrapper::BuiltinUint64> KeyOnlyType;

  static const char* type_name() { return "opendds_wrapper::BuiltinUint64"; }
  static bool gen_has_key() { return false; }
  static size_t key_count() { return 0; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class  BuiltinUint64TypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BuiltinUint64TypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BuiltinUint64> TraitsType;
  typedef OpenDDS::DCPS::MarshalTraits<BuiltinUint64> MarshalTraitsType;
  typedef BuiltinUint64TypeSupport TypeSupportType;
  typedef BuiltinUint64TypeSupport::_var_type _var_type;
  typedef BuiltinUint64TypeSupport::_ptr_type _ptr_type;

  BuiltinUint64TypeSupportImpl() {}
  virtual ~BuiltinUint64TypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;

  void representations_allowed_by_type(::DDS::DataRepresentationIdSeq& seq);

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual OpenDDS::DCPS::Extensibility getExtensibility() const;

  static BuiltinUint64TypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<opendds_wrapper::BuiltinUint64>();
bool gen_skip_over(Serializer& ser, opendds_wrapper::BuiltinUint64*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_BuiltinUint64_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_BuiltinUint64_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_BuiltinUint64_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BuiltinUint64 */


/* Begin STRUCT: BuiltinFloat32 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void set_default(opendds_wrapper::BuiltinFloat32& stru);

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::BuiltinFloat32& stru);

bool operator<<(Serializer& strm, const opendds_wrapper::BuiltinFloat32& stru);

bool operator>>(Serializer& strm, opendds_wrapper::BuiltinFloat32& stru);

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const opendds_wrapper::BuiltinFloat32>& stru);

bool operator<<(Serializer& strm, const NestedKeyOnly<const opendds_wrapper::BuiltinFloat32>& stru);

bool operator>>(Serializer& strm, const NestedKeyOnly<opendds_wrapper::BuiltinFloat32>& stru);

template <>
struct MarshalTraits<opendds_wrapper::BuiltinFloat32> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(3);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(4);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const opendds_wrapper::BuiltinFloat32&) { return false; }
  static bool from_message_block(opendds_wrapper::BuiltinFloat32&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const opendds_wrapper::BuiltinFloat32> stru);

bool operator<<(Serializer& strm, KeyOnly<const opendds_wrapper::BuiltinFloat32> stru);

bool operator>>(Serializer& strm, KeyOnly<opendds_wrapper::BuiltinFloat32> stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
/// This structure supports use of std::map with one or more keys.
struct  BuiltinFloat32_OpenDDS_KeyLessThan {
  bool operator()(const opendds_wrapper::BuiltinFloat32&, const opendds_wrapper::BuiltinFloat32&) const
  {
    // With no keys, return false to allow use of
    // map with just one entry
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const opendds_wrapper::BuiltinFloat32& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class BuiltinFloat32TypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits<opendds_wrapper::BuiltinFloat32> {
  typedef opendds_wrapper::BuiltinFloat32 MessageType;
  typedef opendds_wrapper::BuiltinFloat32Seq MessageSequenceType;
  typedef opendds_wrapper::BuiltinFloat32TypeSupport TypeSupportType;
  typedef opendds_wrapper::BuiltinFloat32TypeSupportImpl TypeSupportTypeImpl;
  typedef opendds_wrapper::BuiltinFloat32DataWriter DataWriterType;
  typedef opendds_wrapper::BuiltinFloat32DataReader DataReaderType;
  typedef opendds_wrapper::BuiltinFloat32_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const opendds_wrapper::BuiltinFloat32> KeyOnlyType;

  static const char* type_name() { return "opendds_wrapper::BuiltinFloat32"; }
  static bool gen_has_key() { return false; }
  static size_t key_count() { return 0; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class  BuiltinFloat32TypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BuiltinFloat32TypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BuiltinFloat32> TraitsType;
  typedef OpenDDS::DCPS::MarshalTraits<BuiltinFloat32> MarshalTraitsType;
  typedef BuiltinFloat32TypeSupport TypeSupportType;
  typedef BuiltinFloat32TypeSupport::_var_type _var_type;
  typedef BuiltinFloat32TypeSupport::_ptr_type _ptr_type;

  BuiltinFloat32TypeSupportImpl() {}
  virtual ~BuiltinFloat32TypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;

  void representations_allowed_by_type(::DDS::DataRepresentationIdSeq& seq);

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual OpenDDS::DCPS::Extensibility getExtensibility() const;

  static BuiltinFloat32TypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<opendds_wrapper::BuiltinFloat32>();
bool gen_skip_over(Serializer& ser, opendds_wrapper::BuiltinFloat32*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_BuiltinFloat32_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_BuiltinFloat32_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_BuiltinFloat32_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BuiltinFloat32 */


/* Begin STRUCT: BuiltinFloat64 */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void set_default(opendds_wrapper::BuiltinFloat64& stru);

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::BuiltinFloat64& stru);

bool operator<<(Serializer& strm, const opendds_wrapper::BuiltinFloat64& stru);

bool operator>>(Serializer& strm, opendds_wrapper::BuiltinFloat64& stru);

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const opendds_wrapper::BuiltinFloat64>& stru);

bool operator<<(Serializer& strm, const NestedKeyOnly<const opendds_wrapper::BuiltinFloat64>& stru);

bool operator>>(Serializer& strm, const NestedKeyOnly<opendds_wrapper::BuiltinFloat64>& stru);

template <>
struct MarshalTraits<opendds_wrapper::BuiltinFloat64> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(3);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(8);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const opendds_wrapper::BuiltinFloat64&) { return false; }
  static bool from_message_block(opendds_wrapper::BuiltinFloat64&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const opendds_wrapper::BuiltinFloat64> stru);

bool operator<<(Serializer& strm, KeyOnly<const opendds_wrapper::BuiltinFloat64> stru);

bool operator>>(Serializer& strm, KeyOnly<opendds_wrapper::BuiltinFloat64> stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
/// This structure supports use of std::map with one or more keys.
struct  BuiltinFloat64_OpenDDS_KeyLessThan {
  bool operator()(const opendds_wrapper::BuiltinFloat64&, const opendds_wrapper::BuiltinFloat64&) const
  {
    // With no keys, return false to allow use of
    // map with just one entry
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const opendds_wrapper::BuiltinFloat64& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class BuiltinFloat64TypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits<opendds_wrapper::BuiltinFloat64> {
  typedef opendds_wrapper::BuiltinFloat64 MessageType;
  typedef opendds_wrapper::BuiltinFloat64Seq MessageSequenceType;
  typedef opendds_wrapper::BuiltinFloat64TypeSupport TypeSupportType;
  typedef opendds_wrapper::BuiltinFloat64TypeSupportImpl TypeSupportTypeImpl;
  typedef opendds_wrapper::BuiltinFloat64DataWriter DataWriterType;
  typedef opendds_wrapper::BuiltinFloat64DataReader DataReaderType;
  typedef opendds_wrapper::BuiltinFloat64_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const opendds_wrapper::BuiltinFloat64> KeyOnlyType;

  static const char* type_name() { return "opendds_wrapper::BuiltinFloat64"; }
  static bool gen_has_key() { return false; }
  static size_t key_count() { return 0; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class  BuiltinFloat64TypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BuiltinFloat64TypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BuiltinFloat64> TraitsType;
  typedef OpenDDS::DCPS::MarshalTraits<BuiltinFloat64> MarshalTraitsType;
  typedef BuiltinFloat64TypeSupport TypeSupportType;
  typedef BuiltinFloat64TypeSupport::_var_type _var_type;
  typedef BuiltinFloat64TypeSupport::_ptr_type _ptr_type;

  BuiltinFloat64TypeSupportImpl() {}
  virtual ~BuiltinFloat64TypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;

  void representations_allowed_by_type(::DDS::DataRepresentationIdSeq& seq);

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual OpenDDS::DCPS::Extensibility getExtensibility() const;

  static BuiltinFloat64TypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<opendds_wrapper::BuiltinFloat64>();
bool gen_skip_over(Serializer& ser, opendds_wrapper::BuiltinFloat64*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_BuiltinFloat64_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_BuiltinFloat64_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_BuiltinFloat64_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BuiltinFloat64 */


/* Begin STRUCT: BuiltinString */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void set_default(opendds_wrapper::BuiltinString& stru);

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::BuiltinString& stru);

bool operator<<(Serializer& strm, const opendds_wrapper::BuiltinString& stru);

bool operator>>(Serializer& strm, opendds_wrapper::BuiltinString& stru);

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const opendds_wrapper::BuiltinString>& stru);

bool operator<<(Serializer& strm, const NestedKeyOnly<const opendds_wrapper::BuiltinString>& stru);

bool operator>>(Serializer& strm, const NestedKeyOnly<opendds_wrapper::BuiltinString>& stru);

template <>
struct MarshalTraits<opendds_wrapper::BuiltinString> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(3);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const opendds_wrapper::BuiltinString&) { return false; }
  static bool from_message_block(opendds_wrapper::BuiltinString&, const ACE_Message_Block&) { return false; }
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const opendds_wrapper::BuiltinString> stru);

bool operator<<(Serializer& strm, KeyOnly<const opendds_wrapper::BuiltinString> stru);

bool operator>>(Serializer& strm, KeyOnly<opendds_wrapper::BuiltinString> stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
/// This structure supports use of std::map with one or more keys.
struct  BuiltinString_OpenDDS_KeyLessThan {
  bool operator()(const opendds_wrapper::BuiltinString&, const opendds_wrapper::BuiltinString&) const
  {
    // With no keys, return false to allow use of
    // map with just one entry
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const opendds_wrapper::BuiltinString& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class BuiltinStringTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits<opendds_wrapper::BuiltinString> {
  typedef opendds_wrapper::BuiltinString MessageType;
  typedef opendds_wrapper::BuiltinStringSeq MessageSequenceType;
  typedef opendds_wrapper::BuiltinStringTypeSupport TypeSupportType;
  typedef opendds_wrapper::BuiltinStringTypeSupportImpl TypeSupportTypeImpl;
  typedef opendds_wrapper::BuiltinStringDataWriter DataWriterType;
  typedef opendds_wrapper::BuiltinStringDataReader DataReaderType;
  typedef opendds_wrapper::BuiltinString_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const opendds_wrapper::BuiltinString> KeyOnlyType;

  static const char* type_name() { return "opendds_wrapper::BuiltinString"; }
  static bool gen_has_key() { return false; }
  static size_t key_count() { return 0; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class  BuiltinStringTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BuiltinStringTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BuiltinString> TraitsType;
  typedef OpenDDS::DCPS::MarshalTraits<BuiltinString> MarshalTraitsType;
  typedef BuiltinStringTypeSupport TypeSupportType;
  typedef BuiltinStringTypeSupport::_var_type _var_type;
  typedef BuiltinStringTypeSupport::_ptr_type _ptr_type;

  BuiltinStringTypeSupportImpl() {}
  virtual ~BuiltinStringTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;

  void representations_allowed_by_type(::DDS::DataRepresentationIdSeq& seq);

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual OpenDDS::DCPS::Extensibility getExtensibility() const;

  static BuiltinStringTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<opendds_wrapper::BuiltinString>();
bool gen_skip_over(Serializer& ser, opendds_wrapper::BuiltinString*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_BuiltinString_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_BuiltinString_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_BuiltinString_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BuiltinString */


/* Begin TYPEDEF: OctetSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::OctetSequence& seq);

bool operator<<(Serializer& strm, const opendds_wrapper::OctetSequence& seq);

bool operator>>(Serializer& strm, opendds_wrapper::OctetSequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, opendds_wrapper::OctetSequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_OctetSequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_OctetSequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_OctetSequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: OctetSequence */


/* Begin STRUCT: BuiltinBuffer */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void set_default(opendds_wrapper::BuiltinBuffer& stru);

void serialized_size(const Encoding& encoding, size_t& size, const opendds_wrapper::BuiltinBuffer& stru);

bool operator<<(Serializer& strm, const opendds_wrapper::BuiltinBuffer& stru);

bool operator>>(Serializer& strm, opendds_wrapper::BuiltinBuffer& stru);

void serialized_size(const Encoding& encoding, size_t& size, const NestedKeyOnly<const opendds_wrapper::BuiltinBuffer>& stru);

bool operator<<(Serializer& strm, const NestedKeyOnly<const opendds_wrapper::BuiltinBuffer>& stru);

bool operator>>(Serializer& strm, const NestedKeyOnly<opendds_wrapper::BuiltinBuffer>& stru);

template <>
struct MarshalTraits<opendds_wrapper::BuiltinBuffer> {
  static void representations_allowed_by_type(DDS::DataRepresentationIdSeq& seq)
  {
    seq.length(3);
    seq[0] = DDS::XCDR_DATA_REPRESENTATION;
    seq[1] = DDS::XCDR2_DATA_REPRESENTATION;
    seq[2] = DDS::XML_DATA_REPRESENTATION;
  }

  static SerializedSizeBound serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static SerializedSizeBound key_only_serialized_size_bound(const Encoding& encoding)
  {
    switch (encoding.kind()) {
    case Encoding::KIND_UNALIGNED_CDR:
      return SerializedSizeBound(0);
    case Encoding::KIND_XCDR1:
      return SerializedSizeBound();
    case Encoding::KIND_XCDR2:
      return SerializedSizeBound();
    default:
      OPENDDS_ASSERT(false);
      return SerializedSizeBound();
    }
  }

  static bool to_message_block(ACE_Message_Block&, const opendds_wrapper::BuiltinBuffer&);
  static bool from_message_block(opendds_wrapper::BuiltinBuffer&, const ACE_Message_Block&);
  static Extensibility extensibility() { return APPENDABLE; }
  static Extensibility max_extensibility_level() { return APPENDABLE; }
};
void serialized_size(const Encoding& encoding, size_t& size, const KeyOnly<const opendds_wrapper::BuiltinBuffer> stru);

bool operator<<(Serializer& strm, KeyOnly<const opendds_wrapper::BuiltinBuffer> stru);

bool operator>>(Serializer& strm, KeyOnly<opendds_wrapper::BuiltinBuffer> stru);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
/// This structure supports use of std::map with one or more keys.
struct  BuiltinBuffer_OpenDDS_KeyLessThan {
  bool operator()(const opendds_wrapper::BuiltinBuffer&, const opendds_wrapper::BuiltinBuffer&) const
  {
    // With no keys, return false to allow use of
    // map with just one entry
    return false;
  }
};
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void vwrite(OpenDDS::DCPS::ValueWriter& value_writer, const opendds_wrapper::BuiltinBuffer& value);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class BuiltinBufferTypeSupportImpl;
}

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS {
namespace DCPS {
template <>
struct DDSTraits<opendds_wrapper::BuiltinBuffer> {
  typedef opendds_wrapper::BuiltinBuffer MessageType;
  typedef opendds_wrapper::BuiltinBufferSeq MessageSequenceType;
  typedef opendds_wrapper::BuiltinBufferTypeSupport TypeSupportType;
  typedef opendds_wrapper::BuiltinBufferTypeSupportImpl TypeSupportTypeImpl;
  typedef opendds_wrapper::BuiltinBufferDataWriter DataWriterType;
  typedef opendds_wrapper::BuiltinBufferDataReader DataReaderType;
  typedef opendds_wrapper::BuiltinBuffer_OpenDDS_KeyLessThan LessThanType;
  typedef OpenDDS::DCPS::KeyOnly<const opendds_wrapper::BuiltinBuffer> KeyOnlyType;

  static const char* type_name() { return "opendds_wrapper::BuiltinBuffer"; }
  static bool gen_has_key() { return false; }
  static size_t key_count() { return 0; }
};
} // namespace DCPS
} // namespace OpenDDS
OPENDDS_END_VERSIONED_NAMESPACE_DECL


namespace opendds_wrapper {
class  BuiltinBufferTypeSupportImpl
  : public virtual OpenDDS::DCPS::LocalObject<BuiltinBufferTypeSupport>
  , public virtual OpenDDS::DCPS::TypeSupportImpl
{
public:
  typedef OpenDDS::DCPS::DDSTraits<BuiltinBuffer> TraitsType;
  typedef OpenDDS::DCPS::MarshalTraits<BuiltinBuffer> MarshalTraitsType;
  typedef BuiltinBufferTypeSupport TypeSupportType;
  typedef BuiltinBufferTypeSupport::_var_type _var_type;
  typedef BuiltinBufferTypeSupport::_ptr_type _ptr_type;

  BuiltinBufferTypeSupportImpl() {}
  virtual ~BuiltinBufferTypeSupportImpl() {}

  virtual ::DDS::DataWriter_ptr create_datawriter();
  virtual ::DDS::DataReader_ptr create_datareader();
#ifndef OPENDDS_NO_MULTI_TOPIC
  virtual ::DDS::DataReader_ptr create_multitopic_datareader();
#endif /* !OPENDDS_NO_MULTI_TOPIC */
#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
  virtual const OpenDDS::DCPS::MetaStruct& getMetaStructForType();
#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
  virtual bool has_dcps_key();
  const char* default_type_name() const;

  void representations_allowed_by_type(::DDS::DataRepresentationIdSeq& seq);

  virtual const OpenDDS::XTypes::TypeIdentifier& getMinimalTypeIdentifier() const;
  virtual const OpenDDS::XTypes::TypeMap& getMinimalTypeMap() const;

  virtual OpenDDS::DCPS::Extensibility getExtensibility() const;

  static BuiltinBufferTypeSupport::_ptr_type _narrow(CORBA::Object_ptr obj);
};
}

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

template<>
const MetaStruct& getMetaStruct<opendds_wrapper::BuiltinBuffer>();
bool gen_skip_over(Serializer& ser, opendds_wrapper::BuiltinBuffer*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct opendds_wrapper_BuiltinBuffer_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<opendds_wrapper_BuiltinBuffer_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<opendds_wrapper_BuiltinBuffer_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End STRUCT: BuiltinBuffer */

/* End MODULE: opendds_wrapper */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif /* OPENDDS_IDL_GENERATED_BUILTINTYPESUPPORTIMPL_H_J837Z9 */
