// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: holo/map/proto/adasis/holo_adasis_v3_1_0.proto

#ifndef PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto
#define PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto 

namespace protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[76];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto
namespace holo {
namespace map {
namespace adasisv3 {
class AbsoluteVehiclePosition;
class AbsoluteVehiclePositionDefaultTypeInternal;
extern AbsoluteVehiclePositionDefaultTypeInternal _AbsoluteVehiclePosition_default_instance_;
class AbsoluteVehiclePositionProfileValue;
class AbsoluteVehiclePositionProfileValueDefaultTypeInternal;
extern AbsoluteVehiclePositionProfileValueDefaultTypeInternal _AbsoluteVehiclePositionProfileValue_default_instance_;
class BooleanProfileValue;
class BooleanProfileValueDefaultTypeInternal;
extern BooleanProfileValueDefaultTypeInternal _BooleanProfileValue_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class ConditionFuzzyTime;
class ConditionFuzzyTimeDefaultTypeInternal;
extern ConditionFuzzyTimeDefaultTypeInternal _ConditionFuzzyTime_default_instance_;
class ConditionLoad;
class ConditionLoadDefaultTypeInternal;
extern ConditionLoadDefaultTypeInternal _ConditionLoad_default_instance_;
class ConditionNumeric;
class ConditionNumericDefaultTypeInternal;
extern ConditionNumericDefaultTypeInternal _ConditionNumeric_default_instance_;
class ConditionTimeOfDay;
class ConditionTimeOfDayDefaultTypeInternal;
extern ConditionTimeOfDayDefaultTypeInternal _ConditionTimeOfDay_default_instance_;
class ConditionTurnDirection;
class ConditionTurnDirectionDefaultTypeInternal;
extern ConditionTurnDirectionDefaultTypeInternal _ConditionTurnDirection_default_instance_;
class ConditionVehicleType;
class ConditionVehicleTypeDefaultTypeInternal;
extern ConditionVehicleTypeDefaultTypeInternal _ConditionVehicleType_default_instance_;
class ConditionWeather;
class ConditionWeatherDefaultTypeInternal;
extern ConditionWeatherDefaultTypeInternal _ConditionWeather_default_instance_;
class ConditionalRestrictionProfileValue;
class ConditionalRestrictionProfileValueDefaultTypeInternal;
extern ConditionalRestrictionProfileValueDefaultTypeInternal _ConditionalRestrictionProfileValue_default_instance_;
class Curve;
class CurveDefaultTypeInternal;
extern CurveDefaultTypeInternal _Curve_default_instance_;
class DecelerationZoneProfileValue;
class DecelerationZoneProfileValueDefaultTypeInternal;
extern DecelerationZoneProfileValueDefaultTypeInternal _DecelerationZoneProfileValue_default_instance_;
class DrivingSideProfileValue;
class DrivingSideProfileValueDefaultTypeInternal;
extern DrivingSideProfileValueDefaultTypeInternal _DrivingSideProfileValue_default_instance_;
class EffectiveSpeedLimit;
class EffectiveSpeedLimitDefaultTypeInternal;
extern EffectiveSpeedLimitDefaultTypeInternal _EffectiveSpeedLimit_default_instance_;
class ExtendedSpeedLimitValue;
class ExtendedSpeedLimitValueDefaultTypeInternal;
extern ExtendedSpeedLimitValueDefaultTypeInternal _ExtendedSpeedLimitValue_default_instance_;
class FloatProfileValue;
class FloatProfileValueDefaultTypeInternal;
extern FloatProfileValueDefaultTypeInternal _FloatProfileValue_default_instance_;
class FormOfWayProfileValue;
class FormOfWayProfileValueDefaultTypeInternal;
extern FormOfWayProfileValueDefaultTypeInternal _FormOfWayProfileValue_default_instance_;
class GlobalData;
class GlobalDataDefaultTypeInternal;
extern GlobalDataDefaultTypeInternal _GlobalData_default_instance_;
class GlobalDataMessage;
class GlobalDataMessageDefaultTypeInternal;
extern GlobalDataMessageDefaultTypeInternal _GlobalDataMessage_default_instance_;
class Int32ProfileValue;
class Int32ProfileValueDefaultTypeInternal;
extern Int32ProfileValueDefaultTypeInternal _Int32ProfileValue_default_instance_;
class LaneConnectivityPair;
class LaneConnectivityPairDefaultTypeInternal;
extern LaneConnectivityPairDefaultTypeInternal _LaneConnectivityPair_default_instance_;
class LaneConnectivityValue;
class LaneConnectivityValueDefaultTypeInternal;
extern LaneConnectivityValueDefaultTypeInternal _LaneConnectivityValue_default_instance_;
class LaneInfo;
class LaneInfoDefaultTypeInternal;
extern LaneInfoDefaultTypeInternal _LaneInfo_default_instance_;
class LaneModelValue;
class LaneModelValueDefaultTypeInternal;
extern LaneModelValueDefaultTypeInternal _LaneModelValue_default_instance_;
class LanesGeometryProfileValue;
class LanesGeometryProfileValueDefaultTypeInternal;
extern LanesGeometryProfileValueDefaultTypeInternal _LanesGeometryProfileValue_default_instance_;
class LineGeometry;
class LineGeometryDefaultTypeInternal;
extern LineGeometryDefaultTypeInternal _LineGeometry_default_instance_;
class LineGeometryValue;
class LineGeometryValueDefaultTypeInternal;
extern LineGeometryValueDefaultTypeInternal _LineGeometryValue_default_instance_;
class LineGeometryValueAttribute;
class LineGeometryValueAttributeDefaultTypeInternal;
extern LineGeometryValueAttributeDefaultTypeInternal _LineGeometryValueAttribute_default_instance_;
class LinearObject;
class LinearObjectDefaultTypeInternal;
extern LinearObjectDefaultTypeInternal _LinearObject_default_instance_;
class LinearObjectDefinitionValue;
class LinearObjectDefinitionValueDefaultTypeInternal;
extern LinearObjectDefinitionValueDefaultTypeInternal _LinearObjectDefinitionValue_default_instance_;
class LocationObject;
class LocationObjectDefaultTypeInternal;
extern LocationObjectDefaultTypeInternal _LocationObject_default_instance_;
class MapProviderProfileValue;
class MapProviderProfileValueDefaultTypeInternal;
extern MapProviderProfileValueDefaultTypeInternal _MapProviderProfileValue_default_instance_;
class MapStatusProfileValue;
class MapStatusProfileValueDefaultTypeInternal;
extern MapStatusProfileValueDefaultTypeInternal _MapStatusProfileValue_default_instance_;
class MessageOnBus;
class MessageOnBusDefaultTypeInternal;
extern MessageOnBusDefaultTypeInternal _MessageOnBus_default_instance_;
class NodeArm;
class NodeArmDefaultTypeInternal;
extern NodeArmDefaultTypeInternal _NodeArm_default_instance_;
class NodeProfileValue;
class NodeProfileValueDefaultTypeInternal;
extern NodeProfileValueDefaultTypeInternal _NodeProfileValue_default_instance_;
class OffsetFloatEntry;
class OffsetFloatEntryDefaultTypeInternal;
extern OffsetFloatEntryDefaultTypeInternal _OffsetFloatEntry_default_instance_;
class OffsetFloatProfileValue;
class OffsetFloatProfileValueDefaultTypeInternal;
extern OffsetFloatProfileValueDefaultTypeInternal _OffsetFloatProfileValue_default_instance_;
class OverHeadProfileValue;
class OverHeadProfileValueDefaultTypeInternal;
extern OverHeadProfileValueDefaultTypeInternal _OverHeadProfileValue_default_instance_;
class OverHeadValue;
class OverHeadValueDefaultTypeInternal;
extern OverHeadValueDefaultTypeInternal _OverHeadValue_default_instance_;
class PathControl;
class PathControlDefaultTypeInternal;
extern PathControlDefaultTypeInternal _PathControl_default_instance_;
class PathControlMessage;
class PathControlMessageDefaultTypeInternal;
extern PathControlMessageDefaultTypeInternal _PathControlMessage_default_instance_;
class PoleProfileValue;
class PoleProfileValueDefaultTypeInternal;
extern PoleProfileValueDefaultTypeInternal _PoleProfileValue_default_instance_;
class Position;
class PositionDefaultTypeInternal;
extern PositionDefaultTypeInternal _Position_default_instance_;
class PositionMessage;
class PositionMessageDefaultTypeInternal;
extern PositionMessageDefaultTypeInternal _PositionMessage_default_instance_;
class ProfileControl;
class ProfileControlDefaultTypeInternal;
extern ProfileControlDefaultTypeInternal _ProfileControl_default_instance_;
class ProfileControlMessage;
class ProfileControlMessageDefaultTypeInternal;
extern ProfileControlMessageDefaultTypeInternal _ProfileControlMessage_default_instance_;
class ProfileEntry;
class ProfileEntryDefaultTypeInternal;
extern ProfileEntryDefaultTypeInternal _ProfileEntry_default_instance_;
class ProfileMessage;
class ProfileMessageDefaultTypeInternal;
extern ProfileMessageDefaultTypeInternal _ProfileMessage_default_instance_;
class ReasonMessage;
class ReasonMessageDefaultTypeInternal;
extern ReasonMessageDefaultTypeInternal _ReasonMessage_default_instance_;
class RegionCodeValue;
class RegionCodeValueDefaultTypeInternal;
extern RegionCodeValueDefaultTypeInternal _RegionCodeValue_default_instance_;
class RelativePosition;
class RelativePositionDefaultTypeInternal;
extern RelativePositionDefaultTypeInternal _RelativePosition_default_instance_;
class RoadConditionProfileValue;
class RoadConditionProfileValueDefaultTypeInternal;
extern RoadConditionProfileValueDefaultTypeInternal _RoadConditionProfileValue_default_instance_;
class RoadGeometryProfileValue;
class RoadGeometryProfileValueDefaultTypeInternal;
extern RoadGeometryProfileValueDefaultTypeInternal _RoadGeometryProfileValue_default_instance_;
class RoadSurfaceProfileValue;
class RoadSurfaceProfileValueDefaultTypeInternal;
extern RoadSurfaceProfileValueDefaultTypeInternal _RoadSurfaceProfileValue_default_instance_;
class SpecialSituationProfileValue;
class SpecialSituationProfileValueDefaultTypeInternal;
extern SpecialSituationProfileValueDefaultTypeInternal _SpecialSituationProfileValue_default_instance_;
class Speed;
class SpeedDefaultTypeInternal;
extern SpeedDefaultTypeInternal _Speed_default_instance_;
class SpeedProfileValue;
class SpeedProfileValueDefaultTypeInternal;
extern SpeedProfileValueDefaultTypeInternal _SpeedProfileValue_default_instance_;
class StaticNotODDProfileValue;
class StaticNotODDProfileValueDefaultTypeInternal;
extern StaticNotODDProfileValueDefaultTypeInternal _StaticNotODDProfileValue_default_instance_;
class StaticODDProfileValue;
class StaticODDProfileValueDefaultTypeInternal;
extern StaticODDProfileValueDefaultTypeInternal _StaticODDProfileValue_default_instance_;
class SurfaceConditionProfileValue;
class SurfaceConditionProfileValueDefaultTypeInternal;
extern SurfaceConditionProfileValueDefaultTypeInternal _SurfaceConditionProfileValue_default_instance_;
class SystemStatusProfileValue;
class SystemStatusProfileValueDefaultTypeInternal;
extern SystemStatusProfileValueDefaultTypeInternal _SystemStatusProfileValue_default_instance_;
class TrafficEventProfileValue;
class TrafficEventProfileValueDefaultTypeInternal;
extern TrafficEventProfileValueDefaultTypeInternal _TrafficEventProfileValue_default_instance_;
class TrafficFlowProfileValue;
class TrafficFlowProfileValueDefaultTypeInternal;
extern TrafficFlowProfileValueDefaultTypeInternal _TrafficFlowProfileValue_default_instance_;
class TrafficLightProfileValue;
class TrafficLightProfileValueDefaultTypeInternal;
extern TrafficLightProfileValueDefaultTypeInternal _TrafficLightProfileValue_default_instance_;
class TrafficSignValue;
class TrafficSignValueDefaultTypeInternal;
extern TrafficSignValueDefaultTypeInternal _TrafficSignValue_default_instance_;
class UInt32ProfileValue;
class UInt32ProfileValueDefaultTypeInternal;
extern UInt32ProfileValueDefaultTypeInternal _UInt32ProfileValue_default_instance_;
class UInt64ProfileValue;
class UInt64ProfileValueDefaultTypeInternal;
extern UInt64ProfileValueDefaultTypeInternal _UInt64ProfileValue_default_instance_;
class UnitSystemProfileValue;
class UnitSystemProfileValueDefaultTypeInternal;
extern UnitSystemProfileValueDefaultTypeInternal _UnitSystemProfileValue_default_instance_;
class Vector;
class VectorDefaultTypeInternal;
extern VectorDefaultTypeInternal _Vector_default_instance_;
class VehiclePosition;
class VehiclePositionDefaultTypeInternal;
extern VehiclePositionDefaultTypeInternal _VehiclePosition_default_instance_;
class WGS84Point;
class WGS84PointDefaultTypeInternal;
extern WGS84PointDefaultTypeInternal _WGS84Point_default_instance_;
class WeatherProfileValue;
class WeatherProfileValueDefaultTypeInternal;
extern WeatherProfileValueDefaultTypeInternal _WeatherProfileValue_default_instance_;
class YesNoUnknownProfileValue;
class YesNoUnknownProfileValueDefaultTypeInternal;
extern YesNoUnknownProfileValueDefaultTypeInternal _YesNoUnknownProfileValue_default_instance_;
}  // namespace adasisv3
}  // namespace map
}  // namespace holo
namespace google {
namespace protobuf {
template<> ::holo::map::adasisv3::AbsoluteVehiclePosition* Arena::CreateMaybeMessage<::holo::map::adasisv3::AbsoluteVehiclePosition>(Arena*);
template<> ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue>(Arena*);
template<> ::holo::map::adasisv3::BooleanProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::BooleanProfileValue>(Arena*);
template<> ::holo::map::adasisv3::Condition* Arena::CreateMaybeMessage<::holo::map::adasisv3::Condition>(Arena*);
template<> ::holo::map::adasisv3::ConditionFuzzyTime* Arena::CreateMaybeMessage<::holo::map::adasisv3::ConditionFuzzyTime>(Arena*);
template<> ::holo::map::adasisv3::ConditionLoad* Arena::CreateMaybeMessage<::holo::map::adasisv3::ConditionLoad>(Arena*);
template<> ::holo::map::adasisv3::ConditionNumeric* Arena::CreateMaybeMessage<::holo::map::adasisv3::ConditionNumeric>(Arena*);
template<> ::holo::map::adasisv3::ConditionTimeOfDay* Arena::CreateMaybeMessage<::holo::map::adasisv3::ConditionTimeOfDay>(Arena*);
template<> ::holo::map::adasisv3::ConditionTurnDirection* Arena::CreateMaybeMessage<::holo::map::adasisv3::ConditionTurnDirection>(Arena*);
template<> ::holo::map::adasisv3::ConditionVehicleType* Arena::CreateMaybeMessage<::holo::map::adasisv3::ConditionVehicleType>(Arena*);
template<> ::holo::map::adasisv3::ConditionWeather* Arena::CreateMaybeMessage<::holo::map::adasisv3::ConditionWeather>(Arena*);
template<> ::holo::map::adasisv3::ConditionalRestrictionProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::ConditionalRestrictionProfileValue>(Arena*);
template<> ::holo::map::adasisv3::Curve* Arena::CreateMaybeMessage<::holo::map::adasisv3::Curve>(Arena*);
template<> ::holo::map::adasisv3::DecelerationZoneProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::DecelerationZoneProfileValue>(Arena*);
template<> ::holo::map::adasisv3::DrivingSideProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::DrivingSideProfileValue>(Arena*);
template<> ::holo::map::adasisv3::EffectiveSpeedLimit* Arena::CreateMaybeMessage<::holo::map::adasisv3::EffectiveSpeedLimit>(Arena*);
template<> ::holo::map::adasisv3::ExtendedSpeedLimitValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::ExtendedSpeedLimitValue>(Arena*);
template<> ::holo::map::adasisv3::FloatProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::FloatProfileValue>(Arena*);
template<> ::holo::map::adasisv3::FormOfWayProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::FormOfWayProfileValue>(Arena*);
template<> ::holo::map::adasisv3::GlobalData* Arena::CreateMaybeMessage<::holo::map::adasisv3::GlobalData>(Arena*);
template<> ::holo::map::adasisv3::GlobalDataMessage* Arena::CreateMaybeMessage<::holo::map::adasisv3::GlobalDataMessage>(Arena*);
template<> ::holo::map::adasisv3::Int32ProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::Int32ProfileValue>(Arena*);
template<> ::holo::map::adasisv3::LaneConnectivityPair* Arena::CreateMaybeMessage<::holo::map::adasisv3::LaneConnectivityPair>(Arena*);
template<> ::holo::map::adasisv3::LaneConnectivityValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::LaneConnectivityValue>(Arena*);
template<> ::holo::map::adasisv3::LaneInfo* Arena::CreateMaybeMessage<::holo::map::adasisv3::LaneInfo>(Arena*);
template<> ::holo::map::adasisv3::LaneModelValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::LaneModelValue>(Arena*);
template<> ::holo::map::adasisv3::LanesGeometryProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::LanesGeometryProfileValue>(Arena*);
template<> ::holo::map::adasisv3::LineGeometry* Arena::CreateMaybeMessage<::holo::map::adasisv3::LineGeometry>(Arena*);
template<> ::holo::map::adasisv3::LineGeometryValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::LineGeometryValue>(Arena*);
template<> ::holo::map::adasisv3::LineGeometryValueAttribute* Arena::CreateMaybeMessage<::holo::map::adasisv3::LineGeometryValueAttribute>(Arena*);
template<> ::holo::map::adasisv3::LinearObject* Arena::CreateMaybeMessage<::holo::map::adasisv3::LinearObject>(Arena*);
template<> ::holo::map::adasisv3::LinearObjectDefinitionValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::LinearObjectDefinitionValue>(Arena*);
template<> ::holo::map::adasisv3::LocationObject* Arena::CreateMaybeMessage<::holo::map::adasisv3::LocationObject>(Arena*);
template<> ::holo::map::adasisv3::MapProviderProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::MapProviderProfileValue>(Arena*);
template<> ::holo::map::adasisv3::MapStatusProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::MapStatusProfileValue>(Arena*);
template<> ::holo::map::adasisv3::MessageOnBus* Arena::CreateMaybeMessage<::holo::map::adasisv3::MessageOnBus>(Arena*);
template<> ::holo::map::adasisv3::NodeArm* Arena::CreateMaybeMessage<::holo::map::adasisv3::NodeArm>(Arena*);
template<> ::holo::map::adasisv3::NodeProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::NodeProfileValue>(Arena*);
template<> ::holo::map::adasisv3::OffsetFloatEntry* Arena::CreateMaybeMessage<::holo::map::adasisv3::OffsetFloatEntry>(Arena*);
template<> ::holo::map::adasisv3::OffsetFloatProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::OffsetFloatProfileValue>(Arena*);
template<> ::holo::map::adasisv3::OverHeadProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::OverHeadProfileValue>(Arena*);
template<> ::holo::map::adasisv3::OverHeadValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::OverHeadValue>(Arena*);
template<> ::holo::map::adasisv3::PathControl* Arena::CreateMaybeMessage<::holo::map::adasisv3::PathControl>(Arena*);
template<> ::holo::map::adasisv3::PathControlMessage* Arena::CreateMaybeMessage<::holo::map::adasisv3::PathControlMessage>(Arena*);
template<> ::holo::map::adasisv3::PoleProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::PoleProfileValue>(Arena*);
template<> ::holo::map::adasisv3::Position* Arena::CreateMaybeMessage<::holo::map::adasisv3::Position>(Arena*);
template<> ::holo::map::adasisv3::PositionMessage* Arena::CreateMaybeMessage<::holo::map::adasisv3::PositionMessage>(Arena*);
template<> ::holo::map::adasisv3::ProfileControl* Arena::CreateMaybeMessage<::holo::map::adasisv3::ProfileControl>(Arena*);
template<> ::holo::map::adasisv3::ProfileControlMessage* Arena::CreateMaybeMessage<::holo::map::adasisv3::ProfileControlMessage>(Arena*);
template<> ::holo::map::adasisv3::ProfileEntry* Arena::CreateMaybeMessage<::holo::map::adasisv3::ProfileEntry>(Arena*);
template<> ::holo::map::adasisv3::ProfileMessage* Arena::CreateMaybeMessage<::holo::map::adasisv3::ProfileMessage>(Arena*);
template<> ::holo::map::adasisv3::ReasonMessage* Arena::CreateMaybeMessage<::holo::map::adasisv3::ReasonMessage>(Arena*);
template<> ::holo::map::adasisv3::RegionCodeValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::RegionCodeValue>(Arena*);
template<> ::holo::map::adasisv3::RelativePosition* Arena::CreateMaybeMessage<::holo::map::adasisv3::RelativePosition>(Arena*);
template<> ::holo::map::adasisv3::RoadConditionProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::RoadConditionProfileValue>(Arena*);
template<> ::holo::map::adasisv3::RoadGeometryProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::RoadGeometryProfileValue>(Arena*);
template<> ::holo::map::adasisv3::RoadSurfaceProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::RoadSurfaceProfileValue>(Arena*);
template<> ::holo::map::adasisv3::SpecialSituationProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::SpecialSituationProfileValue>(Arena*);
template<> ::holo::map::adasisv3::Speed* Arena::CreateMaybeMessage<::holo::map::adasisv3::Speed>(Arena*);
template<> ::holo::map::adasisv3::SpeedProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::SpeedProfileValue>(Arena*);
template<> ::holo::map::adasisv3::StaticNotODDProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::StaticNotODDProfileValue>(Arena*);
template<> ::holo::map::adasisv3::StaticODDProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::StaticODDProfileValue>(Arena*);
template<> ::holo::map::adasisv3::SurfaceConditionProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::SurfaceConditionProfileValue>(Arena*);
template<> ::holo::map::adasisv3::SystemStatusProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::SystemStatusProfileValue>(Arena*);
template<> ::holo::map::adasisv3::TrafficEventProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::TrafficEventProfileValue>(Arena*);
template<> ::holo::map::adasisv3::TrafficFlowProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::TrafficFlowProfileValue>(Arena*);
template<> ::holo::map::adasisv3::TrafficLightProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::TrafficLightProfileValue>(Arena*);
template<> ::holo::map::adasisv3::TrafficSignValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::TrafficSignValue>(Arena*);
template<> ::holo::map::adasisv3::UInt32ProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::UInt32ProfileValue>(Arena*);
template<> ::holo::map::adasisv3::UInt64ProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::UInt64ProfileValue>(Arena*);
template<> ::holo::map::adasisv3::UnitSystemProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::UnitSystemProfileValue>(Arena*);
template<> ::holo::map::adasisv3::Vector* Arena::CreateMaybeMessage<::holo::map::adasisv3::Vector>(Arena*);
template<> ::holo::map::adasisv3::VehiclePosition* Arena::CreateMaybeMessage<::holo::map::adasisv3::VehiclePosition>(Arena*);
template<> ::holo::map::adasisv3::WGS84Point* Arena::CreateMaybeMessage<::holo::map::adasisv3::WGS84Point>(Arena*);
template<> ::holo::map::adasisv3::WeatherProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::WeatherProfileValue>(Arena*);
template<> ::holo::map::adasisv3::YesNoUnknownProfileValue* Arena::CreateMaybeMessage<::holo::map::adasisv3::YesNoUnknownProfileValue>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace holo {
namespace map {
namespace adasisv3 {

enum AdasisV3ProtobufProtocolMajorVersion {
  AdasisV3ProtobufProtocolMajorVersion_Value = 2
};
bool AdasisV3ProtobufProtocolMajorVersion_IsValid(int value);
const AdasisV3ProtobufProtocolMajorVersion AdasisV3ProtobufProtocolMajorVersion_MIN = AdasisV3ProtobufProtocolMajorVersion_Value;
const AdasisV3ProtobufProtocolMajorVersion AdasisV3ProtobufProtocolMajorVersion_MAX = AdasisV3ProtobufProtocolMajorVersion_Value;
const int AdasisV3ProtobufProtocolMajorVersion_ARRAYSIZE = AdasisV3ProtobufProtocolMajorVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdasisV3ProtobufProtocolMajorVersion_descriptor();
inline const ::std::string& AdasisV3ProtobufProtocolMajorVersion_Name(AdasisV3ProtobufProtocolMajorVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdasisV3ProtobufProtocolMajorVersion_descriptor(), value);
}
inline bool AdasisV3ProtobufProtocolMajorVersion_Parse(
    const ::std::string& name, AdasisV3ProtobufProtocolMajorVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdasisV3ProtobufProtocolMajorVersion>(
    AdasisV3ProtobufProtocolMajorVersion_descriptor(), name, value);
}
enum AdasisV3ProtobufProtocolMinorVersion {
  AdasisV3ProtobufProtocolMinorVersion_Value = 2
};
bool AdasisV3ProtobufProtocolMinorVersion_IsValid(int value);
const AdasisV3ProtobufProtocolMinorVersion AdasisV3ProtobufProtocolMinorVersion_MIN = AdasisV3ProtobufProtocolMinorVersion_Value;
const AdasisV3ProtobufProtocolMinorVersion AdasisV3ProtobufProtocolMinorVersion_MAX = AdasisV3ProtobufProtocolMinorVersion_Value;
const int AdasisV3ProtobufProtocolMinorVersion_ARRAYSIZE = AdasisV3ProtobufProtocolMinorVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdasisV3ProtobufProtocolMinorVersion_descriptor();
inline const ::std::string& AdasisV3ProtobufProtocolMinorVersion_Name(AdasisV3ProtobufProtocolMinorVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdasisV3ProtobufProtocolMinorVersion_descriptor(), value);
}
inline bool AdasisV3ProtobufProtocolMinorVersion_Parse(
    const ::std::string& name, AdasisV3ProtobufProtocolMinorVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdasisV3ProtobufProtocolMinorVersion>(
    AdasisV3ProtobufProtocolMinorVersion_descriptor(), name, value);
}
enum Availability {
  Availability_NotAvailable = 0,
  Availability_Valid = 1
};
bool Availability_IsValid(int value);
const Availability Availability_MIN = Availability_NotAvailable;
const Availability Availability_MAX = Availability_Valid;
const int Availability_ARRAYSIZE = Availability_MAX + 1;

const ::google::protobuf::EnumDescriptor* Availability_descriptor();
inline const ::std::string& Availability_Name(Availability value) {
  return ::google::protobuf::internal::NameOfEnum(
    Availability_descriptor(), value);
}
inline bool Availability_Parse(
    const ::std::string& name, Availability* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Availability>(
    Availability_descriptor(), name, value);
}
enum UnitOfSystem {
  UnitOfSystem_Imperial = 0,
  UnitOfSystem_Metric = 1
};
bool UnitOfSystem_IsValid(int value);
const UnitOfSystem UnitOfSystem_MIN = UnitOfSystem_Imperial;
const UnitOfSystem UnitOfSystem_MAX = UnitOfSystem_Metric;
const int UnitOfSystem_ARRAYSIZE = UnitOfSystem_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnitOfSystem_descriptor();
inline const ::std::string& UnitOfSystem_Name(UnitOfSystem value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitOfSystem_descriptor(), value);
}
inline bool UnitOfSystem_Parse(
    const ::std::string& name, UnitOfSystem* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitOfSystem>(
    UnitOfSystem_descriptor(), name, value);
}
enum ChangeMode {
  ChangeMode_Create = 0,
  ChangeMode_Update = 1,
  ChangeMode_Delete = 2
};
bool ChangeMode_IsValid(int value);
const ChangeMode ChangeMode_MIN = ChangeMode_Create;
const ChangeMode ChangeMode_MAX = ChangeMode_Delete;
const int ChangeMode_ARRAYSIZE = ChangeMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ChangeMode_descriptor();
inline const ::std::string& ChangeMode_Name(ChangeMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ChangeMode_descriptor(), value);
}
inline bool ChangeMode_Parse(
    const ::std::string& name, ChangeMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ChangeMode>(
    ChangeMode_descriptor(), name, value);
}
enum ConditionType {
  ConditionType_conditionTypeNumeric = 0,
  ConditionType_conditionTypeVehicle = 1,
  ConditionType_conditionTypeLoad = 2,
  ConditionType_conditionTypeTimeOfDay = 3,
  ConditionType_conditionTypeWeather = 4,
  ConditionType_conditionTypeFuzzyTime = 5,
  ConditionType_conditionTypeTurnDirection = 6
};
bool ConditionType_IsValid(int value);
const ConditionType ConditionType_MIN = ConditionType_conditionTypeNumeric;
const ConditionType ConditionType_MAX = ConditionType_conditionTypeTurnDirection;
const int ConditionType_ARRAYSIZE = ConditionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ConditionType_descriptor();
inline const ::std::string& ConditionType_Name(ConditionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ConditionType_descriptor(), value);
}
inline bool ConditionType_Parse(
    const ::std::string& name, ConditionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ConditionType>(
    ConditionType_descriptor(), name, value);
}
enum CurveType {
  CurveType_NotPresent = 0,
  CurveType_Polyline = 1,
  CurveType_BezierSpline = 2,
  CurveType_Clothoid = 3,
  CurveType_Other = 99
};
bool CurveType_IsValid(int value);
const CurveType CurveType_MIN = CurveType_NotPresent;
const CurveType CurveType_MAX = CurveType_Other;
const int CurveType_ARRAYSIZE = CurveType_MAX + 1;

const ::google::protobuf::EnumDescriptor* CurveType_descriptor();
inline const ::std::string& CurveType_Name(CurveType value) {
  return ::google::protobuf::internal::NameOfEnum(
    CurveType_descriptor(), value);
}
inline bool CurveType_Parse(
    const ::std::string& name, CurveType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CurveType>(
    CurveType_descriptor(), name, value);
}
enum DrivingSide {
  DrivingSide_RightHandDriving = 0,
  DrivingSide_LeftHandDriving = 1
};
bool DrivingSide_IsValid(int value);
const DrivingSide DrivingSide_MIN = DrivingSide_RightHandDriving;
const DrivingSide DrivingSide_MAX = DrivingSide_LeftHandDriving;
const int DrivingSide_ARRAYSIZE = DrivingSide_MAX + 1;

const ::google::protobuf::EnumDescriptor* DrivingSide_descriptor();
inline const ::std::string& DrivingSide_Name(DrivingSide value) {
  return ::google::protobuf::internal::NameOfEnum(
    DrivingSide_descriptor(), value);
}
inline bool DrivingSide_Parse(
    const ::std::string& name, DrivingSide* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DrivingSide>(
    DrivingSide_descriptor(), name, value);
}
enum EffectiveSpeedLimitType {
  EffectiveSpeedLimitType_Unknown = 0,
  EffectiveSpeedLimitType_Implicit = 1,
  EffectiveSpeedLimitType_ExplicitOnTrafficSign = 2,
  EffectiveSpeedLimitType_ExplicitNight = 3,
  EffectiveSpeedLimitType_ExplicitDay = 4,
  EffectiveSpeedLimitType_ExplicitTimeOrDay = 5,
  EffectiveSpeedLimitType_ExplicitRain = 6,
  EffectiveSpeedLimitType_ExplicitSnow = 7,
  EffectiveSpeedLimitType_ExplicitFog = 8
};
bool EffectiveSpeedLimitType_IsValid(int value);
const EffectiveSpeedLimitType EffectiveSpeedLimitType_MIN = EffectiveSpeedLimitType_Unknown;
const EffectiveSpeedLimitType EffectiveSpeedLimitType_MAX = EffectiveSpeedLimitType_ExplicitFog;
const int EffectiveSpeedLimitType_ARRAYSIZE = EffectiveSpeedLimitType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EffectiveSpeedLimitType_descriptor();
inline const ::std::string& EffectiveSpeedLimitType_Name(EffectiveSpeedLimitType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EffectiveSpeedLimitType_descriptor(), value);
}
inline bool EffectiveSpeedLimitType_Parse(
    const ::std::string& name, EffectiveSpeedLimitType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EffectiveSpeedLimitType>(
    EffectiveSpeedLimitType_descriptor(), name, value);
}
enum FormOfWay {
  FormOfWay_Unknown = 0,
  FormOfWay_MultipleCarriageWay = 2,
  FormOfWay_SingleCarriageWay = 3,
  FormOfWay_RoundaboutCircle = 4,
  FormOfWay_Service = 13,
  FormOfWay_RampEntry = 16,
  FormOfWay_RampExit = 17,
  FormOfWay_CrossLink = 18,
  FormOfWay_JCT = 19,
  FormOfWay_SlipRoad = 20,
  FormOfWay_SideRoad = 21,
  FormOfWay_SlipAndJCT = 22,
  FormOfWay_TurnRightLineA = 23,
  FormOfWay_TurnRightLineB = 24,
  FormOfWay_TurnLeftLineA = 25,
  FormOfWay_TurnLeftLineB = 26,
  FormOfWay_TurnLeftRightLine = 27,
  FormOfWay_ServiceAndSlipRoad = 28,
  FormOfWay_ServiceAndJCT = 29,
  FormOfWay_ServiceAndSlipRoadAndJCT = 30,
  FormOfWay_Other = 99
};
bool FormOfWay_IsValid(int value);
const FormOfWay FormOfWay_MIN = FormOfWay_Unknown;
const FormOfWay FormOfWay_MAX = FormOfWay_Other;
const int FormOfWay_ARRAYSIZE = FormOfWay_MAX + 1;

const ::google::protobuf::EnumDescriptor* FormOfWay_descriptor();
inline const ::std::string& FormOfWay_Name(FormOfWay value) {
  return ::google::protobuf::internal::NameOfEnum(
    FormOfWay_descriptor(), value);
}
inline bool FormOfWay_Parse(
    const ::std::string& name, FormOfWay* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FormOfWay>(
    FormOfWay_descriptor(), name, value);
}
enum FuzzyTime {
  FuzzyTime_Unknown = 1,
  FuzzyTime_Day = 2,
  FuzzyTime_Night = 3
};
bool FuzzyTime_IsValid(int value);
const FuzzyTime FuzzyTime_MIN = FuzzyTime_Unknown;
const FuzzyTime FuzzyTime_MAX = FuzzyTime_Night;
const int FuzzyTime_ARRAYSIZE = FuzzyTime_MAX + 1;

const ::google::protobuf::EnumDescriptor* FuzzyTime_descriptor();
inline const ::std::string& FuzzyTime_Name(FuzzyTime value) {
  return ::google::protobuf::internal::NameOfEnum(
    FuzzyTime_descriptor(), value);
}
inline bool FuzzyTime_Parse(
    const ::std::string& name, FuzzyTime* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FuzzyTime>(
    FuzzyTime_descriptor(), name, value);
}
enum GuidanceMode {
  GuidanceMode_guidanceInactive = 1,
  GuidanceMode_guidanceForUser = 2,
  GuidanceMode_guidanceAutomatic = 3
};
bool GuidanceMode_IsValid(int value);
const GuidanceMode GuidanceMode_MIN = GuidanceMode_guidanceInactive;
const GuidanceMode GuidanceMode_MAX = GuidanceMode_guidanceAutomatic;
const int GuidanceMode_ARRAYSIZE = GuidanceMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GuidanceMode_descriptor();
inline const ::std::string& GuidanceMode_Name(GuidanceMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GuidanceMode_descriptor(), value);
}
inline bool GuidanceMode_Parse(
    const ::std::string& name, GuidanceMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GuidanceMode>(
    GuidanceMode_descriptor(), name, value);
}
enum LaneArrowMarking {
  LaneArrowMarking_None = 0,
  LaneArrowMarking_Straight = 1,
  LaneArrowMarking_SlightRight = 2,
  LaneArrowMarking_Right = 4,
  LaneArrowMarking_HardRight = 8,
  LaneArrowMarking_UTurn = 16,
  LaneArrowMarking_HardLeft = 32,
  LaneArrowMarking_Left = 64,
  LaneArrowMarking_SlightLeft = 128,
  LaneArrowMarking_NA = -1
};
bool LaneArrowMarking_IsValid(int value);
const LaneArrowMarking LaneArrowMarking_MIN = LaneArrowMarking_NA;
const LaneArrowMarking LaneArrowMarking_MAX = LaneArrowMarking_SlightLeft;
const int LaneArrowMarking_ARRAYSIZE = LaneArrowMarking_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneArrowMarking_descriptor();
inline const ::std::string& LaneArrowMarking_Name(LaneArrowMarking value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneArrowMarking_descriptor(), value);
}
inline bool LaneArrowMarking_Parse(
    const ::std::string& name, LaneArrowMarking* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneArrowMarking>(
    LaneArrowMarking_descriptor(), name, value);
}
enum LaneTransition {
  LaneTransition_Unknown = 0,
  LaneTransition_Continue = 1,
  LaneTransition_Merging = 2,
  LaneTransition_Splitting = 3,
  LaneTransition_Other = 99
};
bool LaneTransition_IsValid(int value);
const LaneTransition LaneTransition_MIN = LaneTransition_Unknown;
const LaneTransition LaneTransition_MAX = LaneTransition_Other;
const int LaneTransition_ARRAYSIZE = LaneTransition_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneTransition_descriptor();
inline const ::std::string& LaneTransition_Name(LaneTransition value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneTransition_descriptor(), value);
}
inline bool LaneTransition_Parse(
    const ::std::string& name, LaneTransition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneTransition>(
    LaneTransition_descriptor(), name, value);
}
enum LateralPosition {
  LateralPosition_Unknown = 0,
  LateralPosition_Right = 1,
  LateralPosition_Left = 2,
  LateralPosition_Above = 4,
  LateralPosition_Surface = 8
};
bool LateralPosition_IsValid(int value);
const LateralPosition LateralPosition_MIN = LateralPosition_Unknown;
const LateralPosition LateralPosition_MAX = LateralPosition_Surface;
const int LateralPosition_ARRAYSIZE = LateralPosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* LateralPosition_descriptor();
inline const ::std::string& LateralPosition_Name(LateralPosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    LateralPosition_descriptor(), value);
}
inline bool LateralPosition_Parse(
    const ::std::string& name, LateralPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LateralPosition>(
    LateralPosition_descriptor(), name, value);
}
enum LineMarking {
  LineMarking_Unknown = 0,
  LineMarking_SolidLine = 1,
  LineMarking_DashedLine = 2,
  LineMarking_ShortDashedLine = 3,
  LineMarking_DoubleSolidLine = 4,
  LineMarking_DoubleDashedLine = 5,
  LineMarking_LeftSolidRightDashed = 6,
  LineMarking_RightSolidLeftDashed = 7,
  LineMarking_ShadedArea = 8,
  LineMarking_LaneVirtualMarking = 9,
  LineMarking_IntersectionVirualMarking = 10,
  LineMarking_CurbVirtualMarking = 11,
  LineMarking_UnclosedRoad = 12,
  LineMarking_RoadVirtualLine = 13,
  LineMarking_Other = 99
};
bool LineMarking_IsValid(int value);
const LineMarking LineMarking_MIN = LineMarking_Unknown;
const LineMarking LineMarking_MAX = LineMarking_Other;
const int LineMarking_ARRAYSIZE = LineMarking_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineMarking_descriptor();
inline const ::std::string& LineMarking_Name(LineMarking value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineMarking_descriptor(), value);
}
inline bool LineMarking_Parse(
    const ::std::string& name, LineMarking* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineMarking>(
    LineMarking_descriptor(), name, value);
}
enum LineMarkingColour {
  LineMarkingColour_None = 0,
  LineMarkingColour_White = 1,
  LineMarkingColour_Yellow = 2,
  LineMarkingColour_Orange = 3,
  LineMarkingColour_Blue = 4,
  LineMarkingColour_Green = 5,
  LineMarkingColour_Gray = 6,
  LineMarkingColour_LeftGrayRightYellow = 7,
  LineMarkingColour_LeftYellowRightWhite = 8,
  LineMarkingColour_Other = 99
};
bool LineMarkingColour_IsValid(int value);
const LineMarkingColour LineMarkingColour_MIN = LineMarkingColour_None;
const LineMarkingColour LineMarkingColour_MAX = LineMarkingColour_Other;
const int LineMarkingColour_ARRAYSIZE = LineMarkingColour_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineMarkingColour_descriptor();
inline const ::std::string& LineMarkingColour_Name(LineMarkingColour value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineMarkingColour_descriptor(), value);
}
inline bool LineMarkingColour_Parse(
    const ::std::string& name, LineMarkingColour* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineMarkingColour>(
    LineMarkingColour_descriptor(), name, value);
}
enum LinearObjectType {
  LinearObjectType_Unknown = 0,
  LinearObjectType_Centerline = 1,
  LinearObjectType_LaneMarking = 2,
  LinearObjectType_Guardrail = 3,
  LinearObjectType_Fence = 4,
  LinearObjectType_Kerb = 5,
  LinearObjectType_Wall = 6,
  LinearObjectType_MMetalGuardrail = 7,
  LinearObjectType_CPureConcrete = 8,
  LinearObjectType_POtherGuardrail = 9,
  LinearObjectType_MCurb = 10,
  LinearObjectType_CCurb = 11,
  LinearObjectType_PCurb = 12,
  LinearObjectType_PureNature = 13,
  LinearObjectType_PureCurb = 14,
  LinearObjectType_WallFlat = 15,
  LinearObjectType_WallTunnel = 16,
  LinearObjectType_Canopy = 17,
  LinearObjectType_Other = 99
};
bool LinearObjectType_IsValid(int value);
const LinearObjectType LinearObjectType_MIN = LinearObjectType_Unknown;
const LinearObjectType LinearObjectType_MAX = LinearObjectType_Other;
const int LinearObjectType_ARRAYSIZE = LinearObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LinearObjectType_descriptor();
inline const ::std::string& LinearObjectType_Name(LinearObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LinearObjectType_descriptor(), value);
}
inline bool LinearObjectType_Parse(
    const ::std::string& name, LinearObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LinearObjectType>(
    LinearObjectType_descriptor(), name, value);
}
enum Load {
  Load_loadWaterPolluting = 1,
  Load_loadExplosive = 2,
  Load_loadOtherDangerous = 3,
  Load_loadEmpty = 4,
  Load_loadSpecial = 5,
  Load_loadGasses = 6,
  Load_loadFlammableLiquids = 7,
  Load_loadFlammableSolids = 8,
  Load_loadOxidizing = 9,
  Load_loadToxicInfectious = 10,
  Load_loadRadioactive = 11,
  Load_loadCorrosive = 12
};
bool Load_IsValid(int value);
const Load Load_MIN = Load_loadWaterPolluting;
const Load Load_MAX = Load_loadCorrosive;
const int Load_ARRAYSIZE = Load_MAX + 1;

const ::google::protobuf::EnumDescriptor* Load_descriptor();
inline const ::std::string& Load_Name(Load value) {
  return ::google::protobuf::internal::NameOfEnum(
    Load_descriptor(), value);
}
inline bool Load_Parse(
    const ::std::string& name, Load* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Load>(
    Load_descriptor(), name, value);
}
enum LocationObjectType {
  LocationObjectType_GuidePost = 1
};
bool LocationObjectType_IsValid(int value);
const LocationObjectType LocationObjectType_MIN = LocationObjectType_GuidePost;
const LocationObjectType LocationObjectType_MAX = LocationObjectType_GuidePost;
const int LocationObjectType_ARRAYSIZE = LocationObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LocationObjectType_descriptor();
inline const ::std::string& LocationObjectType_Name(LocationObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LocationObjectType_descriptor(), value);
}
inline bool LocationObjectType_Parse(
    const ::std::string& name, LocationObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LocationObjectType>(
    LocationObjectType_descriptor(), name, value);
}
enum MapProvider {
  MapProvider_provider_Unknown = 0,
  MapProvider_provider_AND = 1,
  MapProvider_provider_AutoNavi = 2,
  MapProvider_provider_HERE = 3,
  MapProvider_provider_Hyundai = 4,
  MapProvider_provider_Navinfo = 5,
  MapProvider_provider_TomTom = 6,
  MapProvider_provider_Zenrin = 7
};
bool MapProvider_IsValid(int value);
const MapProvider MapProvider_MIN = MapProvider_provider_Unknown;
const MapProvider MapProvider_MAX = MapProvider_provider_Zenrin;
const int MapProvider_ARRAYSIZE = MapProvider_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapProvider_descriptor();
inline const ::std::string& MapProvider_Name(MapProvider value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapProvider_descriptor(), value);
}
inline bool MapProvider_Parse(
    const ::std::string& name, MapProvider* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapProvider>(
    MapProvider_descriptor(), name, value);
}
enum MapStatus {
  MapStatus_mapNotAvailable = 0,
  MapStatus_mapLoading = 1,
  MapStatus_mapAvailable = 2
};
bool MapStatus_IsValid(int value);
const MapStatus MapStatus_MIN = MapStatus_mapNotAvailable;
const MapStatus MapStatus_MAX = MapStatus_mapAvailable;
const int MapStatus_ARRAYSIZE = MapStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* MapStatus_descriptor();
inline const ::std::string& MapStatus_Name(MapStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    MapStatus_descriptor(), value);
}
inline bool MapStatus_Parse(
    const ::std::string& name, MapStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MapStatus>(
    MapStatus_descriptor(), name, value);
}
enum MessageType {
  MessageType_Position = 1,
  MessageType_Profile = 2,
  MessageType_GlobalData = 3,
  MessageType_ProfileControl = 4,
  MessageType_PathControl = 5,
  MessageType_Reason = 6
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = MessageType_Position;
const MessageType MessageType_MAX = MessageType_Reason;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum ProfileType {
  ProfileType_Unknown = 0,
  ProfileType_Node = 1,
  ProfileType_Probability = 2,
  ProfileType_HeadingChange = 3,
  ProfileType_LaneModel = 4,
  ProfileType_LaneConnectivity = 5,
  ProfileType_LinearObjects = 6,
  ProfileType_LanesGeometry = 7,
  ProfileType_LaneWidth = 8,
  ProfileType_RoadGeometry = 9,
  ProfileType_NumberOfLanesPerDirection = 10,
  ProfileType_ComplexIntersection = 11,
  ProfileType_LinkIdentifier = 12,
  ProfileType_FunctionalRoadClass = 13,
  ProfileType_RouteNumberTypes = 14,
  ProfileType_FormOfWay = 15,
  ProfileType_RoadAccessibility = 16,
  ProfileType_AccessRestriction = 17,
  ProfileType_OvertakingRestriction = 18,
  ProfileType_Tunnel = 19,
  ProfileType_Bridge = 20,
  ProfileType_DividedRoad = 21,
  ProfileType_Curvature = 22,
  ProfileType_Slope = 23,
  ProfileType_BuiltUpArea = 24,
  ProfileType_InTown = 25,
  ProfileType_Surface = 26,
  ProfileType_TrafficSign = 27,
  ProfileType_TrafficLight = 28,
  ProfileType_SpecialSituation = 29,
  ProfileType_EffectiveSpeedLimit = 30,
  ProfileType_ExtendedSpeedLimit = 31,
  ProfileType_TravelSpeed = 32,
  ProfileType_FlowSpeed = 33,
  ProfileType_RoadCondition = 34,
  ProfileType_Weather = 35,
  ProfileType_LocationObject = 36,
  ProfileType_PartOfCalculatedRoute = 37,
  ProfileType_CountryCode = 38,
  ProfileType_RegionCode = 39,
  ProfileType_DrivingSide = 40,
  ProfileType_UnitSystem = 41,
  ProfileType_VersionProtocol = 42,
  ProfileType_VersionHardware = 43,
  ProfileType_VersionMap = 44,
  ProfileType_MapAge = 45,
  ProfileType_MapProvider = 46,
  ProfileType_MapStatus = 47,
  ProfileType_SystemStatus = 48,
  ProfileType_TimeZoneOffset = 49,
  ProfileType_AbsoluteVehiclePosition = 50,
  ProfileType_RoadSurface = 98,
  ProfileType_Pole = 99,
  ProfileType_RoadStatus = 100,
  ProfileType_TrafficFlow = 101,
  ProfileType_TrafficEvent = 102,
  ProfileType_StaticNotODD = 103,
  ProfileType_StaticODD = 108,
  ProfileType_Ready = 109,
  ProfileType_DecelerationZone = 110,
  ProfileType_LaneStatus = 112,
  ProfileType_OverHead = 113
};
bool ProfileType_IsValid(int value);
const ProfileType ProfileType_MIN = ProfileType_Unknown;
const ProfileType ProfileType_MAX = ProfileType_OverHead;
const int ProfileType_ARRAYSIZE = ProfileType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProfileType_descriptor();
inline const ::std::string& ProfileType_Name(ProfileType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProfileType_descriptor(), value);
}
inline bool ProfileType_Parse(
    const ::std::string& name, ProfileType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProfileType>(
    ProfileType_descriptor(), name, value);
}
enum Quality {
  Quality_Unknown = 1,
  Quality_NotAvailable = 2,
  Quality_Value1 = 3,
  Quality_Value2 = 4,
  Quality_Value3 = 5,
  Quality_Value4 = 6,
  Quality_Value5 = 7
};
bool Quality_IsValid(int value);
const Quality Quality_MIN = Quality_Unknown;
const Quality Quality_MAX = Quality_Value5;
const int Quality_ARRAYSIZE = Quality_MAX + 1;

const ::google::protobuf::EnumDescriptor* Quality_descriptor();
inline const ::std::string& Quality_Name(Quality value) {
  return ::google::protobuf::internal::NameOfEnum(
    Quality_descriptor(), value);
}
inline bool Quality_Parse(
    const ::std::string& name, Quality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Quality>(
    Quality_descriptor(), name, value);
}
enum RelativeDirection {
  RelativeDirection_None = 0,
  RelativeDirection_Both = 1,
  RelativeDirection_AlongPathDirection = 2,
  RelativeDirection_AgainstPathDirection = 3
};
bool RelativeDirection_IsValid(int value);
const RelativeDirection RelativeDirection_MIN = RelativeDirection_None;
const RelativeDirection RelativeDirection_MAX = RelativeDirection_AgainstPathDirection;
const int RelativeDirection_ARRAYSIZE = RelativeDirection_MAX + 1;

const ::google::protobuf::EnumDescriptor* RelativeDirection_descriptor();
inline const ::std::string& RelativeDirection_Name(RelativeDirection value) {
  return ::google::protobuf::internal::NameOfEnum(
    RelativeDirection_descriptor(), value);
}
inline bool RelativeDirection_Parse(
    const ::std::string& name, RelativeDirection* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RelativeDirection>(
    RelativeDirection_descriptor(), name, value);
}
enum RightOfWay {
  RightOfWay_Unknown = 0,
  RightOfWay_MustYield = 1,
  RightOfWay_HasRightOfWay = 2
};
bool RightOfWay_IsValid(int value);
const RightOfWay RightOfWay_MIN = RightOfWay_Unknown;
const RightOfWay RightOfWay_MAX = RightOfWay_HasRightOfWay;
const int RightOfWay_ARRAYSIZE = RightOfWay_MAX + 1;

const ::google::protobuf::EnumDescriptor* RightOfWay_descriptor();
inline const ::std::string& RightOfWay_Name(RightOfWay value) {
  return ::google::protobuf::internal::NameOfEnum(
    RightOfWay_descriptor(), value);
}
inline bool RightOfWay_Parse(
    const ::std::string& name, RightOfWay* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RightOfWay>(
    RightOfWay_descriptor(), name, value);
}
enum RoadAccessFlags {
  RoadAccessFlags_PassengerCars = 1,
  RoadAccessFlags_Pedestrians = 2,
  RoadAccessFlags_Bus = 4,
  RoadAccessFlags_Delivery = 8,
  RoadAccessFlags_Emergency = 16,
  RoadAccessFlags_Taxi = 32,
  RoadAccessFlags_ThroughTraffic = 64,
  RoadAccessFlags_Trucks = 128
};
bool RoadAccessFlags_IsValid(int value);
const RoadAccessFlags RoadAccessFlags_MIN = RoadAccessFlags_PassengerCars;
const RoadAccessFlags RoadAccessFlags_MAX = RoadAccessFlags_Trucks;
const int RoadAccessFlags_ARRAYSIZE = RoadAccessFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadAccessFlags_descriptor();
inline const ::std::string& RoadAccessFlags_Name(RoadAccessFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadAccessFlags_descriptor(), value);
}
inline bool RoadAccessFlags_Parse(
    const ::std::string& name, RoadAccessFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadAccessFlags>(
    RoadAccessFlags_descriptor(), name, value);
}
enum RoadCondition {
  RoadCondition_Unknown = 1,
  RoadCondition_Clear = 2,
  RoadCondition_Wet = 3,
  RoadCondition_Snowy = 4,
  RoadCondition_Icy = 5,
  RoadCondition_Slippery = 6,
  RoadCondition_Dirt = 7
};
bool RoadCondition_IsValid(int value);
const RoadCondition RoadCondition_MIN = RoadCondition_Unknown;
const RoadCondition RoadCondition_MAX = RoadCondition_Dirt;
const int RoadCondition_ARRAYSIZE = RoadCondition_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadCondition_descriptor();
inline const ::std::string& RoadCondition_Name(RoadCondition value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadCondition_descriptor(), value);
}
inline bool RoadCondition_Parse(
    const ::std::string& name, RoadCondition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadCondition>(
    RoadCondition_descriptor(), name, value);
}
enum SpecialSituationType {
  SpecialSituationType_DeadEnd = 248,
  SpecialSituationType_FerryTerminal = 249,
  SpecialSituationType_TollBooth = 250,
  SpecialSituationType_RailroadCrossing = 251,
  SpecialSituationType_PedestrianCrossing = 252,
  SpecialSituationType_SpeedBump = 253,
  SpecialSituationType_CertifiedRoad = 254,
  SpecialSituationType_TollBooth_CertifiedRoad = 255
};
bool SpecialSituationType_IsValid(int value);
const SpecialSituationType SpecialSituationType_MIN = SpecialSituationType_DeadEnd;
const SpecialSituationType SpecialSituationType_MAX = SpecialSituationType_TollBooth_CertifiedRoad;
const int SpecialSituationType_ARRAYSIZE = SpecialSituationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpecialSituationType_descriptor();
inline const ::std::string& SpecialSituationType_Name(SpecialSituationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpecialSituationType_descriptor(), value);
}
inline bool SpecialSituationType_Parse(
    const ::std::string& name, SpecialSituationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpecialSituationType>(
    SpecialSituationType_descriptor(), name, value);
}
enum SpeedLimitSource {
  SpeedLimitSource_Unknown = 1,
  SpeedLimitSource_Implicit = 2,
  SpeedLimitSource_Explicit = 3
};
bool SpeedLimitSource_IsValid(int value);
const SpeedLimitSource SpeedLimitSource_MIN = SpeedLimitSource_Unknown;
const SpeedLimitSource SpeedLimitSource_MAX = SpeedLimitSource_Explicit;
const int SpeedLimitSource_ARRAYSIZE = SpeedLimitSource_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpeedLimitSource_descriptor();
inline const ::std::string& SpeedLimitSource_Name(SpeedLimitSource value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpeedLimitSource_descriptor(), value);
}
inline bool SpeedLimitSource_Parse(
    const ::std::string& name, SpeedLimitSource* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpeedLimitSource>(
    SpeedLimitSource_descriptor(), name, value);
}
enum SurfaceCondition {
  SurfaceCondition_Unknown = 1,
  SurfaceCondition_PavedRigid = 2,
  SurfaceCondition_PavedFlexible = 3,
  SurfaceCondition_Blocks = 4,
  SurfaceCondition_Gravel = 5,
  SurfaceCondition_Dirt = 6
};
bool SurfaceCondition_IsValid(int value);
const SurfaceCondition SurfaceCondition_MIN = SurfaceCondition_Unknown;
const SurfaceCondition SurfaceCondition_MAX = SurfaceCondition_Dirt;
const int SurfaceCondition_ARRAYSIZE = SurfaceCondition_MAX + 1;

const ::google::protobuf::EnumDescriptor* SurfaceCondition_descriptor();
inline const ::std::string& SurfaceCondition_Name(SurfaceCondition value) {
  return ::google::protobuf::internal::NameOfEnum(
    SurfaceCondition_descriptor(), value);
}
inline bool SurfaceCondition_Parse(
    const ::std::string& name, SurfaceCondition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SurfaceCondition>(
    SurfaceCondition_descriptor(), name, value);
}
enum TrafficLightLongitudinalPosition {
  TrafficLightLongitudinalPosition_Unknown = 0,
  TrafficLightLongitudinalPosition_BeforeIntersection = 1,
  TrafficLightLongitudinalPosition_AfterIntersection = 2
};
bool TrafficLightLongitudinalPosition_IsValid(int value);
const TrafficLightLongitudinalPosition TrafficLightLongitudinalPosition_MIN = TrafficLightLongitudinalPosition_Unknown;
const TrafficLightLongitudinalPosition TrafficLightLongitudinalPosition_MAX = TrafficLightLongitudinalPosition_AfterIntersection;
const int TrafficLightLongitudinalPosition_ARRAYSIZE = TrafficLightLongitudinalPosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightLongitudinalPosition_descriptor();
inline const ::std::string& TrafficLightLongitudinalPosition_Name(TrafficLightLongitudinalPosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightLongitudinalPosition_descriptor(), value);
}
inline bool TrafficLightLongitudinalPosition_Parse(
    const ::std::string& name, TrafficLightLongitudinalPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightLongitudinalPosition>(
    TrafficLightLongitudinalPosition_descriptor(), name, value);
}
enum TrafficLightState {
  TrafficLightState_Unknown = 0,
  TrafficLightState_Invalid = 1,
  TrafficLightState_Off = 2,
  TrafficLightState_Green = 3,
  TrafficLightState_Yellow = 4,
  TrafficLightState_Red = 5
};
bool TrafficLightState_IsValid(int value);
const TrafficLightState TrafficLightState_MIN = TrafficLightState_Unknown;
const TrafficLightState TrafficLightState_MAX = TrafficLightState_Red;
const int TrafficLightState_ARRAYSIZE = TrafficLightState_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficLightState_descriptor();
inline const ::std::string& TrafficLightState_Name(TrafficLightState value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficLightState_descriptor(), value);
}
inline bool TrafficLightState_Parse(
    const ::std::string& name, TrafficLightState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficLightState>(
    TrafficLightState_descriptor(), name, value);
}
enum UnitOfSpeed {
  UnitOfSpeed_KpH = 1,
  UnitOfSpeed_MpH = 2
};
bool UnitOfSpeed_IsValid(int value);
const UnitOfSpeed UnitOfSpeed_MIN = UnitOfSpeed_KpH;
const UnitOfSpeed UnitOfSpeed_MAX = UnitOfSpeed_MpH;
const int UnitOfSpeed_ARRAYSIZE = UnitOfSpeed_MAX + 1;

const ::google::protobuf::EnumDescriptor* UnitOfSpeed_descriptor();
inline const ::std::string& UnitOfSpeed_Name(UnitOfSpeed value) {
  return ::google::protobuf::internal::NameOfEnum(
    UnitOfSpeed_descriptor(), value);
}
inline bool UnitOfSpeed_Parse(
    const ::std::string& name, UnitOfSpeed* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UnitOfSpeed>(
    UnitOfSpeed_descriptor(), name, value);
}
enum Weather {
  Weather_Unknown = 0,
  Weather_NoSpecial = 1,
  Weather_Sunshine = 2,
  Weather_Rain = 3,
  Weather_Fog = 4,
  Weather_Snow = 5,
  Weather_Ice = 6,
  Weather_StrongWind = 7
};
bool Weather_IsValid(int value);
const Weather Weather_MIN = Weather_Unknown;
const Weather Weather_MAX = Weather_StrongWind;
const int Weather_ARRAYSIZE = Weather_MAX + 1;

const ::google::protobuf::EnumDescriptor* Weather_descriptor();
inline const ::std::string& Weather_Name(Weather value) {
  return ::google::protobuf::internal::NameOfEnum(
    Weather_descriptor(), value);
}
inline bool Weather_Parse(
    const ::std::string& name, Weather* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Weather>(
    Weather_descriptor(), name, value);
}
enum WeatherRedefine {
  WeatherRedefine_SunnyOrClear = 0,
  WeatherRedefine_Cloudy = 1,
  WeatherRedefine_FewClouds = 2,
  WeatherRedefine_PartlyCoundy = 3,
  WeatherRedefine_Overcast = 4,
  WeatherRedefine_Windy = 5,
  WeatherRedefine_Calm = 6,
  WeatherRedefine_LightBreeze = 7,
  WeatherRedefine_ModerateOrGentleBreeze = 8,
  WeatherRedefine_FreshBreeze = 9,
  WeatherRedefine_StrongBreeze = 10,
  WeatherRedefine_HightWindAndNearGale = 11,
  WeatherRedefine_Gale = 12,
  WeatherRedefine_StrongGale = 13,
  WeatherRedefine_WindStorm = 14,
  WeatherRedefine_ViolentWindStorm = 15,
  WeatherRedefine_Hurricane = 16,
  WeatherRedefine_Tornado = 17,
  WeatherRedefine_TropicalStorm = 18,
  WeatherRedefine_ShowerRain = 19,
  WeatherRedefine_HeavyShowerRain = 20,
  WeatherRedefine_Thundershower = 21,
  WeatherRedefine_HeavyThunderstorm = 22,
  WeatherRedefine_ThundershowerAndHail = 23,
  WeatherRedefine_LightRain = 24,
  WeatherRedefine_ModerateRain = 25,
  WeatherRedefine_HeavyRain = 26,
  WeatherRedefine_ExtremeRain = 27,
  WeatherRedefine_DrizzleRain = 28,
  WeatherRedefine_RainStorm = 29,
  WeatherRedefine_HeavyRainStorm = 30,
  WeatherRedefine_SevereRainStorm = 31,
  WeatherRedefine_FreezingRain = 32,
  WeatherRedefine_LightSnow = 33,
  WeatherRedefine_ModerateSnow = 34,
  WeatherRedefine_HeavySnow = 35,
  WeatherRedefine_Snowstorm = 36,
  WeatherRedefine_Sleet = 37,
  WeatherRedefine_RainAndSnow = 38,
  WeatherRedefine_ShowerSnow = 39,
  WeatherRedefine_SnowFlurry = 40,
  WeatherRedefine_Mist = 41,
  WeatherRedefine_Foggy = 42,
  WeatherRedefine_Haze = 43,
  WeatherRedefine_Sand = 44,
  WeatherRedefine_Dust = 45,
  WeatherRedefine_Duststorm = 46,
  WeatherRedefine_Sandstorm = 47,
  WeatherRedefine_Hot = 48,
  WeatherRedefine_Cold = 49,
  WeatherRedefine_IceParticle = 50,
  WeatherRedefine_IceNeedle = 51,
  WeatherRedefine_Hail = 52,
  WeatherRedefine_LightningStorm = 53,
  WeatherRedefine_Lightning = 54,
  WeatherRedefine_Unknown = 127,
  WeatherRedefine_Other = 99
};
bool WeatherRedefine_IsValid(int value);
const WeatherRedefine WeatherRedefine_MIN = WeatherRedefine_SunnyOrClear;
const WeatherRedefine WeatherRedefine_MAX = WeatherRedefine_Unknown;
const int WeatherRedefine_ARRAYSIZE = WeatherRedefine_MAX + 1;

const ::google::protobuf::EnumDescriptor* WeatherRedefine_descriptor();
inline const ::std::string& WeatherRedefine_Name(WeatherRedefine value) {
  return ::google::protobuf::internal::NameOfEnum(
    WeatherRedefine_descriptor(), value);
}
inline bool WeatherRedefine_Parse(
    const ::std::string& name, WeatherRedefine* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WeatherRedefine>(
    WeatherRedefine_descriptor(), name, value);
}
enum YesNoUnknown {
  YesNoUnknown_Unknown = 0,
  YesNoUnknown_Yes = 1,
  YesNoUnknown_No = 2
};
bool YesNoUnknown_IsValid(int value);
const YesNoUnknown YesNoUnknown_MIN = YesNoUnknown_Unknown;
const YesNoUnknown YesNoUnknown_MAX = YesNoUnknown_No;
const int YesNoUnknown_ARRAYSIZE = YesNoUnknown_MAX + 1;

const ::google::protobuf::EnumDescriptor* YesNoUnknown_descriptor();
inline const ::std::string& YesNoUnknown_Name(YesNoUnknown value) {
  return ::google::protobuf::internal::NameOfEnum(
    YesNoUnknown_descriptor(), value);
}
inline bool YesNoUnknown_Parse(
    const ::std::string& name, YesNoUnknown* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YesNoUnknown>(
    YesNoUnknown_descriptor(), name, value);
}
enum RoadStatus {
  RoadStatus_Unknown = 0,
  RoadStatus_NormalTraversable = 1,
  RoadStatus_InConstruction = 2,
  RoadStatus_DrivingProhibition = 3,
  RoadStatus_Other = 99
};
bool RoadStatus_IsValid(int value);
const RoadStatus RoadStatus_MIN = RoadStatus_Unknown;
const RoadStatus RoadStatus_MAX = RoadStatus_Other;
const int RoadStatus_ARRAYSIZE = RoadStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadStatus_descriptor();
inline const ::std::string& RoadStatus_Name(RoadStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadStatus_descriptor(), value);
}
inline bool RoadStatus_Parse(
    const ::std::string& name, RoadStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadStatus>(
    RoadStatus_descriptor(), name, value);
}
enum TrafficSignSignType {
  TrafficSignSignType_RoadWorks = 6,
  TrafficSignSignType_Stop = 33,
  TrafficSignSignType_OvertakingProhibited = 46,
  TrafficSignSignType_EndOfProhibitionOnOvertaking = 47,
  TrafficSignSignType_ChildrenAndSchoolZone = 52,
  TrafficSignSignType_MinSpeedLimit = 86,
  TrafficSignSignType_MaxSpeedLimit = 87,
  TrafficSignSignType_EndOfSpeedLimit = 88,
  TrafficSignSignType_NoEntrance = 245,
  TrafficSignSignType_AllSpeedLimitCancel = 246,
  TrafficSignSignType_NoParkingSign = 247,
  TrafficSignSignType_Others = 250,
  TrafficSignSignType_StartOfHighway = 251,
  TrafficSignSignType_EndOfHighway = 252,
  TrafficSignSignType_LeftCurve = 253,
  TrafficSignSignType_RightCurve = 254,
  TrafficSignSignType_Unknown = 255,
  TrafficSignSignType_SeriesCurves = 256
};
bool TrafficSignSignType_IsValid(int value);
const TrafficSignSignType TrafficSignSignType_MIN = TrafficSignSignType_RoadWorks;
const TrafficSignSignType TrafficSignSignType_MAX = TrafficSignSignType_SeriesCurves;
const int TrafficSignSignType_ARRAYSIZE = TrafficSignSignType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficSignSignType_descriptor();
inline const ::std::string& TrafficSignSignType_Name(TrafficSignSignType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficSignSignType_descriptor(), value);
}
inline bool TrafficSignSignType_Parse(
    const ::std::string& name, TrafficSignSignType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficSignSignType>(
    TrafficSignSignType_descriptor(), name, value);
}
enum OverHeadType {
  OverHeadType_Unknown = 0,
  OverHeadType_BottomOfBridge = 1,
  OverHeadType_Other = 99
};
bool OverHeadType_IsValid(int value);
const OverHeadType OverHeadType_MIN = OverHeadType_Unknown;
const OverHeadType OverHeadType_MAX = OverHeadType_Other;
const int OverHeadType_ARRAYSIZE = OverHeadType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OverHeadType_descriptor();
inline const ::std::string& OverHeadType_Name(OverHeadType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OverHeadType_descriptor(), value);
}
inline bool OverHeadType_Parse(
    const ::std::string& name, OverHeadType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OverHeadType>(
    OverHeadType_descriptor(), name, value);
}
enum RoadSurfaceSignType {
  RoadSurfaceSignType_Unknown = 0,
  RoadSurfaceSignType_Text = 1,
  RoadSurfaceSignType_Straight = 2,
  RoadSurfaceSignType_StraightOrLeft = 3,
  RoadSurfaceSignType_StraightOrRight = 4,
  RoadSurfaceSignType_StraightUTurn = 5,
  RoadSurfaceSignType_LeftTurn = 6,
  RoadSurfaceSignType_LeftTurnUTurn = 7,
  RoadSurfaceSignType_LeftTurnAndInterflow = 8,
  RoadSurfaceSignType_RightTurn = 9,
  RoadSurfaceSignType_RightTurnAndInterflow = 10,
  RoadSurfaceSignType_LeftRightTurn = 11,
  RoadSurfaceSignType_UTurn = 12,
  RoadSurfaceSignType_NoLeftTurn = 13,
  RoadSurfaceSignType_NoRightTurn = 14,
  RoadSurfaceSignType_NoUTurn = 15,
  RoadSurfaceSignType_StraightLeftRight = 16,
  RoadSurfaceSignType_StraightULeft = 17,
  RoadSurfaceSignType_RightUTurn = 18,
  RoadSurfaceSignType_MaxSpeedLimit = 19,
  RoadSurfaceSignType_MinSpeedLimit = 20,
  RoadSurfaceSignType_Time = 21,
  RoadSurfaceSignType_CheckFollowingDistance = 22,
  RoadSurfaceSignType_StopToGiveway = 23,
  RoadSurfaceSignType_SlowdownToGiveway = 24,
  RoadSurfaceSignType_StopMark = 25,
  RoadSurfaceSignType_Nets = 26,
  RoadSurfaceSignType_Other = 99
};
bool RoadSurfaceSignType_IsValid(int value);
const RoadSurfaceSignType RoadSurfaceSignType_MIN = RoadSurfaceSignType_Unknown;
const RoadSurfaceSignType RoadSurfaceSignType_MAX = RoadSurfaceSignType_Other;
const int RoadSurfaceSignType_ARRAYSIZE = RoadSurfaceSignType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoadSurfaceSignType_descriptor();
inline const ::std::string& RoadSurfaceSignType_Name(RoadSurfaceSignType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoadSurfaceSignType_descriptor(), value);
}
inline bool RoadSurfaceSignType_Parse(
    const ::std::string& name, RoadSurfaceSignType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoadSurfaceSignType>(
    RoadSurfaceSignType_descriptor(), name, value);
}
enum PoleSignType {
  PoleSignType_Unknown = 0,
  PoleSignType_Gantry = 1,
  PoleSignType_SignPost = 2,
  PoleSignType_Signal = 4,
  PoleSignType_Other = 99
};
bool PoleSignType_IsValid(int value);
const PoleSignType PoleSignType_MIN = PoleSignType_Unknown;
const PoleSignType PoleSignType_MAX = PoleSignType_Other;
const int PoleSignType_ARRAYSIZE = PoleSignType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PoleSignType_descriptor();
inline const ::std::string& PoleSignType_Name(PoleSignType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PoleSignType_descriptor(), value);
}
inline bool PoleSignType_Parse(
    const ::std::string& name, PoleSignType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PoleSignType>(
    PoleSignType_descriptor(), name, value);
}
enum SignShape {
  SignShape_Unknown = 0,
  SignShape_Rectangle = 1,
  SignShape_Triangle = 2,
  SignShape_Round = 3,
  SignShape_Diamond = 4,
  SignShape_Hexagon = 5,
  SignShape_Octagon = 6,
  SignShape_Furcation = 7,
  SignShape_Combination = 8,
  SignShape_Other = 99
};
bool SignShape_IsValid(int value);
const SignShape SignShape_MIN = SignShape_Unknown;
const SignShape SignShape_MAX = SignShape_Other;
const int SignShape_ARRAYSIZE = SignShape_MAX + 1;

const ::google::protobuf::EnumDescriptor* SignShape_descriptor();
inline const ::std::string& SignShape_Name(SignShape value) {
  return ::google::protobuf::internal::NameOfEnum(
    SignShape_descriptor(), value);
}
inline bool SignShape_Parse(
    const ::std::string& name, SignShape* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SignShape>(
    SignShape_descriptor(), name, value);
}
enum TrafficFlowStatus {
  TrafficFlowStatus_Unknown = 0,
  TrafficFlowStatus_Smooth = 1,
  TrafficFlowStatus_Amble = 2,
  TrafficFlowStatus_Congestion = 3,
  TrafficFlowStatus_Blockage = 4,
  TrafficFlowStatus_NoTrafficFlow = 5,
  TrafficFlowStatus_Other = 99
};
bool TrafficFlowStatus_IsValid(int value);
const TrafficFlowStatus TrafficFlowStatus_MIN = TrafficFlowStatus_Unknown;
const TrafficFlowStatus TrafficFlowStatus_MAX = TrafficFlowStatus_Other;
const int TrafficFlowStatus_ARRAYSIZE = TrafficFlowStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficFlowStatus_descriptor();
inline const ::std::string& TrafficFlowStatus_Name(TrafficFlowStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficFlowStatus_descriptor(), value);
}
inline bool TrafficFlowStatus_Parse(
    const ::std::string& name, TrafficFlowStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficFlowStatus>(
    TrafficFlowStatus_descriptor(), name, value);
}
enum TrafficEventType {
  TrafficEventType_Unknown = 0,
  TrafficEventType_GeneralTrafficAccident = 7,
  TrafficEventType_SeriousTrafficAccident = 8,
  TrafficEventType_FaultyCar = 9,
  TrafficEventType_SuspectedAccident = 10,
  TrafficEventType_RoadConstruction = 11,
  TrafficEventType_ConstructionImpactTravel = 12,
  TrafficEventType_ConstructionAndPassThroughNotRecommended = 13,
  TrafficEventType_TrafficControl = 14,
  TrafficEventType_RoadClosed = 15,
  TrafficEventType_ExitRampClosed = 16,
  TrafficEventType_EntranceRampClosed = 17,
  TrafficEventType_OneLaneClosed = 18,
  TrafficEventType_TwoLanesClosed = 19,
  TrafficEventType_ThreeLanesClosed = 20,
  TrafficEventType_FourLanesClosed = 21,
  TrafficEventType_ProhibitLeftTurn = 22,
  TrafficEventType_ProhibitRightTurn = 24,
  TrafficEventType_ProhibitLeftAndRightTurn = 26,
  TrafficEventType_ProhibitStraight = 28,
  TrafficEventType_ProhibitUTurn = 30,
  TrafficEventType_RoadHeightOrWeightOrWidthLimited = 32,
  TrafficEventType_OtherVehicleRestrictions = 33,
  TrafficEventType_NoParking = 34,
  TrafficEventType_Gale = 35,
  TrafficEventType_Hurricane = 36,
  TrafficEventType_Fog = 37,
  TrafficEventType_HeavyFog = 38,
  TrafficEventType_Rain = 39,
  TrafficEventType_HeavyRain = 40,
  TrafficEventType_Sleet = 41,
  TrafficEventType_Snow = 42,
  TrafficEventType_HeavySnow = 43,
  TrafficEventType_Hail = 44,
  TrafficEventType_DestructiveHail = 45,
  TrafficEventType_ColdWave = 46,
  TrafficEventType_Sandstorm = 47,
  TrafficEventType_HighTemperature = 48,
  TrafficEventType_Drought = 49,
  TrafficEventType_Thunder = 50,
  TrafficEventType_Frost = 51,
  TrafficEventType_Haze = 52,
  TrafficEventType_Typhoon = 53,
  TrafficEventType_Thunderstorm = 54,
  TrafficEventType_ForestFire = 55,
  TrafficEventType_RoadSurfaceWater = 56,
  TrafficEventType_RoadSurfaceSnow = 57,
  TrafficEventType_RoadSurfaceThinIce = 58,
  TrafficEventType_RoadSurfaceSubsidence = 59,
  TrafficEventType_RoadSurfaceObstacle = 60,
  TrafficEventType_RoadSurfaceFire = 61,
  TrafficEventType_RoadSurfaceSlip = 62,
  TrafficEventType_RoadSurfaceOil = 63,
  TrafficEventType_RoadSurfaceGasoline = 64,
  TrafficEventType_PoorRoadConditions = 65,
  TrafficEventType_DangerousDrivingConditions = 66,
  TrafficEventType_ExtremelyDangerousDrivingConditions = 67,
  TrafficEventType_Expo = 68,
  TrafficEventType_MajorNationalEvents = 69,
  TrafficEventType_Assembly = 70,
  TrafficEventType_LargeConference = 71,
  TrafficEventType_SportsActivity = 72,
  TrafficEventType_CulturalActivity = 73,
  TrafficEventType_Holiday = 74,
  TrafficEventType_Flood = 75,
  TrafficEventType_Earthquake = 76,
  TrafficEventType_RockFall = 77,
  TrafficEventType_Collapse = 78,
  TrafficEventType_DebrisFlow = 79,
  TrafficEventType_GraspTheViolation = 80,
  TrafficEventType_CheckDrunkDriving = 81,
  TrafficEventType_PoliceEnforcement = 82,
  TrafficEventType_Announcement = 83,
  TrafficEventType_OpenToTraffic = 84,
  TrafficEventType_CompleteTheReconstruction = 85,
  TrafficEventType_RealRoadCondition = 86,
  TrafficEventType_Emergency = 87,
  TrafficEventType_SubwayEvent = 88,
  TrafficEventType_CustomBroadcast = 89,
  TrafficEventType_GeneralTrafficAccidentAndRoadClosed = 90,
  TrafficEventType_SeriousTrafficAccidentAndRoadClosed = 91,
  TrafficEventType_RoadConstructionAndRoadClosed = 92,
  TrafficEventType_HeavyFogAndRoadClosed = 93,
  TrafficEventType_HeavyRainAndRoadClosed = 94,
  TrafficEventType_HeavySnowAndRoadClosed = 95,
  TrafficEventType_HailAndRoadClosed = 96,
  TrafficEventType_RoadSurfaceWaterAndRoadClosed = 97,
  TrafficEventType_RoadSurfaceSnowAndRoadClosed = 98,
  TrafficEventType_RoadSurfaceThinIceAndRoadClosed = 99,
  TrafficEventType_RoadSurfaceSubsidenceAndRoadClosed = 100,
  TrafficEventType_RoadSurfaceObstacleAndRoadClosed = 101,
  TrafficEventType_SeriousFireAndRoadClosed = 102,
  TrafficEventType_ExpoAndRoadClosed = 103,
  TrafficEventType_MajorNationalEventsAndRoadClosed = 104,
  TrafficEventType_AssemblyAndRoadClosed = 105,
  TrafficEventType_LargeConferenceAndRoadClosed = 106,
  TrafficEventType_SportsActivityAndRoadClosed = 107,
  TrafficEventType_CulturalActivityAndRoadClosed = 108,
  TrafficEventType_HolidayAndRoadClosed = 109,
  TrafficEventType_FloodAndRoadClosed = 110,
  TrafficEventType_EarthquakeAndRoadClosed = 111,
  TrafficEventType_RockFallAndRoadClosed = 112,
  TrafficEventType_CollapseAndRoadClosed = 113,
  TrafficEventType_DebrisFlowAndRoadClosed = 114,
  TrafficEventType_Other = 999
};
bool TrafficEventType_IsValid(int value);
const TrafficEventType TrafficEventType_MIN = TrafficEventType_Unknown;
const TrafficEventType TrafficEventType_MAX = TrafficEventType_Other;
const int TrafficEventType_ARRAYSIZE = TrafficEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* TrafficEventType_descriptor();
inline const ::std::string& TrafficEventType_Name(TrafficEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    TrafficEventType_descriptor(), value);
}
inline bool TrafficEventType_Parse(
    const ::std::string& name, TrafficEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TrafficEventType>(
    TrafficEventType_descriptor(), name, value);
}
enum DecelerationZoneType {
  DecelerationZoneType_Unknown = 0,
  DecelerationZoneType_SLOWDOWNANTISKID = 1,
  DecelerationZoneType_ROADHUMP = 2,
  DecelerationZoneType_Other = 99
};
bool DecelerationZoneType_IsValid(int value);
const DecelerationZoneType DecelerationZoneType_MIN = DecelerationZoneType_Unknown;
const DecelerationZoneType DecelerationZoneType_MAX = DecelerationZoneType_Other;
const int DecelerationZoneType_ARRAYSIZE = DecelerationZoneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DecelerationZoneType_descriptor();
inline const ::std::string& DecelerationZoneType_Name(DecelerationZoneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DecelerationZoneType_descriptor(), value);
}
inline bool DecelerationZoneType_Parse(
    const ::std::string& name, DecelerationZoneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DecelerationZoneType>(
    DecelerationZoneType_descriptor(), name, value);
}
enum LinearObjectConfidence {
  LinearObjectConfidence_Unknown = 0,
  LinearObjectConfidence_Normal = 1,
  LinearObjectConfidence_Obscured = 2,
  LinearObjectConfidence_NotClear = 3,
  LinearObjectConfidence_NotAligned = 4,
  LinearObjectConfidence_InterferenceLine = 5,
  LinearObjectConfidence_OverlapLine = 6,
  LinearObjectConfidence_MeanWhile = 7,
  LinearObjectConfidence_Other = 99
};
bool LinearObjectConfidence_IsValid(int value);
const LinearObjectConfidence LinearObjectConfidence_MIN = LinearObjectConfidence_Unknown;
const LinearObjectConfidence LinearObjectConfidence_MAX = LinearObjectConfidence_Other;
const int LinearObjectConfidence_ARRAYSIZE = LinearObjectConfidence_MAX + 1;

const ::google::protobuf::EnumDescriptor* LinearObjectConfidence_descriptor();
inline const ::std::string& LinearObjectConfidence_Name(LinearObjectConfidence value) {
  return ::google::protobuf::internal::NameOfEnum(
    LinearObjectConfidence_descriptor(), value);
}
inline bool LinearObjectConfidence_Parse(
    const ::std::string& name, LinearObjectConfidence* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LinearObjectConfidence>(
    LinearObjectConfidence_descriptor(), name, value);
}
enum ReasonType {
  ReasonType_Unknown = 0,
  ReasonType_Reset = 1,
  ReasonType_RouteStatus = 2,
  ReasonType_Other = 255
};
bool ReasonType_IsValid(int value);
const ReasonType ReasonType_MIN = ReasonType_Unknown;
const ReasonType ReasonType_MAX = ReasonType_Other;
const int ReasonType_ARRAYSIZE = ReasonType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReasonType_descriptor();
inline const ::std::string& ReasonType_Name(ReasonType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReasonType_descriptor(), value);
}
inline bool ReasonType_Parse(
    const ::std::string& name, ReasonType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReasonType>(
    ReasonType_descriptor(), name, value);
}
// ===================================================================

class Vector : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.Vector) */ {
 public:
  Vector();
  virtual ~Vector();

  Vector(const Vector& from);

  inline Vector& operator=(const Vector& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Vector(Vector&& from) noexcept
    : Vector() {
    *this = ::std::move(from);
  }

  inline Vector& operator=(Vector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Vector* internal_default_instance() {
    return reinterpret_cast<const Vector*>(
               &_Vector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Vector* other);
  friend void swap(Vector& a, Vector& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Vector* New() const final {
    return CreateMaybeMessage<Vector>(NULL);
  }

  Vector* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Vector>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Vector& from);
  void MergeFrom(const Vector& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vector* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.Vector)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Speed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.Speed) */ {
 public:
  Speed();
  virtual ~Speed();

  Speed(const Speed& from);

  inline Speed& operator=(const Speed& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Speed(Speed&& from) noexcept
    : Speed() {
    *this = ::std::move(from);
  }

  inline Speed& operator=(Speed&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Speed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Speed* internal_default_instance() {
    return reinterpret_cast<const Speed*>(
               &_Speed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Speed* other);
  friend void swap(Speed& a, Speed& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Speed* New() const final {
    return CreateMaybeMessage<Speed>(NULL);
  }

  Speed* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Speed>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Speed& from);
  void MergeFrom(const Speed& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Speed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // required .holo.map.adasisv3.UnitOfSpeed unit = 2;
  bool has_unit() const;
  void clear_unit();
  static const int kUnitFieldNumber = 2;
  ::holo::map::adasisv3::UnitOfSpeed unit() const;
  void set_unit(::holo::map::adasisv3::UnitOfSpeed value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.Speed)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_unit();
  void clear_has_unit();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 value_;
  int unit_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WGS84Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.WGS84Point) */ {
 public:
  WGS84Point();
  virtual ~WGS84Point();

  WGS84Point(const WGS84Point& from);

  inline WGS84Point& operator=(const WGS84Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WGS84Point(WGS84Point&& from) noexcept
    : WGS84Point() {
    *this = ::std::move(from);
  }

  inline WGS84Point& operator=(WGS84Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WGS84Point& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WGS84Point* internal_default_instance() {
    return reinterpret_cast<const WGS84Point*>(
               &_WGS84Point_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(WGS84Point* other);
  friend void swap(WGS84Point& a, WGS84Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WGS84Point* New() const final {
    return CreateMaybeMessage<WGS84Point>(NULL);
  }

  WGS84Point* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WGS84Point>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WGS84Point& from);
  void MergeFrom(const WGS84Point& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WGS84Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 latitude = 1;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  ::google::protobuf::int32 latitude() const;
  void set_latitude(::google::protobuf::int32 value);

  // required int32 longitude = 2;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  ::google::protobuf::int32 longitude() const;
  void set_longitude(::google::protobuf::int32 value);

  // required int32 altitude = 3;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  ::google::protobuf::int32 altitude() const;
  void set_altitude(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.WGS84Point)
 private:
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_altitude();
  void clear_has_altitude();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 longitude_;
  ::google::protobuf::int32 altitude_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class VehiclePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.VehiclePosition) */ {
 public:
  VehiclePosition();
  virtual ~VehiclePosition();

  VehiclePosition(const VehiclePosition& from);

  inline VehiclePosition& operator=(const VehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  VehiclePosition(VehiclePosition&& from) noexcept
    : VehiclePosition() {
    *this = ::std::move(from);
  }

  inline VehiclePosition& operator=(VehiclePosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VehiclePosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VehiclePosition* internal_default_instance() {
    return reinterpret_cast<const VehiclePosition*>(
               &_VehiclePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(VehiclePosition* other);
  friend void swap(VehiclePosition& a, VehiclePosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline VehiclePosition* New() const final {
    return CreateMaybeMessage<VehiclePosition>(NULL);
  }

  VehiclePosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<VehiclePosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const VehiclePosition& from);
  void MergeFrom(const VehiclePosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VehiclePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 latitude = 1;
  bool has_latitude() const;
  void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  ::google::protobuf::int32 latitude() const;
  void set_latitude(::google::protobuf::int32 value);

  // required int32 longitude = 2;
  bool has_longitude() const;
  void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  ::google::protobuf::int32 longitude() const;
  void set_longitude(::google::protobuf::int32 value);

  // required uint64 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // required int32 altitude = 3;
  bool has_altitude() const;
  void clear_altitude();
  static const int kAltitudeFieldNumber = 3;
  ::google::protobuf::int32 altitude() const;
  void set_altitude(::google::protobuf::int32 value);

  // required float heading = 5;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 5;
  float heading() const;
  void set_heading(float value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.VehiclePosition)
 private:
  void set_has_latitude();
  void clear_has_latitude();
  void set_has_longitude();
  void clear_has_longitude();
  void set_has_altitude();
  void clear_has_altitude();
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_heading();
  void clear_has_heading();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 latitude_;
  ::google::protobuf::int32 longitude_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::int32 altitude_;
  float heading_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.Position) */ {
 public:
  Position();
  virtual ~Position();

  Position(const Position& from);

  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Position(Position&& from) noexcept
    : Position() {
    *this = ::std::move(from);
  }

  inline Position& operator=(Position&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Position* internal_default_instance() {
    return reinterpret_cast<const Position*>(
               &_Position_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Position* other);
  friend void swap(Position& a, Position& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Position* New() const final {
    return CreateMaybeMessage<Position>(NULL);
  }

  Position* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Position>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Position* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pathId = 1;
  bool has_pathid() const;
  void clear_pathid();
  static const int kPathIdFieldNumber = 1;
  ::google::protobuf::uint32 pathid() const;
  void set_pathid(::google::protobuf::uint32 value);

  // required uint32 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // required uint32 accuracy = 3;
  bool has_accuracy() const;
  void clear_accuracy();
  static const int kAccuracyFieldNumber = 3;
  ::google::protobuf::uint32 accuracy() const;
  void set_accuracy(::google::protobuf::uint32 value);

  // required int32 deviation = 4;
  bool has_deviation() const;
  void clear_deviation();
  static const int kDeviationFieldNumber = 4;
  ::google::protobuf::int32 deviation() const;
  void set_deviation(::google::protobuf::int32 value);

  // required float speed = 5;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  float speed() const;
  void set_speed(float value);

  // required float relativeHeading = 6;
  bool has_relativeheading() const;
  void clear_relativeheading();
  static const int kRelativeHeadingFieldNumber = 6;
  float relativeheading() const;
  void set_relativeheading(float value);

  // required float probability = 7;
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 7;
  float probability() const;
  void set_probability(float value);

  // required uint32 currentLane = 8;
  bool has_currentlane() const;
  void clear_currentlane();
  static const int kCurrentLaneFieldNumber = 8;
  ::google::protobuf::uint32 currentlane() const;
  void set_currentlane(::google::protobuf::uint32 value);

  // required uint32 preferredPath = 9;
  bool has_preferredpath() const;
  void clear_preferredpath();
  static const int kPreferredPathFieldNumber = 9;
  ::google::protobuf::uint32 preferredpath() const;
  void set_preferredpath(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.Position)
 private:
  void set_has_pathid();
  void clear_has_pathid();
  void set_has_offset();
  void clear_has_offset();
  void set_has_accuracy();
  void clear_has_accuracy();
  void set_has_deviation();
  void clear_has_deviation();
  void set_has_speed();
  void clear_has_speed();
  void set_has_relativeheading();
  void clear_has_relativeheading();
  void set_has_probability();
  void clear_has_probability();
  void set_has_currentlane();
  void clear_has_currentlane();
  void set_has_preferredpath();
  void clear_has_preferredpath();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 pathid_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 accuracy_;
  ::google::protobuf::int32 deviation_;
  float speed_;
  float relativeheading_;
  float probability_;
  ::google::protobuf::uint32 currentlane_;
  ::google::protobuf::uint32 preferredpath_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AbsoluteVehiclePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.AbsoluteVehiclePosition) */ {
 public:
  AbsoluteVehiclePosition();
  virtual ~AbsoluteVehiclePosition();

  AbsoluteVehiclePosition(const AbsoluteVehiclePosition& from);

  inline AbsoluteVehiclePosition& operator=(const AbsoluteVehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AbsoluteVehiclePosition(AbsoluteVehiclePosition&& from) noexcept
    : AbsoluteVehiclePosition() {
    *this = ::std::move(from);
  }

  inline AbsoluteVehiclePosition& operator=(AbsoluteVehiclePosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AbsoluteVehiclePosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbsoluteVehiclePosition* internal_default_instance() {
    return reinterpret_cast<const AbsoluteVehiclePosition*>(
               &_AbsoluteVehiclePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AbsoluteVehiclePosition* other);
  friend void swap(AbsoluteVehiclePosition& a, AbsoluteVehiclePosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AbsoluteVehiclePosition* New() const final {
    return CreateMaybeMessage<AbsoluteVehiclePosition>(NULL);
  }

  AbsoluteVehiclePosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AbsoluteVehiclePosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AbsoluteVehiclePosition& from);
  void MergeFrom(const AbsoluteVehiclePosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbsoluteVehiclePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.WGS84Point vehiclePosition = 2;
  bool has_vehicleposition() const;
  void clear_vehicleposition();
  static const int kVehiclePositionFieldNumber = 2;
  private:
  const ::holo::map::adasisv3::WGS84Point& _internal_vehicleposition() const;
  public:
  const ::holo::map::adasisv3::WGS84Point& vehicleposition() const;
  ::holo::map::adasisv3::WGS84Point* release_vehicleposition();
  ::holo::map::adasisv3::WGS84Point* mutable_vehicleposition();
  void set_allocated_vehicleposition(::holo::map::adasisv3::WGS84Point* vehicleposition);

  // required float heading = 1;
  bool has_heading() const;
  void clear_heading();
  static const int kHeadingFieldNumber = 1;
  float heading() const;
  void set_heading(float value);

  // optional uint32 stdLateralPos = 3;
  bool has_stdlateralpos() const;
  void clear_stdlateralpos();
  static const int kStdLateralPosFieldNumber = 3;
  ::google::protobuf::uint32 stdlateralpos() const;
  void set_stdlateralpos(::google::protobuf::uint32 value);

  // optional uint32 stdLongitudinalPos = 4;
  bool has_stdlongitudinalpos() const;
  void clear_stdlongitudinalpos();
  static const int kStdLongitudinalPosFieldNumber = 4;
  ::google::protobuf::uint32 stdlongitudinalpos() const;
  void set_stdlongitudinalpos(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.AbsoluteVehiclePosition)
 private:
  void set_has_heading();
  void clear_has_heading();
  void set_has_vehicleposition();
  void clear_has_vehicleposition();
  void set_has_stdlateralpos();
  void clear_has_stdlateralpos();
  void set_has_stdlongitudinalpos();
  void clear_has_stdlongitudinalpos();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::map::adasisv3::WGS84Point* vehicleposition_;
  float heading_;
  ::google::protobuf::uint32 stdlateralpos_;
  ::google::protobuf::uint32 stdlongitudinalpos_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RelativePosition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.RelativePosition) */ {
 public:
  RelativePosition();
  virtual ~RelativePosition();

  RelativePosition(const RelativePosition& from);

  inline RelativePosition& operator=(const RelativePosition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RelativePosition(RelativePosition&& from) noexcept
    : RelativePosition() {
    *this = ::std::move(from);
  }

  inline RelativePosition& operator=(RelativePosition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RelativePosition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RelativePosition* internal_default_instance() {
    return reinterpret_cast<const RelativePosition*>(
               &_RelativePosition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RelativePosition* other);
  friend void swap(RelativePosition& a, RelativePosition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RelativePosition* New() const final {
    return CreateMaybeMessage<RelativePosition>(NULL);
  }

  RelativePosition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RelativePosition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RelativePosition& from);
  void MergeFrom(const RelativePosition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RelativePosition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float locLaneSequenceConfidence = 1;
  bool has_loclanesequenceconfidence() const;
  void clear_loclanesequenceconfidence();
  static const int kLocLaneSequenceConfidenceFieldNumber = 1;
  float loclanesequenceconfidence() const;
  void set_loclanesequenceconfidence(float value);

  // optional uint32 lateralOffsetLeft = 2;
  bool has_lateraloffsetleft() const;
  void clear_lateraloffsetleft();
  static const int kLateralOffsetLeftFieldNumber = 2;
  ::google::protobuf::uint32 lateraloffsetleft() const;
  void set_lateraloffsetleft(::google::protobuf::uint32 value);

  // optional uint32 lateralOffsetRight = 3;
  bool has_lateraloffsetright() const;
  void clear_lateraloffsetright();
  static const int kLateralOffsetRightFieldNumber = 3;
  ::google::protobuf::uint32 lateraloffsetright() const;
  void set_lateraloffsetright(::google::protobuf::uint32 value);

  // optional float locLeftBoundaryHeading = 4;
  bool has_locleftboundaryheading() const;
  void clear_locleftboundaryheading();
  static const int kLocLeftBoundaryHeadingFieldNumber = 4;
  float locleftboundaryheading() const;
  void set_locleftboundaryheading(float value);

  // optional float locRightBoundaryHeading = 5;
  bool has_locrightboundaryheading() const;
  void clear_locrightboundaryheading();
  static const int kLocRightBoundaryHeadingFieldNumber = 5;
  float locrightboundaryheading() const;
  void set_locrightboundaryheading(float value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.RelativePosition)
 private:
  void set_has_loclanesequenceconfidence();
  void clear_has_loclanesequenceconfidence();
  void set_has_lateraloffsetleft();
  void clear_has_lateraloffsetleft();
  void set_has_lateraloffsetright();
  void clear_has_lateraloffsetright();
  void set_has_locleftboundaryheading();
  void clear_has_locleftboundaryheading();
  void set_has_locrightboundaryheading();
  void clear_has_locrightboundaryheading();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float loclanesequenceconfidence_;
  ::google::protobuf::uint32 lateraloffsetleft_;
  ::google::protobuf::uint32 lateraloffsetright_;
  float locleftboundaryheading_;
  float locrightboundaryheading_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PositionMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.PositionMessage) */ {
 public:
  PositionMessage();
  virtual ~PositionMessage();

  PositionMessage(const PositionMessage& from);

  inline PositionMessage& operator=(const PositionMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PositionMessage(PositionMessage&& from) noexcept
    : PositionMessage() {
    *this = ::std::move(from);
  }

  inline PositionMessage& operator=(PositionMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PositionMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PositionMessage* internal_default_instance() {
    return reinterpret_cast<const PositionMessage*>(
               &_PositionMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(PositionMessage* other);
  friend void swap(PositionMessage& a, PositionMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PositionMessage* New() const final {
    return CreateMaybeMessage<PositionMessage>(NULL);
  }

  PositionMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PositionMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PositionMessage& from);
  void MergeFrom(const PositionMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PositionMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.Position positions = 3;
  int positions_size() const;
  void clear_positions();
  static const int kPositionsFieldNumber = 3;
  ::holo::map::adasisv3::Position* mutable_positions(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Position >*
      mutable_positions();
  const ::holo::map::adasisv3::Position& positions(int index) const;
  ::holo::map::adasisv3::Position* add_positions();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Position >&
      positions() const;

  // optional .holo.map.adasisv3.AbsoluteVehiclePosition absoluteVehiclePosition = 4;
  bool has_absolutevehicleposition() const;
  void clear_absolutevehicleposition();
  static const int kAbsoluteVehiclePositionFieldNumber = 4;
  private:
  const ::holo::map::adasisv3::AbsoluteVehiclePosition& _internal_absolutevehicleposition() const;
  public:
  const ::holo::map::adasisv3::AbsoluteVehiclePosition& absolutevehicleposition() const;
  ::holo::map::adasisv3::AbsoluteVehiclePosition* release_absolutevehicleposition();
  ::holo::map::adasisv3::AbsoluteVehiclePosition* mutable_absolutevehicleposition();
  void set_allocated_absolutevehicleposition(::holo::map::adasisv3::AbsoluteVehiclePosition* absolutevehicleposition);

  // optional .holo.map.adasisv3.RelativePosition relativePosition = 5;
  bool has_relativeposition() const;
  void clear_relativeposition();
  static const int kRelativePositionFieldNumber = 5;
  private:
  const ::holo::map::adasisv3::RelativePosition& _internal_relativeposition() const;
  public:
  const ::holo::map::adasisv3::RelativePosition& relativeposition() const;
  ::holo::map::adasisv3::RelativePosition* release_relativeposition();
  ::holo::map::adasisv3::RelativePosition* mutable_relativeposition();
  void set_allocated_relativeposition(::holo::map::adasisv3::RelativePosition* relativeposition);

  // required uint64 timestamp = 1;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // required uint64 positionAge = 2;
  bool has_positionage() const;
  void clear_positionage();
  static const int kPositionAgeFieldNumber = 2;
  ::google::protobuf::uint64 positionage() const;
  void set_positionage(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.PositionMessage)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();
  void set_has_positionage();
  void clear_has_positionage();
  void set_has_absolutevehicleposition();
  void clear_has_absolutevehicleposition();
  void set_has_relativeposition();
  void clear_has_relativeposition();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Position > positions_;
  ::holo::map::adasisv3::AbsoluteVehiclePosition* absolutevehicleposition_;
  ::holo::map::adasisv3::RelativePosition* relativeposition_;
  ::google::protobuf::uint64 timestamp_;
  ::google::protobuf::uint64 positionage_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProfileEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ProfileEntry) */ {
 public:
  ProfileEntry();
  virtual ~ProfileEntry();

  ProfileEntry(const ProfileEntry& from);

  inline ProfileEntry& operator=(const ProfileEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProfileEntry(ProfileEntry&& from) noexcept
    : ProfileEntry() {
    *this = ::std::move(from);
  }

  inline ProfileEntry& operator=(ProfileEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfileEntry& default_instance();

  enum ValueCase {
    kUInt32ProfileValueValue = 13,
    kInt32ProfileValueValue = 14,
    kUInt64ProfileValueValue = 15,
    kFloatProfileValueValue = 16,
    kBooleanProfileValueValue = 17,
    kYesNoUnknownProfileValueValue = 18,
    kFormOfWayProfileValueValue = 19,
    kDrivingSideProfileValueValue = 20,
    kUnitSystemProfileValueValue = 21,
    kSpecialSituationProfileValueValue = 22,
    kRoadConditionProfileValueValue = 23,
    kWeatherProfileValueValue = 24,
    kMapProviderProfileValueValue = 25,
    kMapStatusProfileValueValue = 26,
    kOffsetFloatProfileValueValue = 27,
    kNodeProfileValueValue = 28,
    kSystemStatusProfileValueValue = 29,
    kAbsoluteVehiclePositionProfileValueValue = 30,
    kSurfaceConditionProfileValueValue = 31,
    kSpeedProfileValueValue = 32,
    kLaneModelValueValue = 33,
    kLaneConnectivityValueValue = 34,
    kLinearObjectDefinitionValueValue = 35,
    kLanesGeometryProfileValueValue = 36,
    kRoadGeometryProfileValueValue = 37,
    kTrafficLightProfileValueValue = 38,
    kEffectiveSpeedLimitValue = 39,
    kLocationObjectValue = 40,
    kRegionCodeValueValue = 41,
    kExtendedSpeedLimitValueValue = 42,
    kTrafficSignValueValue = 43,
    kConditionalRestrictionProfileValueValue = 44,
    kRoadSurfaceProfileValueValue = 45,
    kPoleProfileValueValue = 46,
    kTrafficFlowProfileValueValue = 47,
    kTrafficEventProfileValueValue = 48,
    kStaticODDProfileValueValue = 49,
    kStaticNotODDProfileValueValue = 50,
    kDecelerationzoneProfileValueValue = 51,
    kOverHeadProfileValueValue = 52,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProfileEntry* internal_default_instance() {
    return reinterpret_cast<const ProfileEntry*>(
               &_ProfileEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ProfileEntry* other);
  friend void swap(ProfileEntry& a, ProfileEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProfileEntry* New() const final {
    return CreateMaybeMessage<ProfileEntry>(NULL);
  }

  ProfileEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProfileEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProfileEntry& from);
  void MergeFrom(const ProfileEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 laneNumbers = 6;
  int lanenumbers_size() const;
  void clear_lanenumbers();
  static const int kLaneNumbersFieldNumber = 6;
  ::google::protobuf::uint32 lanenumbers(int index) const;
  void set_lanenumbers(int index, ::google::protobuf::uint32 value);
  void add_lanenumbers(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      lanenumbers() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_lanenumbers();

  // optional uint32 instanceId = 1;
  bool has_instanceid() const;
  void clear_instanceid();
  static const int kInstanceIdFieldNumber = 1;
  ::google::protobuf::uint32 instanceid() const;
  void set_instanceid(::google::protobuf::uint32 value);

  // required .holo.map.adasisv3.ChangeMode change = 3;
  bool has_change() const;
  void clear_change();
  static const int kChangeFieldNumber = 3;
  ::holo::map::adasisv3::ChangeMode change() const;
  void set_change(::holo::map::adasisv3::ChangeMode value);

  // required float confidence = 4;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 4;
  float confidence() const;
  void set_confidence(float value);

  // required uint32 pathId = 5;
  bool has_pathid() const;
  void clear_pathid();
  static const int kPathIdFieldNumber = 5;
  ::google::protobuf::uint32 pathid() const;
  void set_pathid(::google::protobuf::uint32 value);

  // required bool isRetransmission = 2;
  bool has_isretransmission() const;
  void clear_isretransmission();
  static const int kIsRetransmissionFieldNumber = 2;
  bool isretransmission() const;
  void set_isretransmission(bool value);

  // required bool endOffsetFinal = 10;
  bool has_endoffsetfinal() const;
  void clear_endoffsetfinal();
  static const int kEndOffsetFinalFieldNumber = 10;
  bool endoffsetfinal() const;
  void set_endoffsetfinal(bool value);

  // optional .holo.map.adasisv3.RelativeDirection direction = 7;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 7;
  ::holo::map::adasisv3::RelativeDirection direction() const;
  void set_direction(::holo::map::adasisv3::RelativeDirection value);

  // required uint32 offset = 8;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 8;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // required uint32 endOffset = 9;
  bool has_endoffset() const;
  void clear_endoffset();
  static const int kEndOffsetFieldNumber = 9;
  ::google::protobuf::uint32 endoffset() const;
  void set_endoffset(::google::protobuf::uint32 value);

  // required .holo.map.adasisv3.ProfileType type = 11;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 11;
  ::holo::map::adasisv3::ProfileType type() const;
  void set_type(::holo::map::adasisv3::ProfileType value);

  // required .holo.map.adasisv3.Availability available = 12;
  bool has_available() const;
  void clear_available();
  static const int kAvailableFieldNumber = 12;
  ::holo::map::adasisv3::Availability available() const;
  void set_available(::holo::map::adasisv3::Availability value);

  // optional .holo.map.adasisv3.UInt32ProfileValue UInt32ProfileValue_value = 13;
  bool has_uint32profilevalue_value() const;
  void clear_uint32profilevalue_value();
  static const int kUInt32ProfileValueValueFieldNumber = 13;
  private:
  const ::holo::map::adasisv3::UInt32ProfileValue& _internal_uint32profilevalue_value() const;
  public:
  const ::holo::map::adasisv3::UInt32ProfileValue& uint32profilevalue_value() const;
  ::holo::map::adasisv3::UInt32ProfileValue* release_uint32profilevalue_value();
  ::holo::map::adasisv3::UInt32ProfileValue* mutable_uint32profilevalue_value();
  void set_allocated_uint32profilevalue_value(::holo::map::adasisv3::UInt32ProfileValue* uint32profilevalue_value);

  // optional .holo.map.adasisv3.Int32ProfileValue Int32ProfileValue_value = 14;
  bool has_int32profilevalue_value() const;
  void clear_int32profilevalue_value();
  static const int kInt32ProfileValueValueFieldNumber = 14;
  private:
  const ::holo::map::adasisv3::Int32ProfileValue& _internal_int32profilevalue_value() const;
  public:
  const ::holo::map::adasisv3::Int32ProfileValue& int32profilevalue_value() const;
  ::holo::map::adasisv3::Int32ProfileValue* release_int32profilevalue_value();
  ::holo::map::adasisv3::Int32ProfileValue* mutable_int32profilevalue_value();
  void set_allocated_int32profilevalue_value(::holo::map::adasisv3::Int32ProfileValue* int32profilevalue_value);

  // optional .holo.map.adasisv3.UInt64ProfileValue UInt64ProfileValue_value = 15;
  bool has_uint64profilevalue_value() const;
  void clear_uint64profilevalue_value();
  static const int kUInt64ProfileValueValueFieldNumber = 15;
  private:
  const ::holo::map::adasisv3::UInt64ProfileValue& _internal_uint64profilevalue_value() const;
  public:
  const ::holo::map::adasisv3::UInt64ProfileValue& uint64profilevalue_value() const;
  ::holo::map::adasisv3::UInt64ProfileValue* release_uint64profilevalue_value();
  ::holo::map::adasisv3::UInt64ProfileValue* mutable_uint64profilevalue_value();
  void set_allocated_uint64profilevalue_value(::holo::map::adasisv3::UInt64ProfileValue* uint64profilevalue_value);

  // optional .holo.map.adasisv3.FloatProfileValue FloatProfileValue_value = 16;
  bool has_floatprofilevalue_value() const;
  void clear_floatprofilevalue_value();
  static const int kFloatProfileValueValueFieldNumber = 16;
  private:
  const ::holo::map::adasisv3::FloatProfileValue& _internal_floatprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::FloatProfileValue& floatprofilevalue_value() const;
  ::holo::map::adasisv3::FloatProfileValue* release_floatprofilevalue_value();
  ::holo::map::adasisv3::FloatProfileValue* mutable_floatprofilevalue_value();
  void set_allocated_floatprofilevalue_value(::holo::map::adasisv3::FloatProfileValue* floatprofilevalue_value);

  // optional .holo.map.adasisv3.BooleanProfileValue BooleanProfileValue_value = 17;
  bool has_booleanprofilevalue_value() const;
  void clear_booleanprofilevalue_value();
  static const int kBooleanProfileValueValueFieldNumber = 17;
  private:
  const ::holo::map::adasisv3::BooleanProfileValue& _internal_booleanprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::BooleanProfileValue& booleanprofilevalue_value() const;
  ::holo::map::adasisv3::BooleanProfileValue* release_booleanprofilevalue_value();
  ::holo::map::adasisv3::BooleanProfileValue* mutable_booleanprofilevalue_value();
  void set_allocated_booleanprofilevalue_value(::holo::map::adasisv3::BooleanProfileValue* booleanprofilevalue_value);

  // optional .holo.map.adasisv3.YesNoUnknownProfileValue YesNoUnknownProfileValue_value = 18;
  bool has_yesnounknownprofilevalue_value() const;
  void clear_yesnounknownprofilevalue_value();
  static const int kYesNoUnknownProfileValueValueFieldNumber = 18;
  private:
  const ::holo::map::adasisv3::YesNoUnknownProfileValue& _internal_yesnounknownprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::YesNoUnknownProfileValue& yesnounknownprofilevalue_value() const;
  ::holo::map::adasisv3::YesNoUnknownProfileValue* release_yesnounknownprofilevalue_value();
  ::holo::map::adasisv3::YesNoUnknownProfileValue* mutable_yesnounknownprofilevalue_value();
  void set_allocated_yesnounknownprofilevalue_value(::holo::map::adasisv3::YesNoUnknownProfileValue* yesnounknownprofilevalue_value);

  // optional .holo.map.adasisv3.FormOfWayProfileValue FormOfWayProfileValue_value = 19;
  bool has_formofwayprofilevalue_value() const;
  void clear_formofwayprofilevalue_value();
  static const int kFormOfWayProfileValueValueFieldNumber = 19;
  private:
  const ::holo::map::adasisv3::FormOfWayProfileValue& _internal_formofwayprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::FormOfWayProfileValue& formofwayprofilevalue_value() const;
  ::holo::map::adasisv3::FormOfWayProfileValue* release_formofwayprofilevalue_value();
  ::holo::map::adasisv3::FormOfWayProfileValue* mutable_formofwayprofilevalue_value();
  void set_allocated_formofwayprofilevalue_value(::holo::map::adasisv3::FormOfWayProfileValue* formofwayprofilevalue_value);

  // optional .holo.map.adasisv3.DrivingSideProfileValue DrivingSideProfileValue_value = 20;
  bool has_drivingsideprofilevalue_value() const;
  void clear_drivingsideprofilevalue_value();
  static const int kDrivingSideProfileValueValueFieldNumber = 20;
  private:
  const ::holo::map::adasisv3::DrivingSideProfileValue& _internal_drivingsideprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::DrivingSideProfileValue& drivingsideprofilevalue_value() const;
  ::holo::map::adasisv3::DrivingSideProfileValue* release_drivingsideprofilevalue_value();
  ::holo::map::adasisv3::DrivingSideProfileValue* mutable_drivingsideprofilevalue_value();
  void set_allocated_drivingsideprofilevalue_value(::holo::map::adasisv3::DrivingSideProfileValue* drivingsideprofilevalue_value);

  // optional .holo.map.adasisv3.UnitSystemProfileValue UnitSystemProfileValue_value = 21;
  bool has_unitsystemprofilevalue_value() const;
  void clear_unitsystemprofilevalue_value();
  static const int kUnitSystemProfileValueValueFieldNumber = 21;
  private:
  const ::holo::map::adasisv3::UnitSystemProfileValue& _internal_unitsystemprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::UnitSystemProfileValue& unitsystemprofilevalue_value() const;
  ::holo::map::adasisv3::UnitSystemProfileValue* release_unitsystemprofilevalue_value();
  ::holo::map::adasisv3::UnitSystemProfileValue* mutable_unitsystemprofilevalue_value();
  void set_allocated_unitsystemprofilevalue_value(::holo::map::adasisv3::UnitSystemProfileValue* unitsystemprofilevalue_value);

  // optional .holo.map.adasisv3.SpecialSituationProfileValue SpecialSituationProfileValue_value = 22;
  bool has_specialsituationprofilevalue_value() const;
  void clear_specialsituationprofilevalue_value();
  static const int kSpecialSituationProfileValueValueFieldNumber = 22;
  private:
  const ::holo::map::adasisv3::SpecialSituationProfileValue& _internal_specialsituationprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::SpecialSituationProfileValue& specialsituationprofilevalue_value() const;
  ::holo::map::adasisv3::SpecialSituationProfileValue* release_specialsituationprofilevalue_value();
  ::holo::map::adasisv3::SpecialSituationProfileValue* mutable_specialsituationprofilevalue_value();
  void set_allocated_specialsituationprofilevalue_value(::holo::map::adasisv3::SpecialSituationProfileValue* specialsituationprofilevalue_value);

  // optional .holo.map.adasisv3.RoadConditionProfileValue RoadConditionProfileValue_value = 23;
  bool has_roadconditionprofilevalue_value() const;
  void clear_roadconditionprofilevalue_value();
  static const int kRoadConditionProfileValueValueFieldNumber = 23;
  private:
  const ::holo::map::adasisv3::RoadConditionProfileValue& _internal_roadconditionprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::RoadConditionProfileValue& roadconditionprofilevalue_value() const;
  ::holo::map::adasisv3::RoadConditionProfileValue* release_roadconditionprofilevalue_value();
  ::holo::map::adasisv3::RoadConditionProfileValue* mutable_roadconditionprofilevalue_value();
  void set_allocated_roadconditionprofilevalue_value(::holo::map::adasisv3::RoadConditionProfileValue* roadconditionprofilevalue_value);

  // optional .holo.map.adasisv3.WeatherProfileValue WeatherProfileValue_value = 24;
  bool has_weatherprofilevalue_value() const;
  void clear_weatherprofilevalue_value();
  static const int kWeatherProfileValueValueFieldNumber = 24;
  private:
  const ::holo::map::adasisv3::WeatherProfileValue& _internal_weatherprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::WeatherProfileValue& weatherprofilevalue_value() const;
  ::holo::map::adasisv3::WeatherProfileValue* release_weatherprofilevalue_value();
  ::holo::map::adasisv3::WeatherProfileValue* mutable_weatherprofilevalue_value();
  void set_allocated_weatherprofilevalue_value(::holo::map::adasisv3::WeatherProfileValue* weatherprofilevalue_value);

  // optional .holo.map.adasisv3.MapProviderProfileValue MapProviderProfileValue_value = 25;
  bool has_mapproviderprofilevalue_value() const;
  void clear_mapproviderprofilevalue_value();
  static const int kMapProviderProfileValueValueFieldNumber = 25;
  private:
  const ::holo::map::adasisv3::MapProviderProfileValue& _internal_mapproviderprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::MapProviderProfileValue& mapproviderprofilevalue_value() const;
  ::holo::map::adasisv3::MapProviderProfileValue* release_mapproviderprofilevalue_value();
  ::holo::map::adasisv3::MapProviderProfileValue* mutable_mapproviderprofilevalue_value();
  void set_allocated_mapproviderprofilevalue_value(::holo::map::adasisv3::MapProviderProfileValue* mapproviderprofilevalue_value);

  // optional .holo.map.adasisv3.MapStatusProfileValue MapStatusProfileValue_value = 26;
  bool has_mapstatusprofilevalue_value() const;
  void clear_mapstatusprofilevalue_value();
  static const int kMapStatusProfileValueValueFieldNumber = 26;
  private:
  const ::holo::map::adasisv3::MapStatusProfileValue& _internal_mapstatusprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::MapStatusProfileValue& mapstatusprofilevalue_value() const;
  ::holo::map::adasisv3::MapStatusProfileValue* release_mapstatusprofilevalue_value();
  ::holo::map::adasisv3::MapStatusProfileValue* mutable_mapstatusprofilevalue_value();
  void set_allocated_mapstatusprofilevalue_value(::holo::map::adasisv3::MapStatusProfileValue* mapstatusprofilevalue_value);

  // optional .holo.map.adasisv3.OffsetFloatProfileValue OffsetFloatProfileValue_value = 27;
  bool has_offsetfloatprofilevalue_value() const;
  void clear_offsetfloatprofilevalue_value();
  static const int kOffsetFloatProfileValueValueFieldNumber = 27;
  private:
  const ::holo::map::adasisv3::OffsetFloatProfileValue& _internal_offsetfloatprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::OffsetFloatProfileValue& offsetfloatprofilevalue_value() const;
  ::holo::map::adasisv3::OffsetFloatProfileValue* release_offsetfloatprofilevalue_value();
  ::holo::map::adasisv3::OffsetFloatProfileValue* mutable_offsetfloatprofilevalue_value();
  void set_allocated_offsetfloatprofilevalue_value(::holo::map::adasisv3::OffsetFloatProfileValue* offsetfloatprofilevalue_value);

  // optional .holo.map.adasisv3.NodeProfileValue NodeProfileValue_value = 28;
  bool has_nodeprofilevalue_value() const;
  void clear_nodeprofilevalue_value();
  static const int kNodeProfileValueValueFieldNumber = 28;
  private:
  const ::holo::map::adasisv3::NodeProfileValue& _internal_nodeprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::NodeProfileValue& nodeprofilevalue_value() const;
  ::holo::map::adasisv3::NodeProfileValue* release_nodeprofilevalue_value();
  ::holo::map::adasisv3::NodeProfileValue* mutable_nodeprofilevalue_value();
  void set_allocated_nodeprofilevalue_value(::holo::map::adasisv3::NodeProfileValue* nodeprofilevalue_value);

  // optional .holo.map.adasisv3.SystemStatusProfileValue SystemStatusProfileValue_value = 29;
  bool has_systemstatusprofilevalue_value() const;
  void clear_systemstatusprofilevalue_value();
  static const int kSystemStatusProfileValueValueFieldNumber = 29;
  private:
  const ::holo::map::adasisv3::SystemStatusProfileValue& _internal_systemstatusprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::SystemStatusProfileValue& systemstatusprofilevalue_value() const;
  ::holo::map::adasisv3::SystemStatusProfileValue* release_systemstatusprofilevalue_value();
  ::holo::map::adasisv3::SystemStatusProfileValue* mutable_systemstatusprofilevalue_value();
  void set_allocated_systemstatusprofilevalue_value(::holo::map::adasisv3::SystemStatusProfileValue* systemstatusprofilevalue_value);

  // optional .holo.map.adasisv3.AbsoluteVehiclePositionProfileValue AbsoluteVehiclePositionProfileValue_value = 30;
  bool has_absolutevehiclepositionprofilevalue_value() const;
  void clear_absolutevehiclepositionprofilevalue_value();
  static const int kAbsoluteVehiclePositionProfileValueValueFieldNumber = 30;
  private:
  const ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue& _internal_absolutevehiclepositionprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue& absolutevehiclepositionprofilevalue_value() const;
  ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* release_absolutevehiclepositionprofilevalue_value();
  ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* mutable_absolutevehiclepositionprofilevalue_value();
  void set_allocated_absolutevehiclepositionprofilevalue_value(::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* absolutevehiclepositionprofilevalue_value);

  // optional .holo.map.adasisv3.SurfaceConditionProfileValue SurfaceConditionProfileValue_value = 31;
  bool has_surfaceconditionprofilevalue_value() const;
  void clear_surfaceconditionprofilevalue_value();
  static const int kSurfaceConditionProfileValueValueFieldNumber = 31;
  private:
  const ::holo::map::adasisv3::SurfaceConditionProfileValue& _internal_surfaceconditionprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::SurfaceConditionProfileValue& surfaceconditionprofilevalue_value() const;
  ::holo::map::adasisv3::SurfaceConditionProfileValue* release_surfaceconditionprofilevalue_value();
  ::holo::map::adasisv3::SurfaceConditionProfileValue* mutable_surfaceconditionprofilevalue_value();
  void set_allocated_surfaceconditionprofilevalue_value(::holo::map::adasisv3::SurfaceConditionProfileValue* surfaceconditionprofilevalue_value);

  // optional .holo.map.adasisv3.SpeedProfileValue SpeedProfileValue_value = 32;
  bool has_speedprofilevalue_value() const;
  void clear_speedprofilevalue_value();
  static const int kSpeedProfileValueValueFieldNumber = 32;
  private:
  const ::holo::map::adasisv3::SpeedProfileValue& _internal_speedprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::SpeedProfileValue& speedprofilevalue_value() const;
  ::holo::map::adasisv3::SpeedProfileValue* release_speedprofilevalue_value();
  ::holo::map::adasisv3::SpeedProfileValue* mutable_speedprofilevalue_value();
  void set_allocated_speedprofilevalue_value(::holo::map::adasisv3::SpeedProfileValue* speedprofilevalue_value);

  // optional .holo.map.adasisv3.LaneModelValue LaneModelValue_value = 33;
  bool has_lanemodelvalue_value() const;
  void clear_lanemodelvalue_value();
  static const int kLaneModelValueValueFieldNumber = 33;
  private:
  const ::holo::map::adasisv3::LaneModelValue& _internal_lanemodelvalue_value() const;
  public:
  const ::holo::map::adasisv3::LaneModelValue& lanemodelvalue_value() const;
  ::holo::map::adasisv3::LaneModelValue* release_lanemodelvalue_value();
  ::holo::map::adasisv3::LaneModelValue* mutable_lanemodelvalue_value();
  void set_allocated_lanemodelvalue_value(::holo::map::adasisv3::LaneModelValue* lanemodelvalue_value);

  // optional .holo.map.adasisv3.LaneConnectivityValue LaneConnectivityValue_value = 34;
  bool has_laneconnectivityvalue_value() const;
  void clear_laneconnectivityvalue_value();
  static const int kLaneConnectivityValueValueFieldNumber = 34;
  private:
  const ::holo::map::adasisv3::LaneConnectivityValue& _internal_laneconnectivityvalue_value() const;
  public:
  const ::holo::map::adasisv3::LaneConnectivityValue& laneconnectivityvalue_value() const;
  ::holo::map::adasisv3::LaneConnectivityValue* release_laneconnectivityvalue_value();
  ::holo::map::adasisv3::LaneConnectivityValue* mutable_laneconnectivityvalue_value();
  void set_allocated_laneconnectivityvalue_value(::holo::map::adasisv3::LaneConnectivityValue* laneconnectivityvalue_value);

  // optional .holo.map.adasisv3.LinearObjectDefinitionValue LinearObjectDefinitionValue_value = 35;
  bool has_linearobjectdefinitionvalue_value() const;
  void clear_linearobjectdefinitionvalue_value();
  static const int kLinearObjectDefinitionValueValueFieldNumber = 35;
  private:
  const ::holo::map::adasisv3::LinearObjectDefinitionValue& _internal_linearobjectdefinitionvalue_value() const;
  public:
  const ::holo::map::adasisv3::LinearObjectDefinitionValue& linearobjectdefinitionvalue_value() const;
  ::holo::map::adasisv3::LinearObjectDefinitionValue* release_linearobjectdefinitionvalue_value();
  ::holo::map::adasisv3::LinearObjectDefinitionValue* mutable_linearobjectdefinitionvalue_value();
  void set_allocated_linearobjectdefinitionvalue_value(::holo::map::adasisv3::LinearObjectDefinitionValue* linearobjectdefinitionvalue_value);

  // optional .holo.map.adasisv3.LanesGeometryProfileValue LanesGeometryProfileValue_value = 36;
  bool has_lanesgeometryprofilevalue_value() const;
  void clear_lanesgeometryprofilevalue_value();
  static const int kLanesGeometryProfileValueValueFieldNumber = 36;
  private:
  const ::holo::map::adasisv3::LanesGeometryProfileValue& _internal_lanesgeometryprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::LanesGeometryProfileValue& lanesgeometryprofilevalue_value() const;
  ::holo::map::adasisv3::LanesGeometryProfileValue* release_lanesgeometryprofilevalue_value();
  ::holo::map::adasisv3::LanesGeometryProfileValue* mutable_lanesgeometryprofilevalue_value();
  void set_allocated_lanesgeometryprofilevalue_value(::holo::map::adasisv3::LanesGeometryProfileValue* lanesgeometryprofilevalue_value);

  // optional .holo.map.adasisv3.RoadGeometryProfileValue RoadGeometryProfileValue_value = 37;
  bool has_roadgeometryprofilevalue_value() const;
  void clear_roadgeometryprofilevalue_value();
  static const int kRoadGeometryProfileValueValueFieldNumber = 37;
  private:
  const ::holo::map::adasisv3::RoadGeometryProfileValue& _internal_roadgeometryprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::RoadGeometryProfileValue& roadgeometryprofilevalue_value() const;
  ::holo::map::adasisv3::RoadGeometryProfileValue* release_roadgeometryprofilevalue_value();
  ::holo::map::adasisv3::RoadGeometryProfileValue* mutable_roadgeometryprofilevalue_value();
  void set_allocated_roadgeometryprofilevalue_value(::holo::map::adasisv3::RoadGeometryProfileValue* roadgeometryprofilevalue_value);

  // optional .holo.map.adasisv3.TrafficLightProfileValue TrafficLightProfileValue_value = 38;
  bool has_trafficlightprofilevalue_value() const;
  void clear_trafficlightprofilevalue_value();
  static const int kTrafficLightProfileValueValueFieldNumber = 38;
  private:
  const ::holo::map::adasisv3::TrafficLightProfileValue& _internal_trafficlightprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::TrafficLightProfileValue& trafficlightprofilevalue_value() const;
  ::holo::map::adasisv3::TrafficLightProfileValue* release_trafficlightprofilevalue_value();
  ::holo::map::adasisv3::TrafficLightProfileValue* mutable_trafficlightprofilevalue_value();
  void set_allocated_trafficlightprofilevalue_value(::holo::map::adasisv3::TrafficLightProfileValue* trafficlightprofilevalue_value);

  // optional .holo.map.adasisv3.EffectiveSpeedLimit EffectiveSpeedLimit_value = 39;
  bool has_effectivespeedlimit_value() const;
  void clear_effectivespeedlimit_value();
  static const int kEffectiveSpeedLimitValueFieldNumber = 39;
  private:
  const ::holo::map::adasisv3::EffectiveSpeedLimit& _internal_effectivespeedlimit_value() const;
  public:
  const ::holo::map::adasisv3::EffectiveSpeedLimit& effectivespeedlimit_value() const;
  ::holo::map::adasisv3::EffectiveSpeedLimit* release_effectivespeedlimit_value();
  ::holo::map::adasisv3::EffectiveSpeedLimit* mutable_effectivespeedlimit_value();
  void set_allocated_effectivespeedlimit_value(::holo::map::adasisv3::EffectiveSpeedLimit* effectivespeedlimit_value);

  // optional .holo.map.adasisv3.LocationObject LocationObject_value = 40;
  bool has_locationobject_value() const;
  void clear_locationobject_value();
  static const int kLocationObjectValueFieldNumber = 40;
  private:
  const ::holo::map::adasisv3::LocationObject& _internal_locationobject_value() const;
  public:
  const ::holo::map::adasisv3::LocationObject& locationobject_value() const;
  ::holo::map::adasisv3::LocationObject* release_locationobject_value();
  ::holo::map::adasisv3::LocationObject* mutable_locationobject_value();
  void set_allocated_locationobject_value(::holo::map::adasisv3::LocationObject* locationobject_value);

  // optional .holo.map.adasisv3.RegionCodeValue RegionCodeValue_value = 41;
  bool has_regioncodevalue_value() const;
  void clear_regioncodevalue_value();
  static const int kRegionCodeValueValueFieldNumber = 41;
  private:
  const ::holo::map::adasisv3::RegionCodeValue& _internal_regioncodevalue_value() const;
  public:
  const ::holo::map::adasisv3::RegionCodeValue& regioncodevalue_value() const;
  ::holo::map::adasisv3::RegionCodeValue* release_regioncodevalue_value();
  ::holo::map::adasisv3::RegionCodeValue* mutable_regioncodevalue_value();
  void set_allocated_regioncodevalue_value(::holo::map::adasisv3::RegionCodeValue* regioncodevalue_value);

  // optional .holo.map.adasisv3.ExtendedSpeedLimitValue ExtendedSpeedLimitValue_value = 42;
  bool has_extendedspeedlimitvalue_value() const;
  void clear_extendedspeedlimitvalue_value();
  static const int kExtendedSpeedLimitValueValueFieldNumber = 42;
  private:
  const ::holo::map::adasisv3::ExtendedSpeedLimitValue& _internal_extendedspeedlimitvalue_value() const;
  public:
  const ::holo::map::adasisv3::ExtendedSpeedLimitValue& extendedspeedlimitvalue_value() const;
  ::holo::map::adasisv3::ExtendedSpeedLimitValue* release_extendedspeedlimitvalue_value();
  ::holo::map::adasisv3::ExtendedSpeedLimitValue* mutable_extendedspeedlimitvalue_value();
  void set_allocated_extendedspeedlimitvalue_value(::holo::map::adasisv3::ExtendedSpeedLimitValue* extendedspeedlimitvalue_value);

  // optional .holo.map.adasisv3.TrafficSignValue TrafficSignValue_value = 43;
  bool has_trafficsignvalue_value() const;
  void clear_trafficsignvalue_value();
  static const int kTrafficSignValueValueFieldNumber = 43;
  private:
  const ::holo::map::adasisv3::TrafficSignValue& _internal_trafficsignvalue_value() const;
  public:
  const ::holo::map::adasisv3::TrafficSignValue& trafficsignvalue_value() const;
  ::holo::map::adasisv3::TrafficSignValue* release_trafficsignvalue_value();
  ::holo::map::adasisv3::TrafficSignValue* mutable_trafficsignvalue_value();
  void set_allocated_trafficsignvalue_value(::holo::map::adasisv3::TrafficSignValue* trafficsignvalue_value);

  // optional .holo.map.adasisv3.ConditionalRestrictionProfileValue ConditionalRestrictionProfileValue_value = 44;
  bool has_conditionalrestrictionprofilevalue_value() const;
  void clear_conditionalrestrictionprofilevalue_value();
  static const int kConditionalRestrictionProfileValueValueFieldNumber = 44;
  private:
  const ::holo::map::adasisv3::ConditionalRestrictionProfileValue& _internal_conditionalrestrictionprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::ConditionalRestrictionProfileValue& conditionalrestrictionprofilevalue_value() const;
  ::holo::map::adasisv3::ConditionalRestrictionProfileValue* release_conditionalrestrictionprofilevalue_value();
  ::holo::map::adasisv3::ConditionalRestrictionProfileValue* mutable_conditionalrestrictionprofilevalue_value();
  void set_allocated_conditionalrestrictionprofilevalue_value(::holo::map::adasisv3::ConditionalRestrictionProfileValue* conditionalrestrictionprofilevalue_value);

  // optional .holo.map.adasisv3.RoadSurfaceProfileValue RoadSurfaceProfileValue_value = 45;
  bool has_roadsurfaceprofilevalue_value() const;
  void clear_roadsurfaceprofilevalue_value();
  static const int kRoadSurfaceProfileValueValueFieldNumber = 45;
  private:
  const ::holo::map::adasisv3::RoadSurfaceProfileValue& _internal_roadsurfaceprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::RoadSurfaceProfileValue& roadsurfaceprofilevalue_value() const;
  ::holo::map::adasisv3::RoadSurfaceProfileValue* release_roadsurfaceprofilevalue_value();
  ::holo::map::adasisv3::RoadSurfaceProfileValue* mutable_roadsurfaceprofilevalue_value();
  void set_allocated_roadsurfaceprofilevalue_value(::holo::map::adasisv3::RoadSurfaceProfileValue* roadsurfaceprofilevalue_value);

  // optional .holo.map.adasisv3.PoleProfileValue PoleProfileValue_value = 46;
  bool has_poleprofilevalue_value() const;
  void clear_poleprofilevalue_value();
  static const int kPoleProfileValueValueFieldNumber = 46;
  private:
  const ::holo::map::adasisv3::PoleProfileValue& _internal_poleprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::PoleProfileValue& poleprofilevalue_value() const;
  ::holo::map::adasisv3::PoleProfileValue* release_poleprofilevalue_value();
  ::holo::map::adasisv3::PoleProfileValue* mutable_poleprofilevalue_value();
  void set_allocated_poleprofilevalue_value(::holo::map::adasisv3::PoleProfileValue* poleprofilevalue_value);

  // optional .holo.map.adasisv3.TrafficFlowProfileValue TrafficFlowProfileValue_value = 47;
  bool has_trafficflowprofilevalue_value() const;
  void clear_trafficflowprofilevalue_value();
  static const int kTrafficFlowProfileValueValueFieldNumber = 47;
  private:
  const ::holo::map::adasisv3::TrafficFlowProfileValue& _internal_trafficflowprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::TrafficFlowProfileValue& trafficflowprofilevalue_value() const;
  ::holo::map::adasisv3::TrafficFlowProfileValue* release_trafficflowprofilevalue_value();
  ::holo::map::adasisv3::TrafficFlowProfileValue* mutable_trafficflowprofilevalue_value();
  void set_allocated_trafficflowprofilevalue_value(::holo::map::adasisv3::TrafficFlowProfileValue* trafficflowprofilevalue_value);

  // optional .holo.map.adasisv3.TrafficEventProfileValue TrafficEventProfileValue_value = 48;
  bool has_trafficeventprofilevalue_value() const;
  void clear_trafficeventprofilevalue_value();
  static const int kTrafficEventProfileValueValueFieldNumber = 48;
  private:
  const ::holo::map::adasisv3::TrafficEventProfileValue& _internal_trafficeventprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::TrafficEventProfileValue& trafficeventprofilevalue_value() const;
  ::holo::map::adasisv3::TrafficEventProfileValue* release_trafficeventprofilevalue_value();
  ::holo::map::adasisv3::TrafficEventProfileValue* mutable_trafficeventprofilevalue_value();
  void set_allocated_trafficeventprofilevalue_value(::holo::map::adasisv3::TrafficEventProfileValue* trafficeventprofilevalue_value);

  // optional .holo.map.adasisv3.StaticODDProfileValue StaticODDProfileValue_value = 49;
  bool has_staticoddprofilevalue_value() const;
  void clear_staticoddprofilevalue_value();
  static const int kStaticODDProfileValueValueFieldNumber = 49;
  private:
  const ::holo::map::adasisv3::StaticODDProfileValue& _internal_staticoddprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::StaticODDProfileValue& staticoddprofilevalue_value() const;
  ::holo::map::adasisv3::StaticODDProfileValue* release_staticoddprofilevalue_value();
  ::holo::map::adasisv3::StaticODDProfileValue* mutable_staticoddprofilevalue_value();
  void set_allocated_staticoddprofilevalue_value(::holo::map::adasisv3::StaticODDProfileValue* staticoddprofilevalue_value);

  // optional .holo.map.adasisv3.StaticNotODDProfileValue StaticNotODDProfileValue_value = 50;
  bool has_staticnotoddprofilevalue_value() const;
  void clear_staticnotoddprofilevalue_value();
  static const int kStaticNotODDProfileValueValueFieldNumber = 50;
  private:
  const ::holo::map::adasisv3::StaticNotODDProfileValue& _internal_staticnotoddprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::StaticNotODDProfileValue& staticnotoddprofilevalue_value() const;
  ::holo::map::adasisv3::StaticNotODDProfileValue* release_staticnotoddprofilevalue_value();
  ::holo::map::adasisv3::StaticNotODDProfileValue* mutable_staticnotoddprofilevalue_value();
  void set_allocated_staticnotoddprofilevalue_value(::holo::map::adasisv3::StaticNotODDProfileValue* staticnotoddprofilevalue_value);

  // optional .holo.map.adasisv3.DecelerationZoneProfileValue DecelerationzoneProfileValue_value = 51;
  bool has_decelerationzoneprofilevalue_value() const;
  void clear_decelerationzoneprofilevalue_value();
  static const int kDecelerationzoneProfileValueValueFieldNumber = 51;
  private:
  const ::holo::map::adasisv3::DecelerationZoneProfileValue& _internal_decelerationzoneprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::DecelerationZoneProfileValue& decelerationzoneprofilevalue_value() const;
  ::holo::map::adasisv3::DecelerationZoneProfileValue* release_decelerationzoneprofilevalue_value();
  ::holo::map::adasisv3::DecelerationZoneProfileValue* mutable_decelerationzoneprofilevalue_value();
  void set_allocated_decelerationzoneprofilevalue_value(::holo::map::adasisv3::DecelerationZoneProfileValue* decelerationzoneprofilevalue_value);

  // optional .holo.map.adasisv3.OverHeadProfileValue OverHeadProfileValue_value = 52;
  bool has_overheadprofilevalue_value() const;
  void clear_overheadprofilevalue_value();
  static const int kOverHeadProfileValueValueFieldNumber = 52;
  private:
  const ::holo::map::adasisv3::OverHeadProfileValue& _internal_overheadprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::OverHeadProfileValue& overheadprofilevalue_value() const;
  ::holo::map::adasisv3::OverHeadProfileValue* release_overheadprofilevalue_value();
  ::holo::map::adasisv3::OverHeadProfileValue* mutable_overheadprofilevalue_value();
  void set_allocated_overheadprofilevalue_value(::holo::map::adasisv3::OverHeadProfileValue* overheadprofilevalue_value);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ProfileEntry)
 private:
  void set_has_instanceid();
  void clear_has_instanceid();
  void set_has_isretransmission();
  void clear_has_isretransmission();
  void set_has_change();
  void clear_has_change();
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_pathid();
  void clear_has_pathid();
  void set_has_direction();
  void clear_has_direction();
  void set_has_offset();
  void clear_has_offset();
  void set_has_endoffset();
  void clear_has_endoffset();
  void set_has_endoffsetfinal();
  void clear_has_endoffsetfinal();
  void set_has_type();
  void clear_has_type();
  void set_has_available();
  void clear_has_available();
  void set_has_uint32profilevalue_value();
  void set_has_int32profilevalue_value();
  void set_has_uint64profilevalue_value();
  void set_has_floatprofilevalue_value();
  void set_has_booleanprofilevalue_value();
  void set_has_yesnounknownprofilevalue_value();
  void set_has_formofwayprofilevalue_value();
  void set_has_drivingsideprofilevalue_value();
  void set_has_unitsystemprofilevalue_value();
  void set_has_specialsituationprofilevalue_value();
  void set_has_roadconditionprofilevalue_value();
  void set_has_weatherprofilevalue_value();
  void set_has_mapproviderprofilevalue_value();
  void set_has_mapstatusprofilevalue_value();
  void set_has_offsetfloatprofilevalue_value();
  void set_has_nodeprofilevalue_value();
  void set_has_systemstatusprofilevalue_value();
  void set_has_absolutevehiclepositionprofilevalue_value();
  void set_has_surfaceconditionprofilevalue_value();
  void set_has_speedprofilevalue_value();
  void set_has_lanemodelvalue_value();
  void set_has_laneconnectivityvalue_value();
  void set_has_linearobjectdefinitionvalue_value();
  void set_has_lanesgeometryprofilevalue_value();
  void set_has_roadgeometryprofilevalue_value();
  void set_has_trafficlightprofilevalue_value();
  void set_has_effectivespeedlimit_value();
  void set_has_locationobject_value();
  void set_has_regioncodevalue_value();
  void set_has_extendedspeedlimitvalue_value();
  void set_has_trafficsignvalue_value();
  void set_has_conditionalrestrictionprofilevalue_value();
  void set_has_roadsurfaceprofilevalue_value();
  void set_has_poleprofilevalue_value();
  void set_has_trafficflowprofilevalue_value();
  void set_has_trafficeventprofilevalue_value();
  void set_has_staticoddprofilevalue_value();
  void set_has_staticnotoddprofilevalue_value();
  void set_has_decelerationzoneprofilevalue_value();
  void set_has_overheadprofilevalue_value();

  inline bool has_value() const;
  inline void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > lanenumbers_;
  ::google::protobuf::uint32 instanceid_;
  int change_;
  float confidence_;
  ::google::protobuf::uint32 pathid_;
  bool isretransmission_;
  bool endoffsetfinal_;
  int direction_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 endoffset_;
  int type_;
  int available_;
  union ValueUnion {
    ValueUnion() {}
    ::holo::map::adasisv3::UInt32ProfileValue* uint32profilevalue_value_;
    ::holo::map::adasisv3::Int32ProfileValue* int32profilevalue_value_;
    ::holo::map::adasisv3::UInt64ProfileValue* uint64profilevalue_value_;
    ::holo::map::adasisv3::FloatProfileValue* floatprofilevalue_value_;
    ::holo::map::adasisv3::BooleanProfileValue* booleanprofilevalue_value_;
    ::holo::map::adasisv3::YesNoUnknownProfileValue* yesnounknownprofilevalue_value_;
    ::holo::map::adasisv3::FormOfWayProfileValue* formofwayprofilevalue_value_;
    ::holo::map::adasisv3::DrivingSideProfileValue* drivingsideprofilevalue_value_;
    ::holo::map::adasisv3::UnitSystemProfileValue* unitsystemprofilevalue_value_;
    ::holo::map::adasisv3::SpecialSituationProfileValue* specialsituationprofilevalue_value_;
    ::holo::map::adasisv3::RoadConditionProfileValue* roadconditionprofilevalue_value_;
    ::holo::map::adasisv3::WeatherProfileValue* weatherprofilevalue_value_;
    ::holo::map::adasisv3::MapProviderProfileValue* mapproviderprofilevalue_value_;
    ::holo::map::adasisv3::MapStatusProfileValue* mapstatusprofilevalue_value_;
    ::holo::map::adasisv3::OffsetFloatProfileValue* offsetfloatprofilevalue_value_;
    ::holo::map::adasisv3::NodeProfileValue* nodeprofilevalue_value_;
    ::holo::map::adasisv3::SystemStatusProfileValue* systemstatusprofilevalue_value_;
    ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* absolutevehiclepositionprofilevalue_value_;
    ::holo::map::adasisv3::SurfaceConditionProfileValue* surfaceconditionprofilevalue_value_;
    ::holo::map::adasisv3::SpeedProfileValue* speedprofilevalue_value_;
    ::holo::map::adasisv3::LaneModelValue* lanemodelvalue_value_;
    ::holo::map::adasisv3::LaneConnectivityValue* laneconnectivityvalue_value_;
    ::holo::map::adasisv3::LinearObjectDefinitionValue* linearobjectdefinitionvalue_value_;
    ::holo::map::adasisv3::LanesGeometryProfileValue* lanesgeometryprofilevalue_value_;
    ::holo::map::adasisv3::RoadGeometryProfileValue* roadgeometryprofilevalue_value_;
    ::holo::map::adasisv3::TrafficLightProfileValue* trafficlightprofilevalue_value_;
    ::holo::map::adasisv3::EffectiveSpeedLimit* effectivespeedlimit_value_;
    ::holo::map::adasisv3::LocationObject* locationobject_value_;
    ::holo::map::adasisv3::RegionCodeValue* regioncodevalue_value_;
    ::holo::map::adasisv3::ExtendedSpeedLimitValue* extendedspeedlimitvalue_value_;
    ::holo::map::adasisv3::TrafficSignValue* trafficsignvalue_value_;
    ::holo::map::adasisv3::ConditionalRestrictionProfileValue* conditionalrestrictionprofilevalue_value_;
    ::holo::map::adasisv3::RoadSurfaceProfileValue* roadsurfaceprofilevalue_value_;
    ::holo::map::adasisv3::PoleProfileValue* poleprofilevalue_value_;
    ::holo::map::adasisv3::TrafficFlowProfileValue* trafficflowprofilevalue_value_;
    ::holo::map::adasisv3::TrafficEventProfileValue* trafficeventprofilevalue_value_;
    ::holo::map::adasisv3::StaticODDProfileValue* staticoddprofilevalue_value_;
    ::holo::map::adasisv3::StaticNotODDProfileValue* staticnotoddprofilevalue_value_;
    ::holo::map::adasisv3::DecelerationZoneProfileValue* decelerationzoneprofilevalue_value_;
    ::holo::map::adasisv3::OverHeadProfileValue* overheadprofilevalue_value_;
  } value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProfileMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ProfileMessage) */ {
 public:
  ProfileMessage();
  virtual ~ProfileMessage();

  ProfileMessage(const ProfileMessage& from);

  inline ProfileMessage& operator=(const ProfileMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProfileMessage(ProfileMessage&& from) noexcept
    : ProfileMessage() {
    *this = ::std::move(from);
  }

  inline ProfileMessage& operator=(ProfileMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfileMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProfileMessage* internal_default_instance() {
    return reinterpret_cast<const ProfileMessage*>(
               &_ProfileMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ProfileMessage* other);
  friend void swap(ProfileMessage& a, ProfileMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProfileMessage* New() const final {
    return CreateMaybeMessage<ProfileMessage>(NULL);
  }

  ProfileMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProfileMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProfileMessage& from);
  void MergeFrom(const ProfileMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.ProfileEntry profiles = 1;
  int profiles_size() const;
  void clear_profiles();
  static const int kProfilesFieldNumber = 1;
  ::holo::map::adasisv3::ProfileEntry* mutable_profiles(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileEntry >*
      mutable_profiles();
  const ::holo::map::adasisv3::ProfileEntry& profiles(int index) const;
  ::holo::map::adasisv3::ProfileEntry* add_profiles();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileEntry >&
      profiles() const;

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ProfileMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileEntry > profiles_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GlobalData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.GlobalData) */ {
 public:
  GlobalData();
  virtual ~GlobalData();

  GlobalData(const GlobalData& from);

  inline GlobalData& operator=(const GlobalData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GlobalData(GlobalData&& from) noexcept
    : GlobalData() {
    *this = ::std::move(from);
  }

  inline GlobalData& operator=(GlobalData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalData& default_instance();

  enum ValueCase {
    kUInt32ProfileValueValue = 3,
    kInt32ProfileValueValue = 4,
    kUInt64ProfileValueValue = 5,
    kFloatProfileValueValue = 6,
    kBooleanProfileValueValue = 7,
    kYesNoUnknownProfileValueValue = 8,
    kFormOfWayProfileValueValue = 9,
    kDrivingSideProfileValueValue = 10,
    kUnitSystemProfileValueValue = 11,
    kSpecialSituationProfileValueValue = 12,
    kRoadConditionProfileValueValue = 13,
    kWeatherProfileValueValue = 14,
    kMapProviderProfileValueValue = 15,
    kMapStatusProfileValueValue = 16,
    kOffsetFloatProfileValueValue = 17,
    kNodeProfileValueValue = 18,
    kSystemStatusProfileValueValue = 19,
    kAbsoluteVehiclePositionProfileValueValue = 20,
    kSurfaceConditionProfileValueValue = 21,
    kSpeedProfileValueValue = 22,
    kLaneModelValueValue = 23,
    kLaneConnectivityValueValue = 24,
    kLinearObjectDefinitionValueValue = 25,
    kLanesGeometryProfileValueValue = 26,
    kRoadGeometryProfileValueValue = 27,
    kTrafficLightProfileValueValue = 28,
    kEffectiveSpeedLimitValue = 29,
    kLocationObjectValue = 30,
    kRegionCodeValueValue = 31,
    kExtendedSpeedLimitValueValue = 32,
    kTrafficSignValueValue = 33,
    kConditionalRestrictionProfileValueValue = 34,
    kOverHeadProfileValueValue = 35,
    VALUE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlobalData* internal_default_instance() {
    return reinterpret_cast<const GlobalData*>(
               &_GlobalData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GlobalData* other);
  friend void swap(GlobalData& a, GlobalData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GlobalData* New() const final {
    return CreateMaybeMessage<GlobalData>(NULL);
  }

  GlobalData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GlobalData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GlobalData& from);
  void MergeFrom(const GlobalData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.ProfileType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::holo::map::adasisv3::ProfileType type() const;
  void set_type(::holo::map::adasisv3::ProfileType value);

  // required .holo.map.adasisv3.Availability available = 2;
  bool has_available() const;
  void clear_available();
  static const int kAvailableFieldNumber = 2;
  ::holo::map::adasisv3::Availability available() const;
  void set_available(::holo::map::adasisv3::Availability value);

  // optional .holo.map.adasisv3.UInt32ProfileValue UInt32ProfileValue_value = 3;
  bool has_uint32profilevalue_value() const;
  void clear_uint32profilevalue_value();
  static const int kUInt32ProfileValueValueFieldNumber = 3;
  private:
  const ::holo::map::adasisv3::UInt32ProfileValue& _internal_uint32profilevalue_value() const;
  public:
  const ::holo::map::adasisv3::UInt32ProfileValue& uint32profilevalue_value() const;
  ::holo::map::adasisv3::UInt32ProfileValue* release_uint32profilevalue_value();
  ::holo::map::adasisv3::UInt32ProfileValue* mutable_uint32profilevalue_value();
  void set_allocated_uint32profilevalue_value(::holo::map::adasisv3::UInt32ProfileValue* uint32profilevalue_value);

  // optional .holo.map.adasisv3.Int32ProfileValue Int32ProfileValue_value = 4;
  bool has_int32profilevalue_value() const;
  void clear_int32profilevalue_value();
  static const int kInt32ProfileValueValueFieldNumber = 4;
  private:
  const ::holo::map::adasisv3::Int32ProfileValue& _internal_int32profilevalue_value() const;
  public:
  const ::holo::map::adasisv3::Int32ProfileValue& int32profilevalue_value() const;
  ::holo::map::adasisv3::Int32ProfileValue* release_int32profilevalue_value();
  ::holo::map::adasisv3::Int32ProfileValue* mutable_int32profilevalue_value();
  void set_allocated_int32profilevalue_value(::holo::map::adasisv3::Int32ProfileValue* int32profilevalue_value);

  // optional .holo.map.adasisv3.UInt64ProfileValue UInt64ProfileValue_value = 5;
  bool has_uint64profilevalue_value() const;
  void clear_uint64profilevalue_value();
  static const int kUInt64ProfileValueValueFieldNumber = 5;
  private:
  const ::holo::map::adasisv3::UInt64ProfileValue& _internal_uint64profilevalue_value() const;
  public:
  const ::holo::map::adasisv3::UInt64ProfileValue& uint64profilevalue_value() const;
  ::holo::map::adasisv3::UInt64ProfileValue* release_uint64profilevalue_value();
  ::holo::map::adasisv3::UInt64ProfileValue* mutable_uint64profilevalue_value();
  void set_allocated_uint64profilevalue_value(::holo::map::adasisv3::UInt64ProfileValue* uint64profilevalue_value);

  // optional .holo.map.adasisv3.FloatProfileValue FloatProfileValue_value = 6;
  bool has_floatprofilevalue_value() const;
  void clear_floatprofilevalue_value();
  static const int kFloatProfileValueValueFieldNumber = 6;
  private:
  const ::holo::map::adasisv3::FloatProfileValue& _internal_floatprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::FloatProfileValue& floatprofilevalue_value() const;
  ::holo::map::adasisv3::FloatProfileValue* release_floatprofilevalue_value();
  ::holo::map::adasisv3::FloatProfileValue* mutable_floatprofilevalue_value();
  void set_allocated_floatprofilevalue_value(::holo::map::adasisv3::FloatProfileValue* floatprofilevalue_value);

  // optional .holo.map.adasisv3.BooleanProfileValue BooleanProfileValue_value = 7;
  bool has_booleanprofilevalue_value() const;
  void clear_booleanprofilevalue_value();
  static const int kBooleanProfileValueValueFieldNumber = 7;
  private:
  const ::holo::map::adasisv3::BooleanProfileValue& _internal_booleanprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::BooleanProfileValue& booleanprofilevalue_value() const;
  ::holo::map::adasisv3::BooleanProfileValue* release_booleanprofilevalue_value();
  ::holo::map::adasisv3::BooleanProfileValue* mutable_booleanprofilevalue_value();
  void set_allocated_booleanprofilevalue_value(::holo::map::adasisv3::BooleanProfileValue* booleanprofilevalue_value);

  // optional .holo.map.adasisv3.YesNoUnknownProfileValue YesNoUnknownProfileValue_value = 8;
  bool has_yesnounknownprofilevalue_value() const;
  void clear_yesnounknownprofilevalue_value();
  static const int kYesNoUnknownProfileValueValueFieldNumber = 8;
  private:
  const ::holo::map::adasisv3::YesNoUnknownProfileValue& _internal_yesnounknownprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::YesNoUnknownProfileValue& yesnounknownprofilevalue_value() const;
  ::holo::map::adasisv3::YesNoUnknownProfileValue* release_yesnounknownprofilevalue_value();
  ::holo::map::adasisv3::YesNoUnknownProfileValue* mutable_yesnounknownprofilevalue_value();
  void set_allocated_yesnounknownprofilevalue_value(::holo::map::adasisv3::YesNoUnknownProfileValue* yesnounknownprofilevalue_value);

  // optional .holo.map.adasisv3.FormOfWayProfileValue FormOfWayProfileValue_value = 9;
  bool has_formofwayprofilevalue_value() const;
  void clear_formofwayprofilevalue_value();
  static const int kFormOfWayProfileValueValueFieldNumber = 9;
  private:
  const ::holo::map::adasisv3::FormOfWayProfileValue& _internal_formofwayprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::FormOfWayProfileValue& formofwayprofilevalue_value() const;
  ::holo::map::adasisv3::FormOfWayProfileValue* release_formofwayprofilevalue_value();
  ::holo::map::adasisv3::FormOfWayProfileValue* mutable_formofwayprofilevalue_value();
  void set_allocated_formofwayprofilevalue_value(::holo::map::adasisv3::FormOfWayProfileValue* formofwayprofilevalue_value);

  // optional .holo.map.adasisv3.DrivingSideProfileValue DrivingSideProfileValue_value = 10;
  bool has_drivingsideprofilevalue_value() const;
  void clear_drivingsideprofilevalue_value();
  static const int kDrivingSideProfileValueValueFieldNumber = 10;
  private:
  const ::holo::map::adasisv3::DrivingSideProfileValue& _internal_drivingsideprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::DrivingSideProfileValue& drivingsideprofilevalue_value() const;
  ::holo::map::adasisv3::DrivingSideProfileValue* release_drivingsideprofilevalue_value();
  ::holo::map::adasisv3::DrivingSideProfileValue* mutable_drivingsideprofilevalue_value();
  void set_allocated_drivingsideprofilevalue_value(::holo::map::adasisv3::DrivingSideProfileValue* drivingsideprofilevalue_value);

  // optional .holo.map.adasisv3.UnitSystemProfileValue UnitSystemProfileValue_value = 11;
  bool has_unitsystemprofilevalue_value() const;
  void clear_unitsystemprofilevalue_value();
  static const int kUnitSystemProfileValueValueFieldNumber = 11;
  private:
  const ::holo::map::adasisv3::UnitSystemProfileValue& _internal_unitsystemprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::UnitSystemProfileValue& unitsystemprofilevalue_value() const;
  ::holo::map::adasisv3::UnitSystemProfileValue* release_unitsystemprofilevalue_value();
  ::holo::map::adasisv3::UnitSystemProfileValue* mutable_unitsystemprofilevalue_value();
  void set_allocated_unitsystemprofilevalue_value(::holo::map::adasisv3::UnitSystemProfileValue* unitsystemprofilevalue_value);

  // optional .holo.map.adasisv3.SpecialSituationProfileValue SpecialSituationProfileValue_value = 12;
  bool has_specialsituationprofilevalue_value() const;
  void clear_specialsituationprofilevalue_value();
  static const int kSpecialSituationProfileValueValueFieldNumber = 12;
  private:
  const ::holo::map::adasisv3::SpecialSituationProfileValue& _internal_specialsituationprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::SpecialSituationProfileValue& specialsituationprofilevalue_value() const;
  ::holo::map::adasisv3::SpecialSituationProfileValue* release_specialsituationprofilevalue_value();
  ::holo::map::adasisv3::SpecialSituationProfileValue* mutable_specialsituationprofilevalue_value();
  void set_allocated_specialsituationprofilevalue_value(::holo::map::adasisv3::SpecialSituationProfileValue* specialsituationprofilevalue_value);

  // optional .holo.map.adasisv3.RoadConditionProfileValue RoadConditionProfileValue_value = 13;
  bool has_roadconditionprofilevalue_value() const;
  void clear_roadconditionprofilevalue_value();
  static const int kRoadConditionProfileValueValueFieldNumber = 13;
  private:
  const ::holo::map::adasisv3::RoadConditionProfileValue& _internal_roadconditionprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::RoadConditionProfileValue& roadconditionprofilevalue_value() const;
  ::holo::map::adasisv3::RoadConditionProfileValue* release_roadconditionprofilevalue_value();
  ::holo::map::adasisv3::RoadConditionProfileValue* mutable_roadconditionprofilevalue_value();
  void set_allocated_roadconditionprofilevalue_value(::holo::map::adasisv3::RoadConditionProfileValue* roadconditionprofilevalue_value);

  // optional .holo.map.adasisv3.WeatherProfileValue WeatherProfileValue_value = 14;
  bool has_weatherprofilevalue_value() const;
  void clear_weatherprofilevalue_value();
  static const int kWeatherProfileValueValueFieldNumber = 14;
  private:
  const ::holo::map::adasisv3::WeatherProfileValue& _internal_weatherprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::WeatherProfileValue& weatherprofilevalue_value() const;
  ::holo::map::adasisv3::WeatherProfileValue* release_weatherprofilevalue_value();
  ::holo::map::adasisv3::WeatherProfileValue* mutable_weatherprofilevalue_value();
  void set_allocated_weatherprofilevalue_value(::holo::map::adasisv3::WeatherProfileValue* weatherprofilevalue_value);

  // optional .holo.map.adasisv3.MapProviderProfileValue MapProviderProfileValue_value = 15;
  bool has_mapproviderprofilevalue_value() const;
  void clear_mapproviderprofilevalue_value();
  static const int kMapProviderProfileValueValueFieldNumber = 15;
  private:
  const ::holo::map::adasisv3::MapProviderProfileValue& _internal_mapproviderprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::MapProviderProfileValue& mapproviderprofilevalue_value() const;
  ::holo::map::adasisv3::MapProviderProfileValue* release_mapproviderprofilevalue_value();
  ::holo::map::adasisv3::MapProviderProfileValue* mutable_mapproviderprofilevalue_value();
  void set_allocated_mapproviderprofilevalue_value(::holo::map::adasisv3::MapProviderProfileValue* mapproviderprofilevalue_value);

  // optional .holo.map.adasisv3.MapStatusProfileValue MapStatusProfileValue_value = 16;
  bool has_mapstatusprofilevalue_value() const;
  void clear_mapstatusprofilevalue_value();
  static const int kMapStatusProfileValueValueFieldNumber = 16;
  private:
  const ::holo::map::adasisv3::MapStatusProfileValue& _internal_mapstatusprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::MapStatusProfileValue& mapstatusprofilevalue_value() const;
  ::holo::map::adasisv3::MapStatusProfileValue* release_mapstatusprofilevalue_value();
  ::holo::map::adasisv3::MapStatusProfileValue* mutable_mapstatusprofilevalue_value();
  void set_allocated_mapstatusprofilevalue_value(::holo::map::adasisv3::MapStatusProfileValue* mapstatusprofilevalue_value);

  // optional .holo.map.adasisv3.OffsetFloatProfileValue OffsetFloatProfileValue_value = 17;
  bool has_offsetfloatprofilevalue_value() const;
  void clear_offsetfloatprofilevalue_value();
  static const int kOffsetFloatProfileValueValueFieldNumber = 17;
  private:
  const ::holo::map::adasisv3::OffsetFloatProfileValue& _internal_offsetfloatprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::OffsetFloatProfileValue& offsetfloatprofilevalue_value() const;
  ::holo::map::adasisv3::OffsetFloatProfileValue* release_offsetfloatprofilevalue_value();
  ::holo::map::adasisv3::OffsetFloatProfileValue* mutable_offsetfloatprofilevalue_value();
  void set_allocated_offsetfloatprofilevalue_value(::holo::map::adasisv3::OffsetFloatProfileValue* offsetfloatprofilevalue_value);

  // optional .holo.map.adasisv3.NodeProfileValue NodeProfileValue_value = 18;
  bool has_nodeprofilevalue_value() const;
  void clear_nodeprofilevalue_value();
  static const int kNodeProfileValueValueFieldNumber = 18;
  private:
  const ::holo::map::adasisv3::NodeProfileValue& _internal_nodeprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::NodeProfileValue& nodeprofilevalue_value() const;
  ::holo::map::adasisv3::NodeProfileValue* release_nodeprofilevalue_value();
  ::holo::map::adasisv3::NodeProfileValue* mutable_nodeprofilevalue_value();
  void set_allocated_nodeprofilevalue_value(::holo::map::adasisv3::NodeProfileValue* nodeprofilevalue_value);

  // optional .holo.map.adasisv3.SystemStatusProfileValue SystemStatusProfileValue_value = 19;
  bool has_systemstatusprofilevalue_value() const;
  void clear_systemstatusprofilevalue_value();
  static const int kSystemStatusProfileValueValueFieldNumber = 19;
  private:
  const ::holo::map::adasisv3::SystemStatusProfileValue& _internal_systemstatusprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::SystemStatusProfileValue& systemstatusprofilevalue_value() const;
  ::holo::map::adasisv3::SystemStatusProfileValue* release_systemstatusprofilevalue_value();
  ::holo::map::adasisv3::SystemStatusProfileValue* mutable_systemstatusprofilevalue_value();
  void set_allocated_systemstatusprofilevalue_value(::holo::map::adasisv3::SystemStatusProfileValue* systemstatusprofilevalue_value);

  // optional .holo.map.adasisv3.AbsoluteVehiclePositionProfileValue AbsoluteVehiclePositionProfileValue_value = 20;
  bool has_absolutevehiclepositionprofilevalue_value() const;
  void clear_absolutevehiclepositionprofilevalue_value();
  static const int kAbsoluteVehiclePositionProfileValueValueFieldNumber = 20;
  private:
  const ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue& _internal_absolutevehiclepositionprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue& absolutevehiclepositionprofilevalue_value() const;
  ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* release_absolutevehiclepositionprofilevalue_value();
  ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* mutable_absolutevehiclepositionprofilevalue_value();
  void set_allocated_absolutevehiclepositionprofilevalue_value(::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* absolutevehiclepositionprofilevalue_value);

  // optional .holo.map.adasisv3.SurfaceConditionProfileValue SurfaceConditionProfileValue_value = 21;
  bool has_surfaceconditionprofilevalue_value() const;
  void clear_surfaceconditionprofilevalue_value();
  static const int kSurfaceConditionProfileValueValueFieldNumber = 21;
  private:
  const ::holo::map::adasisv3::SurfaceConditionProfileValue& _internal_surfaceconditionprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::SurfaceConditionProfileValue& surfaceconditionprofilevalue_value() const;
  ::holo::map::adasisv3::SurfaceConditionProfileValue* release_surfaceconditionprofilevalue_value();
  ::holo::map::adasisv3::SurfaceConditionProfileValue* mutable_surfaceconditionprofilevalue_value();
  void set_allocated_surfaceconditionprofilevalue_value(::holo::map::adasisv3::SurfaceConditionProfileValue* surfaceconditionprofilevalue_value);

  // optional .holo.map.adasisv3.SpeedProfileValue SpeedProfileValue_value = 22;
  bool has_speedprofilevalue_value() const;
  void clear_speedprofilevalue_value();
  static const int kSpeedProfileValueValueFieldNumber = 22;
  private:
  const ::holo::map::adasisv3::SpeedProfileValue& _internal_speedprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::SpeedProfileValue& speedprofilevalue_value() const;
  ::holo::map::adasisv3::SpeedProfileValue* release_speedprofilevalue_value();
  ::holo::map::adasisv3::SpeedProfileValue* mutable_speedprofilevalue_value();
  void set_allocated_speedprofilevalue_value(::holo::map::adasisv3::SpeedProfileValue* speedprofilevalue_value);

  // optional .holo.map.adasisv3.LaneModelValue LaneModelValue_value = 23;
  bool has_lanemodelvalue_value() const;
  void clear_lanemodelvalue_value();
  static const int kLaneModelValueValueFieldNumber = 23;
  private:
  const ::holo::map::adasisv3::LaneModelValue& _internal_lanemodelvalue_value() const;
  public:
  const ::holo::map::adasisv3::LaneModelValue& lanemodelvalue_value() const;
  ::holo::map::adasisv3::LaneModelValue* release_lanemodelvalue_value();
  ::holo::map::adasisv3::LaneModelValue* mutable_lanemodelvalue_value();
  void set_allocated_lanemodelvalue_value(::holo::map::adasisv3::LaneModelValue* lanemodelvalue_value);

  // optional .holo.map.adasisv3.LaneConnectivityValue LaneConnectivityValue_value = 24;
  bool has_laneconnectivityvalue_value() const;
  void clear_laneconnectivityvalue_value();
  static const int kLaneConnectivityValueValueFieldNumber = 24;
  private:
  const ::holo::map::adasisv3::LaneConnectivityValue& _internal_laneconnectivityvalue_value() const;
  public:
  const ::holo::map::adasisv3::LaneConnectivityValue& laneconnectivityvalue_value() const;
  ::holo::map::adasisv3::LaneConnectivityValue* release_laneconnectivityvalue_value();
  ::holo::map::adasisv3::LaneConnectivityValue* mutable_laneconnectivityvalue_value();
  void set_allocated_laneconnectivityvalue_value(::holo::map::adasisv3::LaneConnectivityValue* laneconnectivityvalue_value);

  // optional .holo.map.adasisv3.LinearObjectDefinitionValue LinearObjectDefinitionValue_value = 25;
  bool has_linearobjectdefinitionvalue_value() const;
  void clear_linearobjectdefinitionvalue_value();
  static const int kLinearObjectDefinitionValueValueFieldNumber = 25;
  private:
  const ::holo::map::adasisv3::LinearObjectDefinitionValue& _internal_linearobjectdefinitionvalue_value() const;
  public:
  const ::holo::map::adasisv3::LinearObjectDefinitionValue& linearobjectdefinitionvalue_value() const;
  ::holo::map::adasisv3::LinearObjectDefinitionValue* release_linearobjectdefinitionvalue_value();
  ::holo::map::adasisv3::LinearObjectDefinitionValue* mutable_linearobjectdefinitionvalue_value();
  void set_allocated_linearobjectdefinitionvalue_value(::holo::map::adasisv3::LinearObjectDefinitionValue* linearobjectdefinitionvalue_value);

  // optional .holo.map.adasisv3.LanesGeometryProfileValue LanesGeometryProfileValue_value = 26;
  bool has_lanesgeometryprofilevalue_value() const;
  void clear_lanesgeometryprofilevalue_value();
  static const int kLanesGeometryProfileValueValueFieldNumber = 26;
  private:
  const ::holo::map::adasisv3::LanesGeometryProfileValue& _internal_lanesgeometryprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::LanesGeometryProfileValue& lanesgeometryprofilevalue_value() const;
  ::holo::map::adasisv3::LanesGeometryProfileValue* release_lanesgeometryprofilevalue_value();
  ::holo::map::adasisv3::LanesGeometryProfileValue* mutable_lanesgeometryprofilevalue_value();
  void set_allocated_lanesgeometryprofilevalue_value(::holo::map::adasisv3::LanesGeometryProfileValue* lanesgeometryprofilevalue_value);

  // optional .holo.map.adasisv3.RoadGeometryProfileValue RoadGeometryProfileValue_value = 27;
  bool has_roadgeometryprofilevalue_value() const;
  void clear_roadgeometryprofilevalue_value();
  static const int kRoadGeometryProfileValueValueFieldNumber = 27;
  private:
  const ::holo::map::adasisv3::RoadGeometryProfileValue& _internal_roadgeometryprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::RoadGeometryProfileValue& roadgeometryprofilevalue_value() const;
  ::holo::map::adasisv3::RoadGeometryProfileValue* release_roadgeometryprofilevalue_value();
  ::holo::map::adasisv3::RoadGeometryProfileValue* mutable_roadgeometryprofilevalue_value();
  void set_allocated_roadgeometryprofilevalue_value(::holo::map::adasisv3::RoadGeometryProfileValue* roadgeometryprofilevalue_value);

  // optional .holo.map.adasisv3.TrafficLightProfileValue TrafficLightProfileValue_value = 28;
  bool has_trafficlightprofilevalue_value() const;
  void clear_trafficlightprofilevalue_value();
  static const int kTrafficLightProfileValueValueFieldNumber = 28;
  private:
  const ::holo::map::adasisv3::TrafficLightProfileValue& _internal_trafficlightprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::TrafficLightProfileValue& trafficlightprofilevalue_value() const;
  ::holo::map::adasisv3::TrafficLightProfileValue* release_trafficlightprofilevalue_value();
  ::holo::map::adasisv3::TrafficLightProfileValue* mutable_trafficlightprofilevalue_value();
  void set_allocated_trafficlightprofilevalue_value(::holo::map::adasisv3::TrafficLightProfileValue* trafficlightprofilevalue_value);

  // optional .holo.map.adasisv3.EffectiveSpeedLimit EffectiveSpeedLimit_value = 29;
  bool has_effectivespeedlimit_value() const;
  void clear_effectivespeedlimit_value();
  static const int kEffectiveSpeedLimitValueFieldNumber = 29;
  private:
  const ::holo::map::adasisv3::EffectiveSpeedLimit& _internal_effectivespeedlimit_value() const;
  public:
  const ::holo::map::adasisv3::EffectiveSpeedLimit& effectivespeedlimit_value() const;
  ::holo::map::adasisv3::EffectiveSpeedLimit* release_effectivespeedlimit_value();
  ::holo::map::adasisv3::EffectiveSpeedLimit* mutable_effectivespeedlimit_value();
  void set_allocated_effectivespeedlimit_value(::holo::map::adasisv3::EffectiveSpeedLimit* effectivespeedlimit_value);

  // optional .holo.map.adasisv3.LocationObject LocationObject_value = 30;
  bool has_locationobject_value() const;
  void clear_locationobject_value();
  static const int kLocationObjectValueFieldNumber = 30;
  private:
  const ::holo::map::adasisv3::LocationObject& _internal_locationobject_value() const;
  public:
  const ::holo::map::adasisv3::LocationObject& locationobject_value() const;
  ::holo::map::adasisv3::LocationObject* release_locationobject_value();
  ::holo::map::adasisv3::LocationObject* mutable_locationobject_value();
  void set_allocated_locationobject_value(::holo::map::adasisv3::LocationObject* locationobject_value);

  // optional .holo.map.adasisv3.RegionCodeValue RegionCodeValue_value = 31;
  bool has_regioncodevalue_value() const;
  void clear_regioncodevalue_value();
  static const int kRegionCodeValueValueFieldNumber = 31;
  private:
  const ::holo::map::adasisv3::RegionCodeValue& _internal_regioncodevalue_value() const;
  public:
  const ::holo::map::adasisv3::RegionCodeValue& regioncodevalue_value() const;
  ::holo::map::adasisv3::RegionCodeValue* release_regioncodevalue_value();
  ::holo::map::adasisv3::RegionCodeValue* mutable_regioncodevalue_value();
  void set_allocated_regioncodevalue_value(::holo::map::adasisv3::RegionCodeValue* regioncodevalue_value);

  // optional .holo.map.adasisv3.ExtendedSpeedLimitValue ExtendedSpeedLimitValue_value = 32;
  bool has_extendedspeedlimitvalue_value() const;
  void clear_extendedspeedlimitvalue_value();
  static const int kExtendedSpeedLimitValueValueFieldNumber = 32;
  private:
  const ::holo::map::adasisv3::ExtendedSpeedLimitValue& _internal_extendedspeedlimitvalue_value() const;
  public:
  const ::holo::map::adasisv3::ExtendedSpeedLimitValue& extendedspeedlimitvalue_value() const;
  ::holo::map::adasisv3::ExtendedSpeedLimitValue* release_extendedspeedlimitvalue_value();
  ::holo::map::adasisv3::ExtendedSpeedLimitValue* mutable_extendedspeedlimitvalue_value();
  void set_allocated_extendedspeedlimitvalue_value(::holo::map::adasisv3::ExtendedSpeedLimitValue* extendedspeedlimitvalue_value);

  // optional .holo.map.adasisv3.TrafficSignValue TrafficSignValue_value = 33;
  bool has_trafficsignvalue_value() const;
  void clear_trafficsignvalue_value();
  static const int kTrafficSignValueValueFieldNumber = 33;
  private:
  const ::holo::map::adasisv3::TrafficSignValue& _internal_trafficsignvalue_value() const;
  public:
  const ::holo::map::adasisv3::TrafficSignValue& trafficsignvalue_value() const;
  ::holo::map::adasisv3::TrafficSignValue* release_trafficsignvalue_value();
  ::holo::map::adasisv3::TrafficSignValue* mutable_trafficsignvalue_value();
  void set_allocated_trafficsignvalue_value(::holo::map::adasisv3::TrafficSignValue* trafficsignvalue_value);

  // optional .holo.map.adasisv3.ConditionalRestrictionProfileValue ConditionalRestrictionProfileValue_value = 34;
  bool has_conditionalrestrictionprofilevalue_value() const;
  void clear_conditionalrestrictionprofilevalue_value();
  static const int kConditionalRestrictionProfileValueValueFieldNumber = 34;
  private:
  const ::holo::map::adasisv3::ConditionalRestrictionProfileValue& _internal_conditionalrestrictionprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::ConditionalRestrictionProfileValue& conditionalrestrictionprofilevalue_value() const;
  ::holo::map::adasisv3::ConditionalRestrictionProfileValue* release_conditionalrestrictionprofilevalue_value();
  ::holo::map::adasisv3::ConditionalRestrictionProfileValue* mutable_conditionalrestrictionprofilevalue_value();
  void set_allocated_conditionalrestrictionprofilevalue_value(::holo::map::adasisv3::ConditionalRestrictionProfileValue* conditionalrestrictionprofilevalue_value);

  // optional .holo.map.adasisv3.OverHeadProfileValue OverHeadProfileValue_value = 35;
  bool has_overheadprofilevalue_value() const;
  void clear_overheadprofilevalue_value();
  static const int kOverHeadProfileValueValueFieldNumber = 35;
  private:
  const ::holo::map::adasisv3::OverHeadProfileValue& _internal_overheadprofilevalue_value() const;
  public:
  const ::holo::map::adasisv3::OverHeadProfileValue& overheadprofilevalue_value() const;
  ::holo::map::adasisv3::OverHeadProfileValue* release_overheadprofilevalue_value();
  ::holo::map::adasisv3::OverHeadProfileValue* mutable_overheadprofilevalue_value();
  void set_allocated_overheadprofilevalue_value(::holo::map::adasisv3::OverHeadProfileValue* overheadprofilevalue_value);

  void clear_value();
  ValueCase value_case() const;
  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.GlobalData)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_available();
  void clear_has_available();
  void set_has_uint32profilevalue_value();
  void set_has_int32profilevalue_value();
  void set_has_uint64profilevalue_value();
  void set_has_floatprofilevalue_value();
  void set_has_booleanprofilevalue_value();
  void set_has_yesnounknownprofilevalue_value();
  void set_has_formofwayprofilevalue_value();
  void set_has_drivingsideprofilevalue_value();
  void set_has_unitsystemprofilevalue_value();
  void set_has_specialsituationprofilevalue_value();
  void set_has_roadconditionprofilevalue_value();
  void set_has_weatherprofilevalue_value();
  void set_has_mapproviderprofilevalue_value();
  void set_has_mapstatusprofilevalue_value();
  void set_has_offsetfloatprofilevalue_value();
  void set_has_nodeprofilevalue_value();
  void set_has_systemstatusprofilevalue_value();
  void set_has_absolutevehiclepositionprofilevalue_value();
  void set_has_surfaceconditionprofilevalue_value();
  void set_has_speedprofilevalue_value();
  void set_has_lanemodelvalue_value();
  void set_has_laneconnectivityvalue_value();
  void set_has_linearobjectdefinitionvalue_value();
  void set_has_lanesgeometryprofilevalue_value();
  void set_has_roadgeometryprofilevalue_value();
  void set_has_trafficlightprofilevalue_value();
  void set_has_effectivespeedlimit_value();
  void set_has_locationobject_value();
  void set_has_regioncodevalue_value();
  void set_has_extendedspeedlimitvalue_value();
  void set_has_trafficsignvalue_value();
  void set_has_conditionalrestrictionprofilevalue_value();
  void set_has_overheadprofilevalue_value();

  inline bool has_value() const;
  inline void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int type_;
  int available_;
  union ValueUnion {
    ValueUnion() {}
    ::holo::map::adasisv3::UInt32ProfileValue* uint32profilevalue_value_;
    ::holo::map::adasisv3::Int32ProfileValue* int32profilevalue_value_;
    ::holo::map::adasisv3::UInt64ProfileValue* uint64profilevalue_value_;
    ::holo::map::adasisv3::FloatProfileValue* floatprofilevalue_value_;
    ::holo::map::adasisv3::BooleanProfileValue* booleanprofilevalue_value_;
    ::holo::map::adasisv3::YesNoUnknownProfileValue* yesnounknownprofilevalue_value_;
    ::holo::map::adasisv3::FormOfWayProfileValue* formofwayprofilevalue_value_;
    ::holo::map::adasisv3::DrivingSideProfileValue* drivingsideprofilevalue_value_;
    ::holo::map::adasisv3::UnitSystemProfileValue* unitsystemprofilevalue_value_;
    ::holo::map::adasisv3::SpecialSituationProfileValue* specialsituationprofilevalue_value_;
    ::holo::map::adasisv3::RoadConditionProfileValue* roadconditionprofilevalue_value_;
    ::holo::map::adasisv3::WeatherProfileValue* weatherprofilevalue_value_;
    ::holo::map::adasisv3::MapProviderProfileValue* mapproviderprofilevalue_value_;
    ::holo::map::adasisv3::MapStatusProfileValue* mapstatusprofilevalue_value_;
    ::holo::map::adasisv3::OffsetFloatProfileValue* offsetfloatprofilevalue_value_;
    ::holo::map::adasisv3::NodeProfileValue* nodeprofilevalue_value_;
    ::holo::map::adasisv3::SystemStatusProfileValue* systemstatusprofilevalue_value_;
    ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* absolutevehiclepositionprofilevalue_value_;
    ::holo::map::adasisv3::SurfaceConditionProfileValue* surfaceconditionprofilevalue_value_;
    ::holo::map::adasisv3::SpeedProfileValue* speedprofilevalue_value_;
    ::holo::map::adasisv3::LaneModelValue* lanemodelvalue_value_;
    ::holo::map::adasisv3::LaneConnectivityValue* laneconnectivityvalue_value_;
    ::holo::map::adasisv3::LinearObjectDefinitionValue* linearobjectdefinitionvalue_value_;
    ::holo::map::adasisv3::LanesGeometryProfileValue* lanesgeometryprofilevalue_value_;
    ::holo::map::adasisv3::RoadGeometryProfileValue* roadgeometryprofilevalue_value_;
    ::holo::map::adasisv3::TrafficLightProfileValue* trafficlightprofilevalue_value_;
    ::holo::map::adasisv3::EffectiveSpeedLimit* effectivespeedlimit_value_;
    ::holo::map::adasisv3::LocationObject* locationobject_value_;
    ::holo::map::adasisv3::RegionCodeValue* regioncodevalue_value_;
    ::holo::map::adasisv3::ExtendedSpeedLimitValue* extendedspeedlimitvalue_value_;
    ::holo::map::adasisv3::TrafficSignValue* trafficsignvalue_value_;
    ::holo::map::adasisv3::ConditionalRestrictionProfileValue* conditionalrestrictionprofilevalue_value_;
    ::holo::map::adasisv3::OverHeadProfileValue* overheadprofilevalue_value_;
  } value_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GlobalDataMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.GlobalDataMessage) */ {
 public:
  GlobalDataMessage();
  virtual ~GlobalDataMessage();

  GlobalDataMessage(const GlobalDataMessage& from);

  inline GlobalDataMessage& operator=(const GlobalDataMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GlobalDataMessage(GlobalDataMessage&& from) noexcept
    : GlobalDataMessage() {
    *this = ::std::move(from);
  }

  inline GlobalDataMessage& operator=(GlobalDataMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GlobalDataMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GlobalDataMessage* internal_default_instance() {
    return reinterpret_cast<const GlobalDataMessage*>(
               &_GlobalDataMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GlobalDataMessage* other);
  friend void swap(GlobalDataMessage& a, GlobalDataMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GlobalDataMessage* New() const final {
    return CreateMaybeMessage<GlobalDataMessage>(NULL);
  }

  GlobalDataMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GlobalDataMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GlobalDataMessage& from);
  void MergeFrom(const GlobalDataMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalDataMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.GlobalData data = 1;
  int data_size() const;
  void clear_data();
  static const int kDataFieldNumber = 1;
  ::holo::map::adasisv3::GlobalData* mutable_data(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::GlobalData >*
      mutable_data();
  const ::holo::map::adasisv3::GlobalData& data(int index) const;
  ::holo::map::adasisv3::GlobalData* add_data();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::GlobalData >&
      data() const;

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.GlobalDataMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::GlobalData > data_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProfileControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ProfileControl) */ {
 public:
  ProfileControl();
  virtual ~ProfileControl();

  ProfileControl(const ProfileControl& from);

  inline ProfileControl& operator=(const ProfileControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProfileControl(ProfileControl&& from) noexcept
    : ProfileControl() {
    *this = ::std::move(from);
  }

  inline ProfileControl& operator=(ProfileControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfileControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProfileControl* internal_default_instance() {
    return reinterpret_cast<const ProfileControl*>(
               &_ProfileControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ProfileControl* other);
  friend void swap(ProfileControl& a, ProfileControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProfileControl* New() const final {
    return CreateMaybeMessage<ProfileControl>(NULL);
  }

  ProfileControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProfileControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProfileControl& from);
  void MergeFrom(const ProfileControl& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 pathId = 1;
  bool has_pathid() const;
  void clear_pathid();
  static const int kPathIdFieldNumber = 1;
  ::google::protobuf::uint32 pathid() const;
  void set_pathid(::google::protobuf::uint32 value);

  // required uint32 offset = 2;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ProfileControl)
 private:
  void set_has_pathid();
  void clear_has_pathid();
  void set_has_offset();
  void clear_has_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 pathid_;
  ::google::protobuf::uint32 offset_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProfileControlMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ProfileControlMessage) */ {
 public:
  ProfileControlMessage();
  virtual ~ProfileControlMessage();

  ProfileControlMessage(const ProfileControlMessage& from);

  inline ProfileControlMessage& operator=(const ProfileControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProfileControlMessage(ProfileControlMessage&& from) noexcept
    : ProfileControlMessage() {
    *this = ::std::move(from);
  }

  inline ProfileControlMessage& operator=(ProfileControlMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProfileControlMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProfileControlMessage* internal_default_instance() {
    return reinterpret_cast<const ProfileControlMessage*>(
               &_ProfileControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ProfileControlMessage* other);
  friend void swap(ProfileControlMessage& a, ProfileControlMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProfileControlMessage* New() const final {
    return CreateMaybeMessage<ProfileControlMessage>(NULL);
  }

  ProfileControlMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProfileControlMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProfileControlMessage& from);
  void MergeFrom(const ProfileControlMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProfileControlMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.ProfileControl values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  ::holo::map::adasisv3::ProfileControl* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileControl >*
      mutable_values();
  const ::holo::map::adasisv3::ProfileControl& values(int index) const;
  ::holo::map::adasisv3::ProfileControl* add_values();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileControl >&
      values() const;

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ProfileControlMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileControl > values_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathControl : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.PathControl) */ {
 public:
  PathControl();
  virtual ~PathControl();

  PathControl(const PathControl& from);

  inline PathControl& operator=(const PathControl& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathControl(PathControl&& from) noexcept
    : PathControl() {
    *this = ::std::move(from);
  }

  inline PathControl& operator=(PathControl&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathControl& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathControl* internal_default_instance() {
    return reinterpret_cast<const PathControl*>(
               &_PathControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(PathControl* other);
  friend void swap(PathControl& a, PathControl& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathControl* New() const final {
    return CreateMaybeMessage<PathControl>(NULL);
  }

  PathControl* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathControl>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathControl& from);
  void MergeFrom(const PathControl& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathControl* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required uint32 parentId = 2;
  bool has_parentid() const;
  void clear_parentid();
  static const int kParentIdFieldNumber = 2;
  ::google::protobuf::uint32 parentid() const;
  void set_parentid(::google::protobuf::uint32 value);

  // required uint32 offset = 3;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.PathControl)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_parentid();
  void clear_has_parentid();
  void set_has_offset();
  void clear_has_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 parentid_;
  ::google::protobuf::uint32 offset_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PathControlMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.PathControlMessage) */ {
 public:
  PathControlMessage();
  virtual ~PathControlMessage();

  PathControlMessage(const PathControlMessage& from);

  inline PathControlMessage& operator=(const PathControlMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PathControlMessage(PathControlMessage&& from) noexcept
    : PathControlMessage() {
    *this = ::std::move(from);
  }

  inline PathControlMessage& operator=(PathControlMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PathControlMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PathControlMessage* internal_default_instance() {
    return reinterpret_cast<const PathControlMessage*>(
               &_PathControlMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(PathControlMessage* other);
  friend void swap(PathControlMessage& a, PathControlMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PathControlMessage* New() const final {
    return CreateMaybeMessage<PathControlMessage>(NULL);
  }

  PathControlMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PathControlMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PathControlMessage& from);
  void MergeFrom(const PathControlMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PathControlMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.PathControl values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  ::holo::map::adasisv3::PathControl* mutable_values(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::PathControl >*
      mutable_values();
  const ::holo::map::adasisv3::PathControl& values(int index) const;
  ::holo::map::adasisv3::PathControl* add_values();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::PathControl >&
      values() const;

  // required uint32 idFirst = 1;
  bool has_idfirst() const;
  void clear_idfirst();
  static const int kIdFirstFieldNumber = 1;
  ::google::protobuf::uint32 idfirst() const;
  void set_idfirst(::google::protobuf::uint32 value);

  // required uint32 idLast = 2;
  bool has_idlast() const;
  void clear_idlast();
  static const int kIdLastFieldNumber = 2;
  ::google::protobuf::uint32 idlast() const;
  void set_idlast(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.PathControlMessage)
 private:
  void set_has_idfirst();
  void clear_has_idfirst();
  void set_has_idlast();
  void clear_has_idlast();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::PathControl > values_;
  ::google::protobuf::uint32 idfirst_;
  ::google::protobuf::uint32 idlast_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReasonMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ReasonMessage) */ {
 public:
  ReasonMessage();
  virtual ~ReasonMessage();

  ReasonMessage(const ReasonMessage& from);

  inline ReasonMessage& operator=(const ReasonMessage& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReasonMessage(ReasonMessage&& from) noexcept
    : ReasonMessage() {
    *this = ::std::move(from);
  }

  inline ReasonMessage& operator=(ReasonMessage&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReasonMessage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReasonMessage* internal_default_instance() {
    return reinterpret_cast<const ReasonMessage*>(
               &_ReasonMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ReasonMessage* other);
  friend void swap(ReasonMessage& a, ReasonMessage& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReasonMessage* New() const final {
    return CreateMaybeMessage<ReasonMessage>(NULL);
  }

  ReasonMessage* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReasonMessage>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReasonMessage& from);
  void MergeFrom(const ReasonMessage& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReasonMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.ReasonType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::holo::map::adasisv3::ReasonType type() const;
  void set_type(::holo::map::adasisv3::ReasonType value);

  // required uint32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ReasonMessage)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int type_;
  ::google::protobuf::uint32 value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MessageOnBus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.MessageOnBus) */ {
 public:
  MessageOnBus();
  virtual ~MessageOnBus();

  MessageOnBus(const MessageOnBus& from);

  inline MessageOnBus& operator=(const MessageOnBus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MessageOnBus(MessageOnBus&& from) noexcept
    : MessageOnBus() {
    *this = ::std::move(from);
  }

  inline MessageOnBus& operator=(MessageOnBus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageOnBus& default_instance();

  enum MessageCase {
    kPositionMessageMessage = 3,
    kProfileMessageMessage = 4,
    kGlobalDataMessageMessage = 5,
    kProfileControlMessageMessage = 6,
    kPathControlMessageMessage = 7,
    kReasonMessageMessage = 8,
    MESSAGE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MessageOnBus* internal_default_instance() {
    return reinterpret_cast<const MessageOnBus*>(
               &_MessageOnBus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(MessageOnBus* other);
  friend void swap(MessageOnBus& a, MessageOnBus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MessageOnBus* New() const final {
    return CreateMaybeMessage<MessageOnBus>(NULL);
  }

  MessageOnBus* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MessageOnBus>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MessageOnBus& from);
  void MergeFrom(const MessageOnBus& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MessageOnBus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 cyclicCounter = 1;
  bool has_cycliccounter() const;
  void clear_cycliccounter();
  static const int kCyclicCounterFieldNumber = 1;
  ::google::protobuf::uint32 cycliccounter() const;
  void set_cycliccounter(::google::protobuf::uint32 value);

  // required .holo.map.adasisv3.MessageType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::holo::map::adasisv3::MessageType type() const;
  void set_type(::holo::map::adasisv3::MessageType value);

  // optional .holo.map.adasisv3.PositionMessage PositionMessage_message = 3;
  bool has_positionmessage_message() const;
  void clear_positionmessage_message();
  static const int kPositionMessageMessageFieldNumber = 3;
  private:
  const ::holo::map::adasisv3::PositionMessage& _internal_positionmessage_message() const;
  public:
  const ::holo::map::adasisv3::PositionMessage& positionmessage_message() const;
  ::holo::map::adasisv3::PositionMessage* release_positionmessage_message();
  ::holo::map::adasisv3::PositionMessage* mutable_positionmessage_message();
  void set_allocated_positionmessage_message(::holo::map::adasisv3::PositionMessage* positionmessage_message);

  // optional .holo.map.adasisv3.ProfileMessage ProfileMessage_message = 4;
  bool has_profilemessage_message() const;
  void clear_profilemessage_message();
  static const int kProfileMessageMessageFieldNumber = 4;
  private:
  const ::holo::map::adasisv3::ProfileMessage& _internal_profilemessage_message() const;
  public:
  const ::holo::map::adasisv3::ProfileMessage& profilemessage_message() const;
  ::holo::map::adasisv3::ProfileMessage* release_profilemessage_message();
  ::holo::map::adasisv3::ProfileMessage* mutable_profilemessage_message();
  void set_allocated_profilemessage_message(::holo::map::adasisv3::ProfileMessage* profilemessage_message);

  // optional .holo.map.adasisv3.GlobalDataMessage GlobalDataMessage_message = 5;
  bool has_globaldatamessage_message() const;
  void clear_globaldatamessage_message();
  static const int kGlobalDataMessageMessageFieldNumber = 5;
  private:
  const ::holo::map::adasisv3::GlobalDataMessage& _internal_globaldatamessage_message() const;
  public:
  const ::holo::map::adasisv3::GlobalDataMessage& globaldatamessage_message() const;
  ::holo::map::adasisv3::GlobalDataMessage* release_globaldatamessage_message();
  ::holo::map::adasisv3::GlobalDataMessage* mutable_globaldatamessage_message();
  void set_allocated_globaldatamessage_message(::holo::map::adasisv3::GlobalDataMessage* globaldatamessage_message);

  // optional .holo.map.adasisv3.ProfileControlMessage ProfileControlMessage_message = 6;
  bool has_profilecontrolmessage_message() const;
  void clear_profilecontrolmessage_message();
  static const int kProfileControlMessageMessageFieldNumber = 6;
  private:
  const ::holo::map::adasisv3::ProfileControlMessage& _internal_profilecontrolmessage_message() const;
  public:
  const ::holo::map::adasisv3::ProfileControlMessage& profilecontrolmessage_message() const;
  ::holo::map::adasisv3::ProfileControlMessage* release_profilecontrolmessage_message();
  ::holo::map::adasisv3::ProfileControlMessage* mutable_profilecontrolmessage_message();
  void set_allocated_profilecontrolmessage_message(::holo::map::adasisv3::ProfileControlMessage* profilecontrolmessage_message);

  // optional .holo.map.adasisv3.PathControlMessage PathControlMessage_message = 7;
  bool has_pathcontrolmessage_message() const;
  void clear_pathcontrolmessage_message();
  static const int kPathControlMessageMessageFieldNumber = 7;
  private:
  const ::holo::map::adasisv3::PathControlMessage& _internal_pathcontrolmessage_message() const;
  public:
  const ::holo::map::adasisv3::PathControlMessage& pathcontrolmessage_message() const;
  ::holo::map::adasisv3::PathControlMessage* release_pathcontrolmessage_message();
  ::holo::map::adasisv3::PathControlMessage* mutable_pathcontrolmessage_message();
  void set_allocated_pathcontrolmessage_message(::holo::map::adasisv3::PathControlMessage* pathcontrolmessage_message);

  // optional .holo.map.adasisv3.ReasonMessage ReasonMessage_message = 8;
  bool has_reasonmessage_message() const;
  void clear_reasonmessage_message();
  static const int kReasonMessageMessageFieldNumber = 8;
  private:
  const ::holo::map::adasisv3::ReasonMessage& _internal_reasonmessage_message() const;
  public:
  const ::holo::map::adasisv3::ReasonMessage& reasonmessage_message() const;
  ::holo::map::adasisv3::ReasonMessage* release_reasonmessage_message();
  ::holo::map::adasisv3::ReasonMessage* mutable_reasonmessage_message();
  void set_allocated_reasonmessage_message(::holo::map::adasisv3::ReasonMessage* reasonmessage_message);

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.MessageOnBus)
 private:
  void set_has_cycliccounter();
  void clear_has_cycliccounter();
  void set_has_type();
  void clear_has_type();
  void set_has_positionmessage_message();
  void set_has_profilemessage_message();
  void set_has_globaldatamessage_message();
  void set_has_profilecontrolmessage_message();
  void set_has_pathcontrolmessage_message();
  void set_has_reasonmessage_message();

  inline bool has_message() const;
  inline void clear_has_message();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 cycliccounter_;
  int type_;
  union MessageUnion {
    MessageUnion() {}
    ::holo::map::adasisv3::PositionMessage* positionmessage_message_;
    ::holo::map::adasisv3::ProfileMessage* profilemessage_message_;
    ::holo::map::adasisv3::GlobalDataMessage* globaldatamessage_message_;
    ::holo::map::adasisv3::ProfileControlMessage* profilecontrolmessage_message_;
    ::holo::map::adasisv3::PathControlMessage* pathcontrolmessage_message_;
    ::holo::map::adasisv3::ReasonMessage* reasonmessage_message_;
  } message_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UInt32ProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.UInt32ProfileValue) */ {
 public:
  UInt32ProfileValue();
  virtual ~UInt32ProfileValue();

  UInt32ProfileValue(const UInt32ProfileValue& from);

  inline UInt32ProfileValue& operator=(const UInt32ProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInt32ProfileValue(UInt32ProfileValue&& from) noexcept
    : UInt32ProfileValue() {
    *this = ::std::move(from);
  }

  inline UInt32ProfileValue& operator=(UInt32ProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UInt32ProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UInt32ProfileValue* internal_default_instance() {
    return reinterpret_cast<const UInt32ProfileValue*>(
               &_UInt32ProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(UInt32ProfileValue* other);
  friend void swap(UInt32ProfileValue& a, UInt32ProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInt32ProfileValue* New() const final {
    return CreateMaybeMessage<UInt32ProfileValue>(NULL);
  }

  UInt32ProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UInt32ProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UInt32ProfileValue& from);
  void MergeFrom(const UInt32ProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UInt32ProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.UInt32ProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Int32ProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.Int32ProfileValue) */ {
 public:
  Int32ProfileValue();
  virtual ~Int32ProfileValue();

  Int32ProfileValue(const Int32ProfileValue& from);

  inline Int32ProfileValue& operator=(const Int32ProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Int32ProfileValue(Int32ProfileValue&& from) noexcept
    : Int32ProfileValue() {
    *this = ::std::move(from);
  }

  inline Int32ProfileValue& operator=(Int32ProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Int32ProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Int32ProfileValue* internal_default_instance() {
    return reinterpret_cast<const Int32ProfileValue*>(
               &_Int32ProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Int32ProfileValue* other);
  friend void swap(Int32ProfileValue& a, Int32ProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Int32ProfileValue* New() const final {
    return CreateMaybeMessage<Int32ProfileValue>(NULL);
  }

  Int32ProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Int32ProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Int32ProfileValue& from);
  void MergeFrom(const Int32ProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Int32ProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.Int32ProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UInt64ProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.UInt64ProfileValue) */ {
 public:
  UInt64ProfileValue();
  virtual ~UInt64ProfileValue();

  UInt64ProfileValue(const UInt64ProfileValue& from);

  inline UInt64ProfileValue& operator=(const UInt64ProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UInt64ProfileValue(UInt64ProfileValue&& from) noexcept
    : UInt64ProfileValue() {
    *this = ::std::move(from);
  }

  inline UInt64ProfileValue& operator=(UInt64ProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UInt64ProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UInt64ProfileValue* internal_default_instance() {
    return reinterpret_cast<const UInt64ProfileValue*>(
               &_UInt64ProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(UInt64ProfileValue* other);
  friend void swap(UInt64ProfileValue& a, UInt64ProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UInt64ProfileValue* New() const final {
    return CreateMaybeMessage<UInt64ProfileValue>(NULL);
  }

  UInt64ProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UInt64ProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UInt64ProfileValue& from);
  void MergeFrom(const UInt64ProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UInt64ProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint64 value() const;
  void set_value(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.UInt64ProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint64 value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FloatProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.FloatProfileValue) */ {
 public:
  FloatProfileValue();
  virtual ~FloatProfileValue();

  FloatProfileValue(const FloatProfileValue& from);

  inline FloatProfileValue& operator=(const FloatProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatProfileValue(FloatProfileValue&& from) noexcept
    : FloatProfileValue() {
    *this = ::std::move(from);
  }

  inline FloatProfileValue& operator=(FloatProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatProfileValue* internal_default_instance() {
    return reinterpret_cast<const FloatProfileValue*>(
               &_FloatProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(FloatProfileValue* other);
  friend void swap(FloatProfileValue& a, FloatProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatProfileValue* New() const final {
    return CreateMaybeMessage<FloatProfileValue>(NULL);
  }

  FloatProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatProfileValue& from);
  void MergeFrom(const FloatProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.FloatProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BooleanProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.BooleanProfileValue) */ {
 public:
  BooleanProfileValue();
  virtual ~BooleanProfileValue();

  BooleanProfileValue(const BooleanProfileValue& from);

  inline BooleanProfileValue& operator=(const BooleanProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BooleanProfileValue(BooleanProfileValue&& from) noexcept
    : BooleanProfileValue() {
    *this = ::std::move(from);
  }

  inline BooleanProfileValue& operator=(BooleanProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BooleanProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BooleanProfileValue* internal_default_instance() {
    return reinterpret_cast<const BooleanProfileValue*>(
               &_BooleanProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(BooleanProfileValue* other);
  friend void swap(BooleanProfileValue& a, BooleanProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BooleanProfileValue* New() const final {
    return CreateMaybeMessage<BooleanProfileValue>(NULL);
  }

  BooleanProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BooleanProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BooleanProfileValue& from);
  void MergeFrom(const BooleanProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BooleanProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  bool value() const;
  void set_value(bool value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.BooleanProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class YesNoUnknownProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.YesNoUnknownProfileValue) */ {
 public:
  YesNoUnknownProfileValue();
  virtual ~YesNoUnknownProfileValue();

  YesNoUnknownProfileValue(const YesNoUnknownProfileValue& from);

  inline YesNoUnknownProfileValue& operator=(const YesNoUnknownProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  YesNoUnknownProfileValue(YesNoUnknownProfileValue&& from) noexcept
    : YesNoUnknownProfileValue() {
    *this = ::std::move(from);
  }

  inline YesNoUnknownProfileValue& operator=(YesNoUnknownProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YesNoUnknownProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const YesNoUnknownProfileValue* internal_default_instance() {
    return reinterpret_cast<const YesNoUnknownProfileValue*>(
               &_YesNoUnknownProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(YesNoUnknownProfileValue* other);
  friend void swap(YesNoUnknownProfileValue& a, YesNoUnknownProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline YesNoUnknownProfileValue* New() const final {
    return CreateMaybeMessage<YesNoUnknownProfileValue>(NULL);
  }

  YesNoUnknownProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<YesNoUnknownProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const YesNoUnknownProfileValue& from);
  void MergeFrom(const YesNoUnknownProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(YesNoUnknownProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.YesNoUnknown value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::YesNoUnknown value() const;
  void set_value(::holo::map::adasisv3::YesNoUnknown value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.YesNoUnknownProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FormOfWayProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.FormOfWayProfileValue) */ {
 public:
  FormOfWayProfileValue();
  virtual ~FormOfWayProfileValue();

  FormOfWayProfileValue(const FormOfWayProfileValue& from);

  inline FormOfWayProfileValue& operator=(const FormOfWayProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FormOfWayProfileValue(FormOfWayProfileValue&& from) noexcept
    : FormOfWayProfileValue() {
    *this = ::std::move(from);
  }

  inline FormOfWayProfileValue& operator=(FormOfWayProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FormOfWayProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FormOfWayProfileValue* internal_default_instance() {
    return reinterpret_cast<const FormOfWayProfileValue*>(
               &_FormOfWayProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(FormOfWayProfileValue* other);
  friend void swap(FormOfWayProfileValue& a, FormOfWayProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FormOfWayProfileValue* New() const final {
    return CreateMaybeMessage<FormOfWayProfileValue>(NULL);
  }

  FormOfWayProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FormOfWayProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FormOfWayProfileValue& from);
  void MergeFrom(const FormOfWayProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FormOfWayProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.FormOfWay value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::FormOfWay value() const;
  void set_value(::holo::map::adasisv3::FormOfWay value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.FormOfWayProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DrivingSideProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.DrivingSideProfileValue) */ {
 public:
  DrivingSideProfileValue();
  virtual ~DrivingSideProfileValue();

  DrivingSideProfileValue(const DrivingSideProfileValue& from);

  inline DrivingSideProfileValue& operator=(const DrivingSideProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DrivingSideProfileValue(DrivingSideProfileValue&& from) noexcept
    : DrivingSideProfileValue() {
    *this = ::std::move(from);
  }

  inline DrivingSideProfileValue& operator=(DrivingSideProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DrivingSideProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DrivingSideProfileValue* internal_default_instance() {
    return reinterpret_cast<const DrivingSideProfileValue*>(
               &_DrivingSideProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(DrivingSideProfileValue* other);
  friend void swap(DrivingSideProfileValue& a, DrivingSideProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DrivingSideProfileValue* New() const final {
    return CreateMaybeMessage<DrivingSideProfileValue>(NULL);
  }

  DrivingSideProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DrivingSideProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DrivingSideProfileValue& from);
  void MergeFrom(const DrivingSideProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrivingSideProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.DrivingSide value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::DrivingSide value() const;
  void set_value(::holo::map::adasisv3::DrivingSide value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.DrivingSideProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UnitSystemProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.UnitSystemProfileValue) */ {
 public:
  UnitSystemProfileValue();
  virtual ~UnitSystemProfileValue();

  UnitSystemProfileValue(const UnitSystemProfileValue& from);

  inline UnitSystemProfileValue& operator=(const UnitSystemProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnitSystemProfileValue(UnitSystemProfileValue&& from) noexcept
    : UnitSystemProfileValue() {
    *this = ::std::move(from);
  }

  inline UnitSystemProfileValue& operator=(UnitSystemProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UnitSystemProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnitSystemProfileValue* internal_default_instance() {
    return reinterpret_cast<const UnitSystemProfileValue*>(
               &_UnitSystemProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(UnitSystemProfileValue* other);
  friend void swap(UnitSystemProfileValue& a, UnitSystemProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnitSystemProfileValue* New() const final {
    return CreateMaybeMessage<UnitSystemProfileValue>(NULL);
  }

  UnitSystemProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UnitSystemProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UnitSystemProfileValue& from);
  void MergeFrom(const UnitSystemProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UnitSystemProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.UnitOfSystem value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::UnitOfSystem value() const;
  void set_value(::holo::map::adasisv3::UnitOfSystem value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.UnitSystemProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpecialSituationProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.SpecialSituationProfileValue) */ {
 public:
  SpecialSituationProfileValue();
  virtual ~SpecialSituationProfileValue();

  SpecialSituationProfileValue(const SpecialSituationProfileValue& from);

  inline SpecialSituationProfileValue& operator=(const SpecialSituationProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpecialSituationProfileValue(SpecialSituationProfileValue&& from) noexcept
    : SpecialSituationProfileValue() {
    *this = ::std::move(from);
  }

  inline SpecialSituationProfileValue& operator=(SpecialSituationProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpecialSituationProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpecialSituationProfileValue* internal_default_instance() {
    return reinterpret_cast<const SpecialSituationProfileValue*>(
               &_SpecialSituationProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(SpecialSituationProfileValue* other);
  friend void swap(SpecialSituationProfileValue& a, SpecialSituationProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpecialSituationProfileValue* New() const final {
    return CreateMaybeMessage<SpecialSituationProfileValue>(NULL);
  }

  SpecialSituationProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpecialSituationProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpecialSituationProfileValue& from);
  void MergeFrom(const SpecialSituationProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpecialSituationProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.SpecialSituationType value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::SpecialSituationType value() const;
  void set_value(::holo::map::adasisv3::SpecialSituationType value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.SpecialSituationProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadConditionProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.RoadConditionProfileValue) */ {
 public:
  RoadConditionProfileValue();
  virtual ~RoadConditionProfileValue();

  RoadConditionProfileValue(const RoadConditionProfileValue& from);

  inline RoadConditionProfileValue& operator=(const RoadConditionProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadConditionProfileValue(RoadConditionProfileValue&& from) noexcept
    : RoadConditionProfileValue() {
    *this = ::std::move(from);
  }

  inline RoadConditionProfileValue& operator=(RoadConditionProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadConditionProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadConditionProfileValue* internal_default_instance() {
    return reinterpret_cast<const RoadConditionProfileValue*>(
               &_RoadConditionProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(RoadConditionProfileValue* other);
  friend void swap(RoadConditionProfileValue& a, RoadConditionProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadConditionProfileValue* New() const final {
    return CreateMaybeMessage<RoadConditionProfileValue>(NULL);
  }

  RoadConditionProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadConditionProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadConditionProfileValue& from);
  void MergeFrom(const RoadConditionProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadConditionProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.RoadCondition value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::RoadCondition value() const;
  void set_value(::holo::map::adasisv3::RoadCondition value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.RoadConditionProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WeatherProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.WeatherProfileValue) */ {
 public:
  WeatherProfileValue();
  virtual ~WeatherProfileValue();

  WeatherProfileValue(const WeatherProfileValue& from);

  inline WeatherProfileValue& operator=(const WeatherProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WeatherProfileValue(WeatherProfileValue&& from) noexcept
    : WeatherProfileValue() {
    *this = ::std::move(from);
  }

  inline WeatherProfileValue& operator=(WeatherProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeatherProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WeatherProfileValue* internal_default_instance() {
    return reinterpret_cast<const WeatherProfileValue*>(
               &_WeatherProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(WeatherProfileValue* other);
  friend void swap(WeatherProfileValue& a, WeatherProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WeatherProfileValue* New() const final {
    return CreateMaybeMessage<WeatherProfileValue>(NULL);
  }

  WeatherProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WeatherProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WeatherProfileValue& from);
  void MergeFrom(const WeatherProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WeatherProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.WeatherRedefine value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::WeatherRedefine value() const;
  void set_value(::holo::map::adasisv3::WeatherRedefine value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.WeatherProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapProviderProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.MapProviderProfileValue) */ {
 public:
  MapProviderProfileValue();
  virtual ~MapProviderProfileValue();

  MapProviderProfileValue(const MapProviderProfileValue& from);

  inline MapProviderProfileValue& operator=(const MapProviderProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapProviderProfileValue(MapProviderProfileValue&& from) noexcept
    : MapProviderProfileValue() {
    *this = ::std::move(from);
  }

  inline MapProviderProfileValue& operator=(MapProviderProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapProviderProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapProviderProfileValue* internal_default_instance() {
    return reinterpret_cast<const MapProviderProfileValue*>(
               &_MapProviderProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(MapProviderProfileValue* other);
  friend void swap(MapProviderProfileValue& a, MapProviderProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapProviderProfileValue* New() const final {
    return CreateMaybeMessage<MapProviderProfileValue>(NULL);
  }

  MapProviderProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapProviderProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapProviderProfileValue& from);
  void MergeFrom(const MapProviderProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapProviderProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.MapProvider value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::MapProvider value() const;
  void set_value(::holo::map::adasisv3::MapProvider value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.MapProviderProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MapStatusProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.MapStatusProfileValue) */ {
 public:
  MapStatusProfileValue();
  virtual ~MapStatusProfileValue();

  MapStatusProfileValue(const MapStatusProfileValue& from);

  inline MapStatusProfileValue& operator=(const MapStatusProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MapStatusProfileValue(MapStatusProfileValue&& from) noexcept
    : MapStatusProfileValue() {
    *this = ::std::move(from);
  }

  inline MapStatusProfileValue& operator=(MapStatusProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapStatusProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MapStatusProfileValue* internal_default_instance() {
    return reinterpret_cast<const MapStatusProfileValue*>(
               &_MapStatusProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(MapStatusProfileValue* other);
  friend void swap(MapStatusProfileValue& a, MapStatusProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MapStatusProfileValue* New() const final {
    return CreateMaybeMessage<MapStatusProfileValue>(NULL);
  }

  MapStatusProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MapStatusProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MapStatusProfileValue& from);
  void MergeFrom(const MapStatusProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MapStatusProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.MapStatus value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::MapStatus value() const;
  void set_value(::holo::map::adasisv3::MapStatus value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.MapStatusProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OffsetFloatEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.OffsetFloatEntry) */ {
 public:
  OffsetFloatEntry();
  virtual ~OffsetFloatEntry();

  OffsetFloatEntry(const OffsetFloatEntry& from);

  inline OffsetFloatEntry& operator=(const OffsetFloatEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OffsetFloatEntry(OffsetFloatEntry&& from) noexcept
    : OffsetFloatEntry() {
    *this = ::std::move(from);
  }

  inline OffsetFloatEntry& operator=(OffsetFloatEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OffsetFloatEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OffsetFloatEntry* internal_default_instance() {
    return reinterpret_cast<const OffsetFloatEntry*>(
               &_OffsetFloatEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(OffsetFloatEntry* other);
  friend void swap(OffsetFloatEntry& a, OffsetFloatEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OffsetFloatEntry* New() const final {
    return CreateMaybeMessage<OffsetFloatEntry>(NULL);
  }

  OffsetFloatEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OffsetFloatEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OffsetFloatEntry& from);
  void MergeFrom(const OffsetFloatEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OffsetFloatEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 offset = 1;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 1;
  ::google::protobuf::uint32 offset() const;
  void set_offset(::google::protobuf::uint32 value);

  // required float value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.OffsetFloatEntry)
 private:
  void set_has_offset();
  void clear_has_offset();
  void set_has_value();
  void clear_has_value();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 offset_;
  float value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OffsetFloatProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.OffsetFloatProfileValue) */ {
 public:
  OffsetFloatProfileValue();
  virtual ~OffsetFloatProfileValue();

  OffsetFloatProfileValue(const OffsetFloatProfileValue& from);

  inline OffsetFloatProfileValue& operator=(const OffsetFloatProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OffsetFloatProfileValue(OffsetFloatProfileValue&& from) noexcept
    : OffsetFloatProfileValue() {
    *this = ::std::move(from);
  }

  inline OffsetFloatProfileValue& operator=(OffsetFloatProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OffsetFloatProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OffsetFloatProfileValue* internal_default_instance() {
    return reinterpret_cast<const OffsetFloatProfileValue*>(
               &_OffsetFloatProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(OffsetFloatProfileValue* other);
  friend void swap(OffsetFloatProfileValue& a, OffsetFloatProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OffsetFloatProfileValue* New() const final {
    return CreateMaybeMessage<OffsetFloatProfileValue>(NULL);
  }

  OffsetFloatProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OffsetFloatProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OffsetFloatProfileValue& from);
  void MergeFrom(const OffsetFloatProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OffsetFloatProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.OffsetFloatEntry entries = 1;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 1;
  ::holo::map::adasisv3::OffsetFloatEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OffsetFloatEntry >*
      mutable_entries();
  const ::holo::map::adasisv3::OffsetFloatEntry& entries(int index) const;
  ::holo::map::adasisv3::OffsetFloatEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OffsetFloatEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.OffsetFloatProfileValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OffsetFloatEntry > entries_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeArm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.NodeArm) */ {
 public:
  NodeArm();
  virtual ~NodeArm();

  NodeArm(const NodeArm& from);

  inline NodeArm& operator=(const NodeArm& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeArm(NodeArm&& from) noexcept
    : NodeArm() {
    *this = ::std::move(from);
  }

  inline NodeArm& operator=(NodeArm&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeArm& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeArm* internal_default_instance() {
    return reinterpret_cast<const NodeArm*>(
               &_NodeArm_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(NodeArm* other);
  friend void swap(NodeArm& a, NodeArm& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeArm* New() const final {
    return CreateMaybeMessage<NodeArm>(NULL);
  }

  NodeArm* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeArm>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeArm& from);
  void MergeFrom(const NodeArm& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeArm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 subPath = 1;
  bool has_subpath() const;
  void clear_subpath();
  static const int kSubPathFieldNumber = 1;
  ::google::protobuf::uint32 subpath() const;
  void set_subpath(::google::protobuf::uint32 value);

  // required float probability = 2;
  bool has_probability() const;
  void clear_probability();
  static const int kProbabilityFieldNumber = 2;
  float probability() const;
  void set_probability(float value);

  // required float turnAngle = 3;
  bool has_turnangle() const;
  void clear_turnangle();
  static const int kTurnAngleFieldNumber = 3;
  float turnangle() const;
  void set_turnangle(float value);

  // required bool isComplexIntersection = 4;
  bool has_iscomplexintersection() const;
  void clear_iscomplexintersection();
  static const int kIsComplexIntersectionFieldNumber = 4;
  bool iscomplexintersection() const;
  void set_iscomplexintersection(bool value);

  // required .holo.map.adasisv3.RightOfWay rightOfWay = 5;
  bool has_rightofway() const;
  void clear_rightofway();
  static const int kRightOfWayFieldNumber = 5;
  ::holo::map::adasisv3::RightOfWay rightofway() const;
  void set_rightofway(::holo::map::adasisv3::RightOfWay value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.NodeArm)
 private:
  void set_has_subpath();
  void clear_has_subpath();
  void set_has_probability();
  void clear_has_probability();
  void set_has_turnangle();
  void clear_has_turnangle();
  void set_has_iscomplexintersection();
  void clear_has_iscomplexintersection();
  void set_has_rightofway();
  void clear_has_rightofway();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 subpath_;
  float probability_;
  float turnangle_;
  bool iscomplexintersection_;
  int rightofway_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class NodeProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.NodeProfileValue) */ {
 public:
  NodeProfileValue();
  virtual ~NodeProfileValue();

  NodeProfileValue(const NodeProfileValue& from);

  inline NodeProfileValue& operator=(const NodeProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeProfileValue(NodeProfileValue&& from) noexcept
    : NodeProfileValue() {
    *this = ::std::move(from);
  }

  inline NodeProfileValue& operator=(NodeProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NodeProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeProfileValue* internal_default_instance() {
    return reinterpret_cast<const NodeProfileValue*>(
               &_NodeProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(NodeProfileValue* other);
  friend void swap(NodeProfileValue& a, NodeProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeProfileValue* New() const final {
    return CreateMaybeMessage<NodeProfileValue>(NULL);
  }

  NodeProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeProfileValue& from);
  void MergeFrom(const NodeProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.NodeArm arms = 1;
  int arms_size() const;
  void clear_arms();
  static const int kArmsFieldNumber = 1;
  ::holo::map::adasisv3::NodeArm* mutable_arms(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::NodeArm >*
      mutable_arms();
  const ::holo::map::adasisv3::NodeArm& arms(int index) const;
  ::holo::map::adasisv3::NodeArm* add_arms();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::NodeArm >&
      arms() const;

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.NodeProfileValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::NodeArm > arms_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemStatusProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.SystemStatusProfileValue) */ {
 public:
  SystemStatusProfileValue();
  virtual ~SystemStatusProfileValue();

  SystemStatusProfileValue(const SystemStatusProfileValue& from);

  inline SystemStatusProfileValue& operator=(const SystemStatusProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SystemStatusProfileValue(SystemStatusProfileValue&& from) noexcept
    : SystemStatusProfileValue() {
    *this = ::std::move(from);
  }

  inline SystemStatusProfileValue& operator=(SystemStatusProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemStatusProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SystemStatusProfileValue* internal_default_instance() {
    return reinterpret_cast<const SystemStatusProfileValue*>(
               &_SystemStatusProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(SystemStatusProfileValue* other);
  friend void swap(SystemStatusProfileValue& a, SystemStatusProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SystemStatusProfileValue* New() const final {
    return CreateMaybeMessage<SystemStatusProfileValue>(NULL);
  }

  SystemStatusProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SystemStatusProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SystemStatusProfileValue& from);
  void MergeFrom(const SystemStatusProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SystemStatusProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool simulating = 2;
  bool has_simulating() const;
  void clear_simulating();
  static const int kSimulatingFieldNumber = 2;
  bool simulating() const;
  void set_simulating(bool value);

  // required .holo.map.adasisv3.GuidanceMode guidance = 1;
  bool has_guidance() const;
  void clear_guidance();
  static const int kGuidanceFieldNumber = 1;
  ::holo::map::adasisv3::GuidanceMode guidance() const;
  void set_guidance(::holo::map::adasisv3::GuidanceMode value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.SystemStatusProfileValue)
 private:
  void set_has_guidance();
  void clear_has_guidance();
  void set_has_simulating();
  void clear_has_simulating();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool simulating_;
  int guidance_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AbsoluteVehiclePositionProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.AbsoluteVehiclePositionProfileValue) */ {
 public:
  AbsoluteVehiclePositionProfileValue();
  virtual ~AbsoluteVehiclePositionProfileValue();

  AbsoluteVehiclePositionProfileValue(const AbsoluteVehiclePositionProfileValue& from);

  inline AbsoluteVehiclePositionProfileValue& operator=(const AbsoluteVehiclePositionProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AbsoluteVehiclePositionProfileValue(AbsoluteVehiclePositionProfileValue&& from) noexcept
    : AbsoluteVehiclePositionProfileValue() {
    *this = ::std::move(from);
  }

  inline AbsoluteVehiclePositionProfileValue& operator=(AbsoluteVehiclePositionProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AbsoluteVehiclePositionProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AbsoluteVehiclePositionProfileValue* internal_default_instance() {
    return reinterpret_cast<const AbsoluteVehiclePositionProfileValue*>(
               &_AbsoluteVehiclePositionProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(AbsoluteVehiclePositionProfileValue* other);
  friend void swap(AbsoluteVehiclePositionProfileValue& a, AbsoluteVehiclePositionProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AbsoluteVehiclePositionProfileValue* New() const final {
    return CreateMaybeMessage<AbsoluteVehiclePositionProfileValue>(NULL);
  }

  AbsoluteVehiclePositionProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AbsoluteVehiclePositionProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AbsoluteVehiclePositionProfileValue& from);
  void MergeFrom(const AbsoluteVehiclePositionProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AbsoluteVehiclePositionProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.VehiclePosition position = 1;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 1;
  private:
  const ::holo::map::adasisv3::VehiclePosition& _internal_position() const;
  public:
  const ::holo::map::adasisv3::VehiclePosition& position() const;
  ::holo::map::adasisv3::VehiclePosition* release_position();
  ::holo::map::adasisv3::VehiclePosition* mutable_position();
  void set_allocated_position(::holo::map::adasisv3::VehiclePosition* position);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.AbsoluteVehiclePositionProfileValue)
 private:
  void set_has_position();
  void clear_has_position();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::map::adasisv3::VehiclePosition* position_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SurfaceConditionProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.SurfaceConditionProfileValue) */ {
 public:
  SurfaceConditionProfileValue();
  virtual ~SurfaceConditionProfileValue();

  SurfaceConditionProfileValue(const SurfaceConditionProfileValue& from);

  inline SurfaceConditionProfileValue& operator=(const SurfaceConditionProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SurfaceConditionProfileValue(SurfaceConditionProfileValue&& from) noexcept
    : SurfaceConditionProfileValue() {
    *this = ::std::move(from);
  }

  inline SurfaceConditionProfileValue& operator=(SurfaceConditionProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SurfaceConditionProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SurfaceConditionProfileValue* internal_default_instance() {
    return reinterpret_cast<const SurfaceConditionProfileValue*>(
               &_SurfaceConditionProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(SurfaceConditionProfileValue* other);
  friend void swap(SurfaceConditionProfileValue& a, SurfaceConditionProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SurfaceConditionProfileValue* New() const final {
    return CreateMaybeMessage<SurfaceConditionProfileValue>(NULL);
  }

  SurfaceConditionProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SurfaceConditionProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SurfaceConditionProfileValue& from);
  void MergeFrom(const SurfaceConditionProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SurfaceConditionProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.Quality general = 1;
  bool has_general() const;
  void clear_general();
  static const int kGeneralFieldNumber = 1;
  ::holo::map::adasisv3::Quality general() const;
  void set_general(::holo::map::adasisv3::Quality value);

  // required .holo.map.adasisv3.SurfaceCondition surface = 2;
  bool has_surface() const;
  void clear_surface();
  static const int kSurfaceFieldNumber = 2;
  ::holo::map::adasisv3::SurfaceCondition surface() const;
  void set_surface(::holo::map::adasisv3::SurfaceCondition value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.SurfaceConditionProfileValue)
 private:
  void set_has_general();
  void clear_has_general();
  void set_has_surface();
  void clear_has_surface();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int general_;
  int surface_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SpeedProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.SpeedProfileValue) */ {
 public:
  SpeedProfileValue();
  virtual ~SpeedProfileValue();

  SpeedProfileValue(const SpeedProfileValue& from);

  inline SpeedProfileValue& operator=(const SpeedProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SpeedProfileValue(SpeedProfileValue&& from) noexcept
    : SpeedProfileValue() {
    *this = ::std::move(from);
  }

  inline SpeedProfileValue& operator=(SpeedProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SpeedProfileValue* internal_default_instance() {
    return reinterpret_cast<const SpeedProfileValue*>(
               &_SpeedProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(SpeedProfileValue* other);
  friend void swap(SpeedProfileValue& a, SpeedProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SpeedProfileValue* New() const final {
    return CreateMaybeMessage<SpeedProfileValue>(NULL);
  }

  SpeedProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SpeedProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SpeedProfileValue& from);
  void MergeFrom(const SpeedProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.Speed value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  private:
  const ::holo::map::adasisv3::Speed& _internal_value() const;
  public:
  const ::holo::map::adasisv3::Speed& value() const;
  ::holo::map::adasisv3::Speed* release_value();
  ::holo::map::adasisv3::Speed* mutable_value();
  void set_allocated_value(::holo::map::adasisv3::Speed* value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.SpeedProfileValue)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::map::adasisv3::Speed* value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LaneInfo) */ {
 public:
  LaneInfo();
  virtual ~LaneInfo();

  LaneInfo(const LaneInfo& from);

  inline LaneInfo& operator=(const LaneInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneInfo(LaneInfo&& from) noexcept
    : LaneInfo() {
    *this = ::std::move(from);
  }

  inline LaneInfo& operator=(LaneInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneInfo* internal_default_instance() {
    return reinterpret_cast<const LaneInfo*>(
               &_LaneInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(LaneInfo* other);
  friend void swap(LaneInfo& a, LaneInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneInfo* New() const final {
    return CreateMaybeMessage<LaneInfo>(NULL);
  }

  LaneInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneInfo& from);
  void MergeFrom(const LaneInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 laneNumber = 1;
  bool has_lanenumber() const;
  void clear_lanenumber();
  static const int kLaneNumberFieldNumber = 1;
  ::google::protobuf::uint32 lanenumber() const;
  void set_lanenumber(::google::protobuf::uint32 value);

  // required .holo.map.adasisv3.RelativeDirection direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  ::holo::map::adasisv3::RelativeDirection direction() const;
  void set_direction(::holo::map::adasisv3::RelativeDirection value);

  // required uint64 types = 4;
  bool has_types() const;
  void clear_types();
  static const int kTypesFieldNumber = 4;
  ::google::protobuf::uint64 types() const;
  void set_types(::google::protobuf::uint64 value);

  // required .holo.map.adasisv3.LaneTransition transition = 3;
  bool has_transition() const;
  void clear_transition();
  static const int kTransitionFieldNumber = 3;
  ::holo::map::adasisv3::LaneTransition transition() const;
  void set_transition(::holo::map::adasisv3::LaneTransition value);

  // required uint32 centerline = 5;
  bool has_centerline() const;
  void clear_centerline();
  static const int kCenterlineFieldNumber = 5;
  ::google::protobuf::uint32 centerline() const;
  void set_centerline(::google::protobuf::uint32 value);

  // required uint32 leftBoundary = 6;
  bool has_leftboundary() const;
  void clear_leftboundary();
  static const int kLeftBoundaryFieldNumber = 6;
  ::google::protobuf::uint32 leftboundary() const;
  void set_leftboundary(::google::protobuf::uint32 value);

  // required uint32 rightBoundary = 7;
  bool has_rightboundary() const;
  void clear_rightboundary();
  static const int kRightBoundaryFieldNumber = 7;
  ::google::protobuf::uint32 rightboundary() const;
  void set_rightboundary(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LaneInfo)
 private:
  void set_has_lanenumber();
  void clear_has_lanenumber();
  void set_has_direction();
  void clear_has_direction();
  void set_has_transition();
  void clear_has_transition();
  void set_has_types();
  void clear_has_types();
  void set_has_centerline();
  void clear_has_centerline();
  void set_has_leftboundary();
  void clear_has_leftboundary();
  void set_has_rightboundary();
  void clear_has_rightboundary();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 lanenumber_;
  int direction_;
  ::google::protobuf::uint64 types_;
  int transition_;
  ::google::protobuf::uint32 centerline_;
  ::google::protobuf::uint32 leftboundary_;
  ::google::protobuf::uint32 rightboundary_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneModelValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LaneModelValue) */ {
 public:
  LaneModelValue();
  virtual ~LaneModelValue();

  LaneModelValue(const LaneModelValue& from);

  inline LaneModelValue& operator=(const LaneModelValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneModelValue(LaneModelValue&& from) noexcept
    : LaneModelValue() {
    *this = ::std::move(from);
  }

  inline LaneModelValue& operator=(LaneModelValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneModelValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneModelValue* internal_default_instance() {
    return reinterpret_cast<const LaneModelValue*>(
               &_LaneModelValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(LaneModelValue* other);
  friend void swap(LaneModelValue& a, LaneModelValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneModelValue* New() const final {
    return CreateMaybeMessage<LaneModelValue>(NULL);
  }

  LaneModelValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneModelValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneModelValue& from);
  void MergeFrom(const LaneModelValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneModelValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.LaneInfo laneInfos = 2;
  int laneinfos_size() const;
  void clear_laneinfos();
  static const int kLaneInfosFieldNumber = 2;
  ::holo::map::adasisv3::LaneInfo* mutable_laneinfos(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneInfo >*
      mutable_laneinfos();
  const ::holo::map::adasisv3::LaneInfo& laneinfos(int index) const;
  ::holo::map::adasisv3::LaneInfo* add_laneinfos();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneInfo >&
      laneinfos() const;

  // required uint32 totalNumberOfLanes = 1;
  bool has_totalnumberoflanes() const;
  void clear_totalnumberoflanes();
  static const int kTotalNumberOfLanesFieldNumber = 1;
  ::google::protobuf::uint32 totalnumberoflanes() const;
  void set_totalnumberoflanes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LaneModelValue)
 private:
  void set_has_totalnumberoflanes();
  void clear_has_totalnumberoflanes();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneInfo > laneinfos_;
  ::google::protobuf::uint32 totalnumberoflanes_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneConnectivityPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LaneConnectivityPair) */ {
 public:
  LaneConnectivityPair();
  virtual ~LaneConnectivityPair();

  LaneConnectivityPair(const LaneConnectivityPair& from);

  inline LaneConnectivityPair& operator=(const LaneConnectivityPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneConnectivityPair(LaneConnectivityPair&& from) noexcept
    : LaneConnectivityPair() {
    *this = ::std::move(from);
  }

  inline LaneConnectivityPair& operator=(LaneConnectivityPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneConnectivityPair& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneConnectivityPair* internal_default_instance() {
    return reinterpret_cast<const LaneConnectivityPair*>(
               &_LaneConnectivityPair_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(LaneConnectivityPair* other);
  friend void swap(LaneConnectivityPair& a, LaneConnectivityPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneConnectivityPair* New() const final {
    return CreateMaybeMessage<LaneConnectivityPair>(NULL);
  }

  LaneConnectivityPair* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneConnectivityPair>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneConnectivityPair& from);
  void MergeFrom(const LaneConnectivityPair& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneConnectivityPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 initialLaneNumber = 1;
  bool has_initiallanenumber() const;
  void clear_initiallanenumber();
  static const int kInitialLaneNumberFieldNumber = 1;
  ::google::protobuf::uint32 initiallanenumber() const;
  void set_initiallanenumber(::google::protobuf::uint32 value);

  // required uint32 initialPath = 2;
  bool has_initialpath() const;
  void clear_initialpath();
  static const int kInitialPathFieldNumber = 2;
  ::google::protobuf::uint32 initialpath() const;
  void set_initialpath(::google::protobuf::uint32 value);

  // required uint32 newLaneNumber = 3;
  bool has_newlanenumber() const;
  void clear_newlanenumber();
  static const int kNewLaneNumberFieldNumber = 3;
  ::google::protobuf::uint32 newlanenumber() const;
  void set_newlanenumber(::google::protobuf::uint32 value);

  // required uint32 newPath = 4;
  bool has_newpath() const;
  void clear_newpath();
  static const int kNewPathFieldNumber = 4;
  ::google::protobuf::uint32 newpath() const;
  void set_newpath(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LaneConnectivityPair)
 private:
  void set_has_initiallanenumber();
  void clear_has_initiallanenumber();
  void set_has_initialpath();
  void clear_has_initialpath();
  void set_has_newlanenumber();
  void clear_has_newlanenumber();
  void set_has_newpath();
  void clear_has_newpath();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 initiallanenumber_;
  ::google::protobuf::uint32 initialpath_;
  ::google::protobuf::uint32 newlanenumber_;
  ::google::protobuf::uint32 newpath_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LaneConnectivityValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LaneConnectivityValue) */ {
 public:
  LaneConnectivityValue();
  virtual ~LaneConnectivityValue();

  LaneConnectivityValue(const LaneConnectivityValue& from);

  inline LaneConnectivityValue& operator=(const LaneConnectivityValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneConnectivityValue(LaneConnectivityValue&& from) noexcept
    : LaneConnectivityValue() {
    *this = ::std::move(from);
  }

  inline LaneConnectivityValue& operator=(LaneConnectivityValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneConnectivityValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneConnectivityValue* internal_default_instance() {
    return reinterpret_cast<const LaneConnectivityValue*>(
               &_LaneConnectivityValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(LaneConnectivityValue* other);
  friend void swap(LaneConnectivityValue& a, LaneConnectivityValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneConnectivityValue* New() const final {
    return CreateMaybeMessage<LaneConnectivityValue>(NULL);
  }

  LaneConnectivityValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneConnectivityValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneConnectivityValue& from);
  void MergeFrom(const LaneConnectivityValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneConnectivityValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.LaneConnectivityPair connectivityPairs = 1;
  int connectivitypairs_size() const;
  void clear_connectivitypairs();
  static const int kConnectivityPairsFieldNumber = 1;
  ::holo::map::adasisv3::LaneConnectivityPair* mutable_connectivitypairs(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneConnectivityPair >*
      mutable_connectivitypairs();
  const ::holo::map::adasisv3::LaneConnectivityPair& connectivitypairs(int index) const;
  ::holo::map::adasisv3::LaneConnectivityPair* add_connectivitypairs();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneConnectivityPair >&
      connectivitypairs() const;

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LaneConnectivityValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneConnectivityPair > connectivitypairs_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinearObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LinearObject) */ {
 public:
  LinearObject();
  virtual ~LinearObject();

  LinearObject(const LinearObject& from);

  inline LinearObject& operator=(const LinearObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinearObject(LinearObject&& from) noexcept
    : LinearObject() {
    *this = ::std::move(from);
  }

  inline LinearObject& operator=(LinearObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinearObject* internal_default_instance() {
    return reinterpret_cast<const LinearObject*>(
               &_LinearObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(LinearObject* other);
  friend void swap(LinearObject& a, LinearObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinearObject* New() const final {
    return CreateMaybeMessage<LinearObject>(NULL);
  }

  LinearObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LinearObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LinearObject& from);
  void MergeFrom(const LinearObject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required .holo.map.adasisv3.LinearObjectConfidence confidence = 2;
  bool has_confidence() const;
  void clear_confidence();
  static const int kConfidenceFieldNumber = 2;
  ::holo::map::adasisv3::LinearObjectConfidence confidence() const;
  void set_confidence(::holo::map::adasisv3::LinearObjectConfidence value);

  // required .holo.map.adasisv3.LinearObjectType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::holo::map::adasisv3::LinearObjectType type() const;
  void set_type(::holo::map::adasisv3::LinearObjectType value);

  // required .holo.map.adasisv3.LineMarking marking = 4;
  bool has_marking() const;
  void clear_marking();
  static const int kMarkingFieldNumber = 4;
  ::holo::map::adasisv3::LineMarking marking() const;
  void set_marking(::holo::map::adasisv3::LineMarking value);

  // required .holo.map.adasisv3.LineMarkingColour colour = 5;
  bool has_colour() const;
  void clear_colour();
  static const int kColourFieldNumber = 5;
  ::holo::map::adasisv3::LineMarkingColour colour() const;
  void set_colour(::holo::map::adasisv3::LineMarkingColour value);

  // required bool ldm = 6;
  bool has_ldm() const;
  void clear_ldm();
  static const int kLdmFieldNumber = 6;
  bool ldm() const;
  void set_ldm(bool value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LinearObject)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_confidence();
  void clear_has_confidence();
  void set_has_type();
  void clear_has_type();
  void set_has_marking();
  void clear_has_marking();
  void set_has_colour();
  void clear_has_colour();
  void set_has_ldm();
  void clear_has_ldm();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 id_;
  int confidence_;
  int type_;
  int marking_;
  int colour_;
  bool ldm_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinearObjectDefinitionValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LinearObjectDefinitionValue) */ {
 public:
  LinearObjectDefinitionValue();
  virtual ~LinearObjectDefinitionValue();

  LinearObjectDefinitionValue(const LinearObjectDefinitionValue& from);

  inline LinearObjectDefinitionValue& operator=(const LinearObjectDefinitionValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinearObjectDefinitionValue(LinearObjectDefinitionValue&& from) noexcept
    : LinearObjectDefinitionValue() {
    *this = ::std::move(from);
  }

  inline LinearObjectDefinitionValue& operator=(LinearObjectDefinitionValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinearObjectDefinitionValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinearObjectDefinitionValue* internal_default_instance() {
    return reinterpret_cast<const LinearObjectDefinitionValue*>(
               &_LinearObjectDefinitionValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(LinearObjectDefinitionValue* other);
  friend void swap(LinearObjectDefinitionValue& a, LinearObjectDefinitionValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinearObjectDefinitionValue* New() const final {
    return CreateMaybeMessage<LinearObjectDefinitionValue>(NULL);
  }

  LinearObjectDefinitionValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LinearObjectDefinitionValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LinearObjectDefinitionValue& from);
  void MergeFrom(const LinearObjectDefinitionValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinearObjectDefinitionValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.LinearObject linearObjects = 1;
  int linearobjects_size() const;
  void clear_linearobjects();
  static const int kLinearObjectsFieldNumber = 1;
  ::holo::map::adasisv3::LinearObject* mutable_linearobjects(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LinearObject >*
      mutable_linearobjects();
  const ::holo::map::adasisv3::LinearObject& linearobjects(int index) const;
  ::holo::map::adasisv3::LinearObject* add_linearobjects();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LinearObject >&
      linearobjects() const;

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LinearObjectDefinitionValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LinearObject > linearobjects_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Curve : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.Curve) */ {
 public:
  Curve();
  virtual ~Curve();

  Curve(const Curve& from);

  inline Curve& operator=(const Curve& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Curve(Curve&& from) noexcept
    : Curve() {
    *this = ::std::move(from);
  }

  inline Curve& operator=(Curve&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Curve& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Curve* internal_default_instance() {
    return reinterpret_cast<const Curve*>(
               &_Curve_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(Curve* other);
  friend void swap(Curve& a, Curve& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Curve* New() const final {
    return CreateMaybeMessage<Curve>(NULL);
  }

  Curve* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Curve>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Curve& from);
  void MergeFrom(const Curve& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Curve* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.WGS84Point points = 2;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 2;
  ::holo::map::adasisv3::WGS84Point* mutable_points(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >*
      mutable_points();
  const ::holo::map::adasisv3::WGS84Point& points(int index) const;
  ::holo::map::adasisv3::WGS84Point* add_points();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >&
      points() const;

  // required .holo.map.adasisv3.CurveType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::holo::map::adasisv3::CurveType type() const;
  void set_type(::holo::map::adasisv3::CurveType value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.Curve)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point > points_;
  int type_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LineGeometryValueAttribute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LineGeometryValueAttribute) */ {
 public:
  LineGeometryValueAttribute();
  virtual ~LineGeometryValueAttribute();

  LineGeometryValueAttribute(const LineGeometryValueAttribute& from);

  inline LineGeometryValueAttribute& operator=(const LineGeometryValueAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LineGeometryValueAttribute(LineGeometryValueAttribute&& from) noexcept
    : LineGeometryValueAttribute() {
    *this = ::std::move(from);
  }

  inline LineGeometryValueAttribute& operator=(LineGeometryValueAttribute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineGeometryValueAttribute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LineGeometryValueAttribute* internal_default_instance() {
    return reinterpret_cast<const LineGeometryValueAttribute*>(
               &_LineGeometryValueAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(LineGeometryValueAttribute* other);
  friend void swap(LineGeometryValueAttribute& a, LineGeometryValueAttribute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LineGeometryValueAttribute* New() const final {
    return CreateMaybeMessage<LineGeometryValueAttribute>(NULL);
  }

  LineGeometryValueAttribute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LineGeometryValueAttribute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LineGeometryValueAttribute& from);
  void MergeFrom(const LineGeometryValueAttribute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineGeometryValueAttribute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float curvature = 1;
  bool has_curvature() const;
  void clear_curvature();
  static const int kCurvatureFieldNumber = 1;
  float curvature() const;
  void set_curvature(float value);

  // required float slope = 2;
  bool has_slope() const;
  void clear_slope();
  static const int kSlopeFieldNumber = 2;
  float slope() const;
  void set_slope(float value);

  // required float banking = 3;
  bool has_banking() const;
  void clear_banking();
  static const int kBankingFieldNumber = 3;
  float banking() const;
  void set_banking(float value);

  // required float headingAngle = 4;
  bool has_headingangle() const;
  void clear_headingangle();
  static const int kHeadingAngleFieldNumber = 4;
  float headingangle() const;
  void set_headingangle(float value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LineGeometryValueAttribute)
 private:
  void set_has_curvature();
  void clear_has_curvature();
  void set_has_slope();
  void clear_has_slope();
  void set_has_banking();
  void clear_has_banking();
  void set_has_headingangle();
  void clear_has_headingangle();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float curvature_;
  float slope_;
  float banking_;
  float headingangle_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LineGeometryValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LineGeometryValue) */ {
 public:
  LineGeometryValue();
  virtual ~LineGeometryValue();

  LineGeometryValue(const LineGeometryValue& from);

  inline LineGeometryValue& operator=(const LineGeometryValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LineGeometryValue(LineGeometryValue&& from) noexcept
    : LineGeometryValue() {
    *this = ::std::move(from);
  }

  inline LineGeometryValue& operator=(LineGeometryValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineGeometryValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LineGeometryValue* internal_default_instance() {
    return reinterpret_cast<const LineGeometryValue*>(
               &_LineGeometryValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(LineGeometryValue* other);
  friend void swap(LineGeometryValue& a, LineGeometryValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LineGeometryValue* New() const final {
    return CreateMaybeMessage<LineGeometryValue>(NULL);
  }

  LineGeometryValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LineGeometryValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LineGeometryValue& from);
  void MergeFrom(const LineGeometryValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineGeometryValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.WGS84Point wgs84point = 1;
  bool has_wgs84point() const;
  void clear_wgs84point();
  static const int kWgs84PointFieldNumber = 1;
  private:
  const ::holo::map::adasisv3::WGS84Point& _internal_wgs84point() const;
  public:
  const ::holo::map::adasisv3::WGS84Point& wgs84point() const;
  ::holo::map::adasisv3::WGS84Point* release_wgs84point();
  ::holo::map::adasisv3::WGS84Point* mutable_wgs84point();
  void set_allocated_wgs84point(::holo::map::adasisv3::WGS84Point* wgs84point);

  // required .holo.map.adasisv3.LineGeometryValueAttribute attribute = 2;
  bool has_attribute() const;
  void clear_attribute();
  static const int kAttributeFieldNumber = 2;
  private:
  const ::holo::map::adasisv3::LineGeometryValueAttribute& _internal_attribute() const;
  public:
  const ::holo::map::adasisv3::LineGeometryValueAttribute& attribute() const;
  ::holo::map::adasisv3::LineGeometryValueAttribute* release_attribute();
  ::holo::map::adasisv3::LineGeometryValueAttribute* mutable_attribute();
  void set_allocated_attribute(::holo::map::adasisv3::LineGeometryValueAttribute* attribute);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LineGeometryValue)
 private:
  void set_has_wgs84point();
  void clear_has_wgs84point();
  void set_has_attribute();
  void clear_has_attribute();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::map::adasisv3::WGS84Point* wgs84point_;
  ::holo::map::adasisv3::LineGeometryValueAttribute* attribute_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LineGeometry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LineGeometry) */ {
 public:
  LineGeometry();
  virtual ~LineGeometry();

  LineGeometry(const LineGeometry& from);

  inline LineGeometry& operator=(const LineGeometry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LineGeometry(LineGeometry&& from) noexcept
    : LineGeometry() {
    *this = ::std::move(from);
  }

  inline LineGeometry& operator=(LineGeometry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineGeometry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LineGeometry* internal_default_instance() {
    return reinterpret_cast<const LineGeometry*>(
               &_LineGeometry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(LineGeometry* other);
  friend void swap(LineGeometry& a, LineGeometry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LineGeometry* New() const final {
    return CreateMaybeMessage<LineGeometry>(NULL);
  }

  LineGeometry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LineGeometry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LineGeometry& from);
  void MergeFrom(const LineGeometry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LineGeometry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.WGS84Point curve = 3;
  int curve_size() const;
  void clear_curve();
  static const int kCurveFieldNumber = 3;
  ::holo::map::adasisv3::WGS84Point* mutable_curve(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >*
      mutable_curve();
  const ::holo::map::adasisv3::WGS84Point& curve(int index) const;
  ::holo::map::adasisv3::WGS84Point* add_curve();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >&
      curve() const;

  // repeated .holo.map.adasisv3.LineGeometryValue value = 4;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 4;
  ::holo::map::adasisv3::LineGeometryValue* mutable_value(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometryValue >*
      mutable_value();
  const ::holo::map::adasisv3::LineGeometryValue& value(int index) const;
  ::holo::map::adasisv3::LineGeometryValue* add_value();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometryValue >&
      value() const;

  // required uint32 idLine = 1;
  bool has_idline() const;
  void clear_idline();
  static const int kIdLineFieldNumber = 1;
  ::google::protobuf::uint32 idline() const;
  void set_idline(::google::protobuf::uint32 value);

  // required .holo.map.adasisv3.CurveType curveType = 2;
  bool has_curvetype() const;
  void clear_curvetype();
  static const int kCurveTypeFieldNumber = 2;
  ::holo::map::adasisv3::CurveType curvetype() const;
  void set_curvetype(::holo::map::adasisv3::CurveType value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LineGeometry)
 private:
  void set_has_idline();
  void clear_has_idline();
  void set_has_curvetype();
  void clear_has_curvetype();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point > curve_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometryValue > value_;
  ::google::protobuf::uint32 idline_;
  int curvetype_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LanesGeometryProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LanesGeometryProfileValue) */ {
 public:
  LanesGeometryProfileValue();
  virtual ~LanesGeometryProfileValue();

  LanesGeometryProfileValue(const LanesGeometryProfileValue& from);

  inline LanesGeometryProfileValue& operator=(const LanesGeometryProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LanesGeometryProfileValue(LanesGeometryProfileValue&& from) noexcept
    : LanesGeometryProfileValue() {
    *this = ::std::move(from);
  }

  inline LanesGeometryProfileValue& operator=(LanesGeometryProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LanesGeometryProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LanesGeometryProfileValue* internal_default_instance() {
    return reinterpret_cast<const LanesGeometryProfileValue*>(
               &_LanesGeometryProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(LanesGeometryProfileValue* other);
  friend void swap(LanesGeometryProfileValue& a, LanesGeometryProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LanesGeometryProfileValue* New() const final {
    return CreateMaybeMessage<LanesGeometryProfileValue>(NULL);
  }

  LanesGeometryProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LanesGeometryProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LanesGeometryProfileValue& from);
  void MergeFrom(const LanesGeometryProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LanesGeometryProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.LineGeometry geometries = 1;
  int geometries_size() const;
  void clear_geometries();
  static const int kGeometriesFieldNumber = 1;
  ::holo::map::adasisv3::LineGeometry* mutable_geometries(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometry >*
      mutable_geometries();
  const ::holo::map::adasisv3::LineGeometry& geometries(int index) const;
  ::holo::map::adasisv3::LineGeometry* add_geometries();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometry >&
      geometries() const;

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LanesGeometryProfileValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometry > geometries_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadGeometryProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.RoadGeometryProfileValue) */ {
 public:
  RoadGeometryProfileValue();
  virtual ~RoadGeometryProfileValue();

  RoadGeometryProfileValue(const RoadGeometryProfileValue& from);

  inline RoadGeometryProfileValue& operator=(const RoadGeometryProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadGeometryProfileValue(RoadGeometryProfileValue&& from) noexcept
    : RoadGeometryProfileValue() {
    *this = ::std::move(from);
  }

  inline RoadGeometryProfileValue& operator=(RoadGeometryProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadGeometryProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadGeometryProfileValue* internal_default_instance() {
    return reinterpret_cast<const RoadGeometryProfileValue*>(
               &_RoadGeometryProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(RoadGeometryProfileValue* other);
  friend void swap(RoadGeometryProfileValue& a, RoadGeometryProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadGeometryProfileValue* New() const final {
    return CreateMaybeMessage<RoadGeometryProfileValue>(NULL);
  }

  RoadGeometryProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadGeometryProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadGeometryProfileValue& from);
  void MergeFrom(const RoadGeometryProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadGeometryProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.Curve roadCenterline = 1;
  bool has_roadcenterline() const;
  void clear_roadcenterline();
  static const int kRoadCenterlineFieldNumber = 1;
  private:
  const ::holo::map::adasisv3::Curve& _internal_roadcenterline() const;
  public:
  const ::holo::map::adasisv3::Curve& roadcenterline() const;
  ::holo::map::adasisv3::Curve* release_roadcenterline();
  ::holo::map::adasisv3::Curve* mutable_roadcenterline();
  void set_allocated_roadcenterline(::holo::map::adasisv3::Curve* roadcenterline);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.RoadGeometryProfileValue)
 private:
  void set_has_roadcenterline();
  void clear_has_roadcenterline();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::map::adasisv3::Curve* roadcenterline_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficLightProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.TrafficLightProfileValue) */ {
 public:
  TrafficLightProfileValue();
  virtual ~TrafficLightProfileValue();

  TrafficLightProfileValue(const TrafficLightProfileValue& from);

  inline TrafficLightProfileValue& operator=(const TrafficLightProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficLightProfileValue(TrafficLightProfileValue&& from) noexcept
    : TrafficLightProfileValue() {
    *this = ::std::move(from);
  }

  inline TrafficLightProfileValue& operator=(TrafficLightProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficLightProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficLightProfileValue* internal_default_instance() {
    return reinterpret_cast<const TrafficLightProfileValue*>(
               &_TrafficLightProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  void Swap(TrafficLightProfileValue* other);
  friend void swap(TrafficLightProfileValue& a, TrafficLightProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficLightProfileValue* New() const final {
    return CreateMaybeMessage<TrafficLightProfileValue>(NULL);
  }

  TrafficLightProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficLightProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficLightProfileValue& from);
  void MergeFrom(const TrafficLightProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficLightProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.WGS84Point position = 6;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 6;
  private:
  const ::holo::map::adasisv3::WGS84Point& _internal_position() const;
  public:
  const ::holo::map::adasisv3::WGS84Point& position() const;
  ::holo::map::adasisv3::WGS84Point* release_position();
  ::holo::map::adasisv3::WGS84Point* mutable_position();
  void set_allocated_position(::holo::map::adasisv3::WGS84Point* position);

  // required .holo.map.adasisv3.WGS84Point boundingBox = 7;
  bool has_boundingbox() const;
  void clear_boundingbox();
  static const int kBoundingBoxFieldNumber = 7;
  private:
  const ::holo::map::adasisv3::WGS84Point& _internal_boundingbox() const;
  public:
  const ::holo::map::adasisv3::WGS84Point& boundingbox() const;
  ::holo::map::adasisv3::WGS84Point* release_boundingbox();
  ::holo::map::adasisv3::WGS84Point* mutable_boundingbox();
  void set_allocated_boundingbox(::holo::map::adasisv3::WGS84Point* boundingbox);

  // required .holo.map.adasisv3.TrafficLightLongitudinalPosition longitudinalPosition = 1;
  bool has_longitudinalposition() const;
  void clear_longitudinalposition();
  static const int kLongitudinalPositionFieldNumber = 1;
  ::holo::map::adasisv3::TrafficLightLongitudinalPosition longitudinalposition() const;
  void set_longitudinalposition(::holo::map::adasisv3::TrafficLightLongitudinalPosition value);

  // required .holo.map.adasisv3.LateralPosition lateralPosition = 2;
  bool has_lateralposition() const;
  void clear_lateralposition();
  static const int kLateralPositionFieldNumber = 2;
  ::holo::map::adasisv3::LateralPosition lateralposition() const;
  void set_lateralposition(::holo::map::adasisv3::LateralPosition value);

  // required double cycleTime = 3;
  bool has_cycletime() const;
  void clear_cycletime();
  static const int kCycleTimeFieldNumber = 3;
  double cycletime() const;
  void set_cycletime(double value);

  // required .holo.map.adasisv3.TrafficLightState currentState = 4;
  bool has_currentstate() const;
  void clear_currentstate();
  static const int kCurrentStateFieldNumber = 4;
  ::holo::map::adasisv3::TrafficLightState currentstate() const;
  void set_currentstate(::holo::map::adasisv3::TrafficLightState value);

  // required .holo.map.adasisv3.YesNoUnknown turnOnRedAllowed = 5;
  bool has_turnonredallowed() const;
  void clear_turnonredallowed();
  static const int kTurnOnRedAllowedFieldNumber = 5;
  ::holo::map::adasisv3::YesNoUnknown turnonredallowed() const;
  void set_turnonredallowed(::holo::map::adasisv3::YesNoUnknown value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.TrafficLightProfileValue)
 private:
  void set_has_longitudinalposition();
  void clear_has_longitudinalposition();
  void set_has_lateralposition();
  void clear_has_lateralposition();
  void set_has_cycletime();
  void clear_has_cycletime();
  void set_has_currentstate();
  void clear_has_currentstate();
  void set_has_turnonredallowed();
  void clear_has_turnonredallowed();
  void set_has_position();
  void clear_has_position();
  void set_has_boundingbox();
  void clear_has_boundingbox();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::map::adasisv3::WGS84Point* position_;
  ::holo::map::adasisv3::WGS84Point* boundingbox_;
  int longitudinalposition_;
  int lateralposition_;
  double cycletime_;
  int currentstate_;
  int turnonredallowed_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EffectiveSpeedLimit : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.EffectiveSpeedLimit) */ {
 public:
  EffectiveSpeedLimit();
  virtual ~EffectiveSpeedLimit();

  EffectiveSpeedLimit(const EffectiveSpeedLimit& from);

  inline EffectiveSpeedLimit& operator=(const EffectiveSpeedLimit& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EffectiveSpeedLimit(EffectiveSpeedLimit&& from) noexcept
    : EffectiveSpeedLimit() {
    *this = ::std::move(from);
  }

  inline EffectiveSpeedLimit& operator=(EffectiveSpeedLimit&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EffectiveSpeedLimit& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const EffectiveSpeedLimit* internal_default_instance() {
    return reinterpret_cast<const EffectiveSpeedLimit*>(
               &_EffectiveSpeedLimit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  void Swap(EffectiveSpeedLimit* other);
  friend void swap(EffectiveSpeedLimit& a, EffectiveSpeedLimit& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EffectiveSpeedLimit* New() const final {
    return CreateMaybeMessage<EffectiveSpeedLimit>(NULL);
  }

  EffectiveSpeedLimit* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<EffectiveSpeedLimit>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const EffectiveSpeedLimit& from);
  void MergeFrom(const EffectiveSpeedLimit& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EffectiveSpeedLimit* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.Speed value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  private:
  const ::holo::map::adasisv3::Speed& _internal_value() const;
  public:
  const ::holo::map::adasisv3::Speed& value() const;
  ::holo::map::adasisv3::Speed* release_value();
  ::holo::map::adasisv3::Speed* mutable_value();
  void set_allocated_value(::holo::map::adasisv3::Speed* value);

  // required .holo.map.adasisv3.EffectiveSpeedLimitType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  ::holo::map::adasisv3::EffectiveSpeedLimitType type() const;
  void set_type(::holo::map::adasisv3::EffectiveSpeedLimitType value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.EffectiveSpeedLimit)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_type();
  void clear_has_type();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::map::adasisv3::Speed* value_;
  int type_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LocationObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.LocationObject) */ {
 public:
  LocationObject();
  virtual ~LocationObject();

  LocationObject(const LocationObject& from);

  inline LocationObject& operator=(const LocationObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LocationObject(LocationObject&& from) noexcept
    : LocationObject() {
    *this = ::std::move(from);
  }

  inline LocationObject& operator=(LocationObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocationObject& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LocationObject* internal_default_instance() {
    return reinterpret_cast<const LocationObject*>(
               &_LocationObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  void Swap(LocationObject* other);
  friend void swap(LocationObject& a, LocationObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LocationObject* New() const final {
    return CreateMaybeMessage<LocationObject>(NULL);
  }

  LocationObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LocationObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LocationObject& from);
  void MergeFrom(const LocationObject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LocationObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.WGS84Point absolutePosition = 3;
  bool has_absoluteposition() const;
  void clear_absoluteposition();
  static const int kAbsolutePositionFieldNumber = 3;
  private:
  const ::holo::map::adasisv3::WGS84Point& _internal_absoluteposition() const;
  public:
  const ::holo::map::adasisv3::WGS84Point& absoluteposition() const;
  ::holo::map::adasisv3::WGS84Point* release_absoluteposition();
  ::holo::map::adasisv3::WGS84Point* mutable_absoluteposition();
  void set_allocated_absoluteposition(::holo::map::adasisv3::WGS84Point* absoluteposition);

  // required int32 lateralOffset = 2;
  bool has_lateraloffset() const;
  void clear_lateraloffset();
  static const int kLateralOffsetFieldNumber = 2;
  ::google::protobuf::int32 lateraloffset() const;
  void set_lateraloffset(::google::protobuf::int32 value);

  // required .holo.map.adasisv3.LocationObjectType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::holo::map::adasisv3::LocationObjectType type() const;
  void set_type(::holo::map::adasisv3::LocationObjectType value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.LocationObject)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_lateraloffset();
  void clear_has_lateraloffset();
  void set_has_absoluteposition();
  void clear_has_absoluteposition();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::map::adasisv3::WGS84Point* absoluteposition_;
  ::google::protobuf::int32 lateraloffset_;
  int type_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegionCodeValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.RegionCodeValue) */ {
 public:
  RegionCodeValue();
  virtual ~RegionCodeValue();

  RegionCodeValue(const RegionCodeValue& from);

  inline RegionCodeValue& operator=(const RegionCodeValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegionCodeValue(RegionCodeValue&& from) noexcept
    : RegionCodeValue() {
    *this = ::std::move(from);
  }

  inline RegionCodeValue& operator=(RegionCodeValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionCodeValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegionCodeValue* internal_default_instance() {
    return reinterpret_cast<const RegionCodeValue*>(
               &_RegionCodeValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  void Swap(RegionCodeValue* other);
  friend void swap(RegionCodeValue& a, RegionCodeValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegionCodeValue* New() const final {
    return CreateMaybeMessage<RegionCodeValue>(NULL);
  }

  RegionCodeValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegionCodeValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegionCodeValue& from);
  void MergeFrom(const RegionCodeValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegionCodeValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value(int index) const;
  void set_value(int index, ::google::protobuf::uint32 value);
  void add_value(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.RegionCodeValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionNumeric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ConditionNumeric) */ {
 public:
  ConditionNumeric();
  virtual ~ConditionNumeric();

  ConditionNumeric(const ConditionNumeric& from);

  inline ConditionNumeric& operator=(const ConditionNumeric& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionNumeric(ConditionNumeric&& from) noexcept
    : ConditionNumeric() {
    *this = ::std::move(from);
  }

  inline ConditionNumeric& operator=(ConditionNumeric&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionNumeric& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionNumeric* internal_default_instance() {
    return reinterpret_cast<const ConditionNumeric*>(
               &_ConditionNumeric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  void Swap(ConditionNumeric* other);
  friend void swap(ConditionNumeric& a, ConditionNumeric& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionNumeric* New() const final {
    return CreateMaybeMessage<ConditionNumeric>(NULL);
  }

  ConditionNumeric* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionNumeric>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionNumeric& from);
  void MergeFrom(const ConditionNumeric& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionNumeric* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ConditionNumeric)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionVehicleType : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ConditionVehicleType) */ {
 public:
  ConditionVehicleType();
  virtual ~ConditionVehicleType();

  ConditionVehicleType(const ConditionVehicleType& from);

  inline ConditionVehicleType& operator=(const ConditionVehicleType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionVehicleType(ConditionVehicleType&& from) noexcept
    : ConditionVehicleType() {
    *this = ::std::move(from);
  }

  inline ConditionVehicleType& operator=(ConditionVehicleType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionVehicleType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionVehicleType* internal_default_instance() {
    return reinterpret_cast<const ConditionVehicleType*>(
               &_ConditionVehicleType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  void Swap(ConditionVehicleType* other);
  friend void swap(ConditionVehicleType& a, ConditionVehicleType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionVehicleType* New() const final {
    return CreateMaybeMessage<ConditionVehicleType>(NULL);
  }

  ConditionVehicleType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionVehicleType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionVehicleType& from);
  void MergeFrom(const ConditionVehicleType& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionVehicleType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 vehicleTypeMask = 1;
  bool has_vehicletypemask() const;
  void clear_vehicletypemask();
  static const int kVehicleTypeMaskFieldNumber = 1;
  ::google::protobuf::uint32 vehicletypemask() const;
  void set_vehicletypemask(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ConditionVehicleType)
 private:
  void set_has_vehicletypemask();
  void clear_has_vehicletypemask();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 vehicletypemask_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionLoad : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ConditionLoad) */ {
 public:
  ConditionLoad();
  virtual ~ConditionLoad();

  ConditionLoad(const ConditionLoad& from);

  inline ConditionLoad& operator=(const ConditionLoad& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionLoad(ConditionLoad&& from) noexcept
    : ConditionLoad() {
    *this = ::std::move(from);
  }

  inline ConditionLoad& operator=(ConditionLoad&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionLoad& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionLoad* internal_default_instance() {
    return reinterpret_cast<const ConditionLoad*>(
               &_ConditionLoad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  void Swap(ConditionLoad* other);
  friend void swap(ConditionLoad& a, ConditionLoad& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionLoad* New() const final {
    return CreateMaybeMessage<ConditionLoad>(NULL);
  }

  ConditionLoad* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionLoad>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionLoad& from);
  void MergeFrom(const ConditionLoad& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionLoad* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.Load value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::holo::map::adasisv3::Load value() const;
  void set_value(::holo::map::adasisv3::Load value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ConditionLoad)
 private:
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionTimeOfDay : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ConditionTimeOfDay) */ {
 public:
  ConditionTimeOfDay();
  virtual ~ConditionTimeOfDay();

  ConditionTimeOfDay(const ConditionTimeOfDay& from);

  inline ConditionTimeOfDay& operator=(const ConditionTimeOfDay& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionTimeOfDay(ConditionTimeOfDay&& from) noexcept
    : ConditionTimeOfDay() {
    *this = ::std::move(from);
  }

  inline ConditionTimeOfDay& operator=(ConditionTimeOfDay&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionTimeOfDay& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionTimeOfDay* internal_default_instance() {
    return reinterpret_cast<const ConditionTimeOfDay*>(
               &_ConditionTimeOfDay_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  void Swap(ConditionTimeOfDay* other);
  friend void swap(ConditionTimeOfDay& a, ConditionTimeOfDay& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionTimeOfDay* New() const final {
    return CreateMaybeMessage<ConditionTimeOfDay>(NULL);
  }

  ConditionTimeOfDay* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionTimeOfDay>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionTimeOfDay& from);
  void MergeFrom(const ConditionTimeOfDay& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionTimeOfDay* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 startMinutes = 1;
  bool has_startminutes() const;
  void clear_startminutes();
  static const int kStartMinutesFieldNumber = 1;
  ::google::protobuf::uint32 startminutes() const;
  void set_startminutes(::google::protobuf::uint32 value);

  // required uint32 endMinutes = 2;
  bool has_endminutes() const;
  void clear_endminutes();
  static const int kEndMinutesFieldNumber = 2;
  ::google::protobuf::uint32 endminutes() const;
  void set_endminutes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ConditionTimeOfDay)
 private:
  void set_has_startminutes();
  void clear_has_startminutes();
  void set_has_endminutes();
  void clear_has_endminutes();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 startminutes_;
  ::google::protobuf::uint32 endminutes_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionWeather : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ConditionWeather) */ {
 public:
  ConditionWeather();
  virtual ~ConditionWeather();

  ConditionWeather(const ConditionWeather& from);

  inline ConditionWeather& operator=(const ConditionWeather& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionWeather(ConditionWeather&& from) noexcept
    : ConditionWeather() {
    *this = ::std::move(from);
  }

  inline ConditionWeather& operator=(ConditionWeather&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionWeather& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionWeather* internal_default_instance() {
    return reinterpret_cast<const ConditionWeather*>(
               &_ConditionWeather_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  void Swap(ConditionWeather* other);
  friend void swap(ConditionWeather& a, ConditionWeather& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionWeather* New() const final {
    return CreateMaybeMessage<ConditionWeather>(NULL);
  }

  ConditionWeather* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionWeather>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionWeather& from);
  void MergeFrom(const ConditionWeather& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionWeather* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.Weather weather = 1;
  bool has_weather() const;
  void clear_weather();
  static const int kWeatherFieldNumber = 1;
  ::holo::map::adasisv3::Weather weather() const;
  void set_weather(::holo::map::adasisv3::Weather value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ConditionWeather)
 private:
  void set_has_weather();
  void clear_has_weather();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int weather_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionFuzzyTime : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ConditionFuzzyTime) */ {
 public:
  ConditionFuzzyTime();
  virtual ~ConditionFuzzyTime();

  ConditionFuzzyTime(const ConditionFuzzyTime& from);

  inline ConditionFuzzyTime& operator=(const ConditionFuzzyTime& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionFuzzyTime(ConditionFuzzyTime&& from) noexcept
    : ConditionFuzzyTime() {
    *this = ::std::move(from);
  }

  inline ConditionFuzzyTime& operator=(ConditionFuzzyTime&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionFuzzyTime& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionFuzzyTime* internal_default_instance() {
    return reinterpret_cast<const ConditionFuzzyTime*>(
               &_ConditionFuzzyTime_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  void Swap(ConditionFuzzyTime* other);
  friend void swap(ConditionFuzzyTime& a, ConditionFuzzyTime& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionFuzzyTime* New() const final {
    return CreateMaybeMessage<ConditionFuzzyTime>(NULL);
  }

  ConditionFuzzyTime* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionFuzzyTime>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionFuzzyTime& from);
  void MergeFrom(const ConditionFuzzyTime& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionFuzzyTime* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.FuzzyTime fuzzyTime = 1;
  bool has_fuzzytime() const;
  void clear_fuzzytime();
  static const int kFuzzyTimeFieldNumber = 1;
  ::holo::map::adasisv3::FuzzyTime fuzzytime() const;
  void set_fuzzytime(::holo::map::adasisv3::FuzzyTime value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ConditionFuzzyTime)
 private:
  void set_has_fuzzytime();
  void clear_has_fuzzytime();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int fuzzytime_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionTurnDirection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ConditionTurnDirection) */ {
 public:
  ConditionTurnDirection();
  virtual ~ConditionTurnDirection();

  ConditionTurnDirection(const ConditionTurnDirection& from);

  inline ConditionTurnDirection& operator=(const ConditionTurnDirection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionTurnDirection(ConditionTurnDirection&& from) noexcept
    : ConditionTurnDirection() {
    *this = ::std::move(from);
  }

  inline ConditionTurnDirection& operator=(ConditionTurnDirection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionTurnDirection& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionTurnDirection* internal_default_instance() {
    return reinterpret_cast<const ConditionTurnDirection*>(
               &_ConditionTurnDirection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  void Swap(ConditionTurnDirection* other);
  friend void swap(ConditionTurnDirection& a, ConditionTurnDirection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionTurnDirection* New() const final {
    return CreateMaybeMessage<ConditionTurnDirection>(NULL);
  }

  ConditionTurnDirection* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionTurnDirection>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionTurnDirection& from);
  void MergeFrom(const ConditionTurnDirection& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionTurnDirection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.LaneArrowMarking direction = 1;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 1;
  ::holo::map::adasisv3::LaneArrowMarking direction() const;
  void set_direction(::holo::map::adasisv3::LaneArrowMarking value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ConditionTurnDirection)
 private:
  void set_has_direction();
  void clear_has_direction();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int direction_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Condition : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.Condition) */ {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Condition& default_instance();

  enum ConditionCase {
    kConditionNumeric = 3,
    kConditionVehicleType = 4,
    kConditionLoad = 5,
    kConditionTimeOfDay = 6,
    kConditionWeather = 7,
    kConditionFuzzyTime = 8,
    kConditionTurnDirection = 9,
    CONDITION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  void Swap(Condition* other);
  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(NULL);
  }

  Condition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.ConditionType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::holo::map::adasisv3::ConditionType type() const;
  void set_type(::holo::map::adasisv3::ConditionType value);

  // required .holo.map.adasisv3.YesNoUnknown appliesToEgoVehicle = 2;
  bool has_appliestoegovehicle() const;
  void clear_appliestoegovehicle();
  static const int kAppliesToEgoVehicleFieldNumber = 2;
  ::holo::map::adasisv3::YesNoUnknown appliestoegovehicle() const;
  void set_appliestoegovehicle(::holo::map::adasisv3::YesNoUnknown value);

  // optional .holo.map.adasisv3.ConditionNumeric condition_numeric = 3;
  bool has_condition_numeric() const;
  void clear_condition_numeric();
  static const int kConditionNumericFieldNumber = 3;
  private:
  const ::holo::map::adasisv3::ConditionNumeric& _internal_condition_numeric() const;
  public:
  const ::holo::map::adasisv3::ConditionNumeric& condition_numeric() const;
  ::holo::map::adasisv3::ConditionNumeric* release_condition_numeric();
  ::holo::map::adasisv3::ConditionNumeric* mutable_condition_numeric();
  void set_allocated_condition_numeric(::holo::map::adasisv3::ConditionNumeric* condition_numeric);

  // optional .holo.map.adasisv3.ConditionVehicleType condition_vehicleType = 4;
  bool has_condition_vehicletype() const;
  void clear_condition_vehicletype();
  static const int kConditionVehicleTypeFieldNumber = 4;
  private:
  const ::holo::map::adasisv3::ConditionVehicleType& _internal_condition_vehicletype() const;
  public:
  const ::holo::map::adasisv3::ConditionVehicleType& condition_vehicletype() const;
  ::holo::map::adasisv3::ConditionVehicleType* release_condition_vehicletype();
  ::holo::map::adasisv3::ConditionVehicleType* mutable_condition_vehicletype();
  void set_allocated_condition_vehicletype(::holo::map::adasisv3::ConditionVehicleType* condition_vehicletype);

  // optional .holo.map.adasisv3.ConditionLoad condition_load = 5;
  bool has_condition_load() const;
  void clear_condition_load();
  static const int kConditionLoadFieldNumber = 5;
  private:
  const ::holo::map::adasisv3::ConditionLoad& _internal_condition_load() const;
  public:
  const ::holo::map::adasisv3::ConditionLoad& condition_load() const;
  ::holo::map::adasisv3::ConditionLoad* release_condition_load();
  ::holo::map::adasisv3::ConditionLoad* mutable_condition_load();
  void set_allocated_condition_load(::holo::map::adasisv3::ConditionLoad* condition_load);

  // optional .holo.map.adasisv3.ConditionTimeOfDay condition_timeOfDay = 6;
  bool has_condition_timeofday() const;
  void clear_condition_timeofday();
  static const int kConditionTimeOfDayFieldNumber = 6;
  private:
  const ::holo::map::adasisv3::ConditionTimeOfDay& _internal_condition_timeofday() const;
  public:
  const ::holo::map::adasisv3::ConditionTimeOfDay& condition_timeofday() const;
  ::holo::map::adasisv3::ConditionTimeOfDay* release_condition_timeofday();
  ::holo::map::adasisv3::ConditionTimeOfDay* mutable_condition_timeofday();
  void set_allocated_condition_timeofday(::holo::map::adasisv3::ConditionTimeOfDay* condition_timeofday);

  // optional .holo.map.adasisv3.ConditionWeather condition_weather = 7;
  bool has_condition_weather() const;
  void clear_condition_weather();
  static const int kConditionWeatherFieldNumber = 7;
  private:
  const ::holo::map::adasisv3::ConditionWeather& _internal_condition_weather() const;
  public:
  const ::holo::map::adasisv3::ConditionWeather& condition_weather() const;
  ::holo::map::adasisv3::ConditionWeather* release_condition_weather();
  ::holo::map::adasisv3::ConditionWeather* mutable_condition_weather();
  void set_allocated_condition_weather(::holo::map::adasisv3::ConditionWeather* condition_weather);

  // optional .holo.map.adasisv3.ConditionFuzzyTime condition_fuzzyTime = 8;
  bool has_condition_fuzzytime() const;
  void clear_condition_fuzzytime();
  static const int kConditionFuzzyTimeFieldNumber = 8;
  private:
  const ::holo::map::adasisv3::ConditionFuzzyTime& _internal_condition_fuzzytime() const;
  public:
  const ::holo::map::adasisv3::ConditionFuzzyTime& condition_fuzzytime() const;
  ::holo::map::adasisv3::ConditionFuzzyTime* release_condition_fuzzytime();
  ::holo::map::adasisv3::ConditionFuzzyTime* mutable_condition_fuzzytime();
  void set_allocated_condition_fuzzytime(::holo::map::adasisv3::ConditionFuzzyTime* condition_fuzzytime);

  // optional .holo.map.adasisv3.ConditionTurnDirection condition_turnDirection = 9;
  bool has_condition_turndirection() const;
  void clear_condition_turndirection();
  static const int kConditionTurnDirectionFieldNumber = 9;
  private:
  const ::holo::map::adasisv3::ConditionTurnDirection& _internal_condition_turndirection() const;
  public:
  const ::holo::map::adasisv3::ConditionTurnDirection& condition_turndirection() const;
  ::holo::map::adasisv3::ConditionTurnDirection* release_condition_turndirection();
  ::holo::map::adasisv3::ConditionTurnDirection* mutable_condition_turndirection();
  void set_allocated_condition_turndirection(::holo::map::adasisv3::ConditionTurnDirection* condition_turndirection);

  void clear_condition();
  ConditionCase condition_case() const;
  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.Condition)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_appliestoegovehicle();
  void clear_has_appliestoegovehicle();
  void set_has_condition_numeric();
  void set_has_condition_vehicletype();
  void set_has_condition_load();
  void set_has_condition_timeofday();
  void set_has_condition_weather();
  void set_has_condition_fuzzytime();
  void set_has_condition_turndirection();

  inline bool has_condition() const;
  inline void clear_has_condition();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int type_;
  int appliestoegovehicle_;
  union ConditionUnion {
    ConditionUnion() {}
    ::holo::map::adasisv3::ConditionNumeric* condition_numeric_;
    ::holo::map::adasisv3::ConditionVehicleType* condition_vehicletype_;
    ::holo::map::adasisv3::ConditionLoad* condition_load_;
    ::holo::map::adasisv3::ConditionTimeOfDay* condition_timeofday_;
    ::holo::map::adasisv3::ConditionWeather* condition_weather_;
    ::holo::map::adasisv3::ConditionFuzzyTime* condition_fuzzytime_;
    ::holo::map::adasisv3::ConditionTurnDirection* condition_turndirection_;
  } condition_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ExtendedSpeedLimitValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ExtendedSpeedLimitValue) */ {
 public:
  ExtendedSpeedLimitValue();
  virtual ~ExtendedSpeedLimitValue();

  ExtendedSpeedLimitValue(const ExtendedSpeedLimitValue& from);

  inline ExtendedSpeedLimitValue& operator=(const ExtendedSpeedLimitValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExtendedSpeedLimitValue(ExtendedSpeedLimitValue&& from) noexcept
    : ExtendedSpeedLimitValue() {
    *this = ::std::move(from);
  }

  inline ExtendedSpeedLimitValue& operator=(ExtendedSpeedLimitValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtendedSpeedLimitValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtendedSpeedLimitValue* internal_default_instance() {
    return reinterpret_cast<const ExtendedSpeedLimitValue*>(
               &_ExtendedSpeedLimitValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  void Swap(ExtendedSpeedLimitValue* other);
  friend void swap(ExtendedSpeedLimitValue& a, ExtendedSpeedLimitValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExtendedSpeedLimitValue* New() const final {
    return CreateMaybeMessage<ExtendedSpeedLimitValue>(NULL);
  }

  ExtendedSpeedLimitValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExtendedSpeedLimitValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExtendedSpeedLimitValue& from);
  void MergeFrom(const ExtendedSpeedLimitValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtendedSpeedLimitValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.Condition conditions = 3;
  int conditions_size() const;
  void clear_conditions();
  static const int kConditionsFieldNumber = 3;
  ::holo::map::adasisv3::Condition* mutable_conditions(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >*
      mutable_conditions();
  const ::holo::map::adasisv3::Condition& conditions(int index) const;
  ::holo::map::adasisv3::Condition* add_conditions();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >&
      conditions() const;

  // required .holo.map.adasisv3.Speed value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  private:
  const ::holo::map::adasisv3::Speed& _internal_value() const;
  public:
  const ::holo::map::adasisv3::Speed& value() const;
  ::holo::map::adasisv3::Speed* release_value();
  ::holo::map::adasisv3::Speed* mutable_value();
  void set_allocated_value(::holo::map::adasisv3::Speed* value);

  // required .holo.map.adasisv3.SpeedLimitSource source = 2;
  bool has_source() const;
  void clear_source();
  static const int kSourceFieldNumber = 2;
  ::holo::map::adasisv3::SpeedLimitSource source() const;
  void set_source(::holo::map::adasisv3::SpeedLimitSource value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ExtendedSpeedLimitValue)
 private:
  void set_has_value();
  void clear_has_value();
  void set_has_source();
  void clear_has_source();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition > conditions_;
  ::holo::map::adasisv3::Speed* value_;
  int source_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficSignValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.TrafficSignValue) */ {
 public:
  TrafficSignValue();
  virtual ~TrafficSignValue();

  TrafficSignValue(const TrafficSignValue& from);

  inline TrafficSignValue& operator=(const TrafficSignValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficSignValue(TrafficSignValue&& from) noexcept
    : TrafficSignValue() {
    *this = ::std::move(from);
  }

  inline TrafficSignValue& operator=(TrafficSignValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficSignValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficSignValue* internal_default_instance() {
    return reinterpret_cast<const TrafficSignValue*>(
               &_TrafficSignValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  void Swap(TrafficSignValue* other);
  friend void swap(TrafficSignValue& a, TrafficSignValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficSignValue* New() const final {
    return CreateMaybeMessage<TrafficSignValue>(NULL);
  }

  TrafficSignValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficSignValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficSignValue& from);
  void MergeFrom(const TrafficSignValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficSignValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.Condition panels = 11;
  int panels_size() const;
  void clear_panels();
  static const int kPanelsFieldNumber = 11;
  ::holo::map::adasisv3::Condition* mutable_panels(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >*
      mutable_panels();
  const ::holo::map::adasisv3::Condition& panels(int index) const;
  ::holo::map::adasisv3::Condition* add_panels();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >&
      panels() const;

  // required .holo.map.adasisv3.WGS84Point wgs84point = 10;
  bool has_wgs84point() const;
  void clear_wgs84point();
  static const int kWgs84PointFieldNumber = 10;
  private:
  const ::holo::map::adasisv3::WGS84Point& _internal_wgs84point() const;
  public:
  const ::holo::map::adasisv3::WGS84Point& wgs84point() const;
  ::holo::map::adasisv3::WGS84Point* release_wgs84point();
  ::holo::map::adasisv3::WGS84Point* mutable_wgs84point();
  void set_allocated_wgs84point(::holo::map::adasisv3::WGS84Point* wgs84point);

  // required uint32 value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  ::google::protobuf::uint32 value() const;
  void set_value(::google::protobuf::uint32 value);

  // required uint32 location = 3;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 3;
  ::google::protobuf::uint32 location() const;
  void set_location(::google::protobuf::uint32 value);

  // required int32 shift = 4;
  bool has_shift() const;
  void clear_shift();
  static const int kShiftFieldNumber = 4;
  ::google::protobuf::int32 shift() const;
  void set_shift(::google::protobuf::int32 value);

  // required int32 transverseDistance = 5;
  bool has_transversedistance() const;
  void clear_transversedistance();
  static const int kTransverseDistanceFieldNumber = 5;
  ::google::protobuf::int32 transversedistance() const;
  void set_transversedistance(::google::protobuf::int32 value);

  // required uint32 distance = 6;
  bool has_distance() const;
  void clear_distance();
  static const int kDistanceFieldNumber = 6;
  ::google::protobuf::uint32 distance() const;
  void set_distance(::google::protobuf::uint32 value);

  // required uint32 length = 7;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 7;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // required .holo.map.adasisv3.YesNoUnknown vms = 8;
  bool has_vms() const;
  void clear_vms();
  static const int kVmsFieldNumber = 8;
  ::holo::map::adasisv3::YesNoUnknown vms() const;
  void set_vms(::holo::map::adasisv3::YesNoUnknown value);

  // required .holo.map.adasisv3.SignShape shape = 9;
  bool has_shape() const;
  void clear_shape();
  static const int kShapeFieldNumber = 9;
  ::holo::map::adasisv3::SignShape shape() const;
  void set_shape(::holo::map::adasisv3::SignShape value);

  // required .holo.map.adasisv3.TrafficSignSignType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::holo::map::adasisv3::TrafficSignSignType type() const;
  void set_type(::holo::map::adasisv3::TrafficSignSignType value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.TrafficSignValue)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_value();
  void clear_has_value();
  void set_has_location();
  void clear_has_location();
  void set_has_shift();
  void clear_has_shift();
  void set_has_transversedistance();
  void clear_has_transversedistance();
  void set_has_distance();
  void clear_has_distance();
  void set_has_length();
  void clear_has_length();
  void set_has_vms();
  void clear_has_vms();
  void set_has_shape();
  void clear_has_shape();
  void set_has_wgs84point();
  void clear_has_wgs84point();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition > panels_;
  ::holo::map::adasisv3::WGS84Point* wgs84point_;
  ::google::protobuf::uint32 value_;
  ::google::protobuf::uint32 location_;
  ::google::protobuf::int32 shift_;
  ::google::protobuf::int32 transversedistance_;
  ::google::protobuf::uint32 distance_;
  ::google::protobuf::uint32 length_;
  int vms_;
  int shape_;
  int type_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ConditionalRestrictionProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.ConditionalRestrictionProfileValue) */ {
 public:
  ConditionalRestrictionProfileValue();
  virtual ~ConditionalRestrictionProfileValue();

  ConditionalRestrictionProfileValue(const ConditionalRestrictionProfileValue& from);

  inline ConditionalRestrictionProfileValue& operator=(const ConditionalRestrictionProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ConditionalRestrictionProfileValue(ConditionalRestrictionProfileValue&& from) noexcept
    : ConditionalRestrictionProfileValue() {
    *this = ::std::move(from);
  }

  inline ConditionalRestrictionProfileValue& operator=(ConditionalRestrictionProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConditionalRestrictionProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ConditionalRestrictionProfileValue* internal_default_instance() {
    return reinterpret_cast<const ConditionalRestrictionProfileValue*>(
               &_ConditionalRestrictionProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  void Swap(ConditionalRestrictionProfileValue* other);
  friend void swap(ConditionalRestrictionProfileValue& a, ConditionalRestrictionProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ConditionalRestrictionProfileValue* New() const final {
    return CreateMaybeMessage<ConditionalRestrictionProfileValue>(NULL);
  }

  ConditionalRestrictionProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ConditionalRestrictionProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ConditionalRestrictionProfileValue& from);
  void MergeFrom(const ConditionalRestrictionProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConditionalRestrictionProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.Condition conditions = 2;
  int conditions_size() const;
  void clear_conditions();
  static const int kConditionsFieldNumber = 2;
  ::holo::map::adasisv3::Condition* mutable_conditions(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >*
      mutable_conditions();
  const ::holo::map::adasisv3::Condition& conditions(int index) const;
  ::holo::map::adasisv3::Condition* add_conditions();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >&
      conditions() const;

  // required bool allowed = 1;
  bool has_allowed() const;
  void clear_allowed();
  static const int kAllowedFieldNumber = 1;
  bool allowed() const;
  void set_allowed(bool value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.ConditionalRestrictionProfileValue)
 private:
  void set_has_allowed();
  void clear_has_allowed();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition > conditions_;
  bool allowed_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RoadSurfaceProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.RoadSurfaceProfileValue) */ {
 public:
  RoadSurfaceProfileValue();
  virtual ~RoadSurfaceProfileValue();

  RoadSurfaceProfileValue(const RoadSurfaceProfileValue& from);

  inline RoadSurfaceProfileValue& operator=(const RoadSurfaceProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoadSurfaceProfileValue(RoadSurfaceProfileValue&& from) noexcept
    : RoadSurfaceProfileValue() {
    *this = ::std::move(from);
  }

  inline RoadSurfaceProfileValue& operator=(RoadSurfaceProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoadSurfaceProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoadSurfaceProfileValue* internal_default_instance() {
    return reinterpret_cast<const RoadSurfaceProfileValue*>(
               &_RoadSurfaceProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  void Swap(RoadSurfaceProfileValue* other);
  friend void swap(RoadSurfaceProfileValue& a, RoadSurfaceProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoadSurfaceProfileValue* New() const final {
    return CreateMaybeMessage<RoadSurfaceProfileValue>(NULL);
  }

  RoadSurfaceProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RoadSurfaceProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RoadSurfaceProfileValue& from);
  void MergeFrom(const RoadSurfaceProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoadSurfaceProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint32 value = 3;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  ::google::protobuf::uint32 value(int index) const;
  void set_value(int index, ::google::protobuf::uint32 value);
  void add_value(::google::protobuf::uint32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_value();

  // required .holo.map.adasisv3.WGS84Point wgs84point = 2;
  bool has_wgs84point() const;
  void clear_wgs84point();
  static const int kWgs84PointFieldNumber = 2;
  private:
  const ::holo::map::adasisv3::WGS84Point& _internal_wgs84point() const;
  public:
  const ::holo::map::adasisv3::WGS84Point& wgs84point() const;
  ::holo::map::adasisv3::WGS84Point* release_wgs84point();
  ::holo::map::adasisv3::WGS84Point* mutable_wgs84point();
  void set_allocated_wgs84point(::holo::map::adasisv3::WGS84Point* wgs84point);

  // required .holo.map.adasisv3.RoadSurfaceSignType signType = 1;
  bool has_signtype() const;
  void clear_signtype();
  static const int kSignTypeFieldNumber = 1;
  ::holo::map::adasisv3::RoadSurfaceSignType signtype() const;
  void set_signtype(::holo::map::adasisv3::RoadSurfaceSignType value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.RoadSurfaceProfileValue)
 private:
  void set_has_signtype();
  void clear_has_signtype();
  void set_has_wgs84point();
  void clear_has_wgs84point();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > value_;
  ::holo::map::adasisv3::WGS84Point* wgs84point_;
  int signtype_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PoleProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.PoleProfileValue) */ {
 public:
  PoleProfileValue();
  virtual ~PoleProfileValue();

  PoleProfileValue(const PoleProfileValue& from);

  inline PoleProfileValue& operator=(const PoleProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PoleProfileValue(PoleProfileValue&& from) noexcept
    : PoleProfileValue() {
    *this = ::std::move(from);
  }

  inline PoleProfileValue& operator=(PoleProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoleProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PoleProfileValue* internal_default_instance() {
    return reinterpret_cast<const PoleProfileValue*>(
               &_PoleProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  void Swap(PoleProfileValue* other);
  friend void swap(PoleProfileValue& a, PoleProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PoleProfileValue* New() const final {
    return CreateMaybeMessage<PoleProfileValue>(NULL);
  }

  PoleProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PoleProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PoleProfileValue& from);
  void MergeFrom(const PoleProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PoleProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.WGS84Point wgs84point = 3;
  bool has_wgs84point() const;
  void clear_wgs84point();
  static const int kWgs84PointFieldNumber = 3;
  private:
  const ::holo::map::adasisv3::WGS84Point& _internal_wgs84point() const;
  public:
  const ::holo::map::adasisv3::WGS84Point& wgs84point() const;
  ::holo::map::adasisv3::WGS84Point* release_wgs84point();
  ::holo::map::adasisv3::WGS84Point* mutable_wgs84point();
  void set_allocated_wgs84point(::holo::map::adasisv3::WGS84Point* wgs84point);

  // required .holo.map.adasisv3.PoleSignType signType = 1;
  bool has_signtype() const;
  void clear_signtype();
  static const int kSignTypeFieldNumber = 1;
  ::holo::map::adasisv3::PoleSignType signtype() const;
  void set_signtype(::holo::map::adasisv3::PoleSignType value);

  // required int32 relativeHeight = 2;
  bool has_relativeheight() const;
  void clear_relativeheight();
  static const int kRelativeHeightFieldNumber = 2;
  ::google::protobuf::int32 relativeheight() const;
  void set_relativeheight(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.PoleProfileValue)
 private:
  void set_has_signtype();
  void clear_has_signtype();
  void set_has_relativeheight();
  void clear_has_relativeheight();
  void set_has_wgs84point();
  void clear_has_wgs84point();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::holo::map::adasisv3::WGS84Point* wgs84point_;
  int signtype_;
  ::google::protobuf::int32 relativeheight_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficFlowProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.TrafficFlowProfileValue) */ {
 public:
  TrafficFlowProfileValue();
  virtual ~TrafficFlowProfileValue();

  TrafficFlowProfileValue(const TrafficFlowProfileValue& from);

  inline TrafficFlowProfileValue& operator=(const TrafficFlowProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficFlowProfileValue(TrafficFlowProfileValue&& from) noexcept
    : TrafficFlowProfileValue() {
    *this = ::std::move(from);
  }

  inline TrafficFlowProfileValue& operator=(TrafficFlowProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficFlowProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficFlowProfileValue* internal_default_instance() {
    return reinterpret_cast<const TrafficFlowProfileValue*>(
               &_TrafficFlowProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  void Swap(TrafficFlowProfileValue* other);
  friend void swap(TrafficFlowProfileValue& a, TrafficFlowProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficFlowProfileValue* New() const final {
    return CreateMaybeMessage<TrafficFlowProfileValue>(NULL);
  }

  TrafficFlowProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficFlowProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficFlowProfileValue& from);
  void MergeFrom(const TrafficFlowProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficFlowProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.TrafficFlowStatus flowStatus = 1;
  bool has_flowstatus() const;
  void clear_flowstatus();
  static const int kFlowStatusFieldNumber = 1;
  ::holo::map::adasisv3::TrafficFlowStatus flowstatus() const;
  void set_flowstatus(::holo::map::adasisv3::TrafficFlowStatus value);

  // required uint32 reliability = 2;
  bool has_reliability() const;
  void clear_reliability();
  static const int kReliabilityFieldNumber = 2;
  ::google::protobuf::uint32 reliability() const;
  void set_reliability(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.TrafficFlowProfileValue)
 private:
  void set_has_flowstatus();
  void clear_has_flowstatus();
  void set_has_reliability();
  void clear_has_reliability();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int flowstatus_;
  ::google::protobuf::uint32 reliability_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TrafficEventProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.TrafficEventProfileValue) */ {
 public:
  TrafficEventProfileValue();
  virtual ~TrafficEventProfileValue();

  TrafficEventProfileValue(const TrafficEventProfileValue& from);

  inline TrafficEventProfileValue& operator=(const TrafficEventProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TrafficEventProfileValue(TrafficEventProfileValue&& from) noexcept
    : TrafficEventProfileValue() {
    *this = ::std::move(from);
  }

  inline TrafficEventProfileValue& operator=(TrafficEventProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TrafficEventProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TrafficEventProfileValue* internal_default_instance() {
    return reinterpret_cast<const TrafficEventProfileValue*>(
               &_TrafficEventProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  void Swap(TrafficEventProfileValue* other);
  friend void swap(TrafficEventProfileValue& a, TrafficEventProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TrafficEventProfileValue* New() const final {
    return CreateMaybeMessage<TrafficEventProfileValue>(NULL);
  }

  TrafficEventProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TrafficEventProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TrafficEventProfileValue& from);
  void MergeFrom(const TrafficEventProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TrafficEventProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .holo.map.adasisv3.TrafficEventType eventType = 1;
  bool has_eventtype() const;
  void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  ::holo::map::adasisv3::TrafficEventType eventtype() const;
  void set_eventtype(::holo::map::adasisv3::TrafficEventType value);

  // required uint32 reliability = 2;
  bool has_reliability() const;
  void clear_reliability();
  static const int kReliabilityFieldNumber = 2;
  ::google::protobuf::uint32 reliability() const;
  void set_reliability(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.TrafficEventProfileValue)
 private:
  void set_has_eventtype();
  void clear_has_eventtype();
  void set_has_reliability();
  void clear_has_reliability();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int eventtype_;
  ::google::protobuf::uint32 reliability_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StaticODDProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.StaticODDProfileValue) */ {
 public:
  StaticODDProfileValue();
  virtual ~StaticODDProfileValue();

  StaticODDProfileValue(const StaticODDProfileValue& from);

  inline StaticODDProfileValue& operator=(const StaticODDProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StaticODDProfileValue(StaticODDProfileValue&& from) noexcept
    : StaticODDProfileValue() {
    *this = ::std::move(from);
  }

  inline StaticODDProfileValue& operator=(StaticODDProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StaticODDProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StaticODDProfileValue* internal_default_instance() {
    return reinterpret_cast<const StaticODDProfileValue*>(
               &_StaticODDProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  void Swap(StaticODDProfileValue* other);
  friend void swap(StaticODDProfileValue& a, StaticODDProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StaticODDProfileValue* New() const final {
    return CreateMaybeMessage<StaticODDProfileValue>(NULL);
  }

  StaticODDProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StaticODDProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StaticODDProfileValue& from);
  void MergeFrom(const StaticODDProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticODDProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 action = 2;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 2;
  ::google::protobuf::uint32 action() const;
  void set_action(::google::protobuf::uint32 value);

  // required uint64 reason = 3;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  ::google::protobuf::uint64 reason() const;
  void set_reason(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.StaticODDProfileValue)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_action();
  void clear_has_action();
  void set_has_reason();
  void clear_has_reason();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 action_;
  ::google::protobuf::uint64 reason_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StaticNotODDProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.StaticNotODDProfileValue) */ {
 public:
  StaticNotODDProfileValue();
  virtual ~StaticNotODDProfileValue();

  StaticNotODDProfileValue(const StaticNotODDProfileValue& from);

  inline StaticNotODDProfileValue& operator=(const StaticNotODDProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StaticNotODDProfileValue(StaticNotODDProfileValue&& from) noexcept
    : StaticNotODDProfileValue() {
    *this = ::std::move(from);
  }

  inline StaticNotODDProfileValue& operator=(StaticNotODDProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StaticNotODDProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StaticNotODDProfileValue* internal_default_instance() {
    return reinterpret_cast<const StaticNotODDProfileValue*>(
               &_StaticNotODDProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  void Swap(StaticNotODDProfileValue* other);
  friend void swap(StaticNotODDProfileValue& a, StaticNotODDProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StaticNotODDProfileValue* New() const final {
    return CreateMaybeMessage<StaticNotODDProfileValue>(NULL);
  }

  StaticNotODDProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StaticNotODDProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StaticNotODDProfileValue& from);
  void MergeFrom(const StaticNotODDProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StaticNotODDProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::google::protobuf::uint32 type() const;
  void set_type(::google::protobuf::uint32 value);

  // required uint32 action = 2;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 2;
  ::google::protobuf::uint32 action() const;
  void set_action(::google::protobuf::uint32 value);

  // required uint64 reason = 3;
  bool has_reason() const;
  void clear_reason();
  static const int kReasonFieldNumber = 3;
  ::google::protobuf::uint64 reason() const;
  void set_reason(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.StaticNotODDProfileValue)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_action();
  void clear_has_action();
  void set_has_reason();
  void clear_has_reason();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 action_;
  ::google::protobuf::uint64 reason_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DecelerationZoneProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.DecelerationZoneProfileValue) */ {
 public:
  DecelerationZoneProfileValue();
  virtual ~DecelerationZoneProfileValue();

  DecelerationZoneProfileValue(const DecelerationZoneProfileValue& from);

  inline DecelerationZoneProfileValue& operator=(const DecelerationZoneProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DecelerationZoneProfileValue(DecelerationZoneProfileValue&& from) noexcept
    : DecelerationZoneProfileValue() {
    *this = ::std::move(from);
  }

  inline DecelerationZoneProfileValue& operator=(DecelerationZoneProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DecelerationZoneProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecelerationZoneProfileValue* internal_default_instance() {
    return reinterpret_cast<const DecelerationZoneProfileValue*>(
               &_DecelerationZoneProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  void Swap(DecelerationZoneProfileValue* other);
  friend void swap(DecelerationZoneProfileValue& a, DecelerationZoneProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DecelerationZoneProfileValue* New() const final {
    return CreateMaybeMessage<DecelerationZoneProfileValue>(NULL);
  }

  DecelerationZoneProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DecelerationZoneProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DecelerationZoneProfileValue& from);
  void MergeFrom(const DecelerationZoneProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecelerationZoneProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.WGS84Point boundingBox = 2;
  int boundingbox_size() const;
  void clear_boundingbox();
  static const int kBoundingBoxFieldNumber = 2;
  ::holo::map::adasisv3::WGS84Point* mutable_boundingbox(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >*
      mutable_boundingbox();
  const ::holo::map::adasisv3::WGS84Point& boundingbox(int index) const;
  ::holo::map::adasisv3::WGS84Point* add_boundingbox();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >&
      boundingbox() const;

  // required .holo.map.adasisv3.DecelerationZoneType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::holo::map::adasisv3::DecelerationZoneType type() const;
  void set_type(::holo::map::adasisv3::DecelerationZoneType value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.DecelerationZoneProfileValue)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point > boundingbox_;
  int type_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OverHeadProfileValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.OverHeadProfileValue) */ {
 public:
  OverHeadProfileValue();
  virtual ~OverHeadProfileValue();

  OverHeadProfileValue(const OverHeadProfileValue& from);

  inline OverHeadProfileValue& operator=(const OverHeadProfileValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OverHeadProfileValue(OverHeadProfileValue&& from) noexcept
    : OverHeadProfileValue() {
    *this = ::std::move(from);
  }

  inline OverHeadProfileValue& operator=(OverHeadProfileValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OverHeadProfileValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OverHeadProfileValue* internal_default_instance() {
    return reinterpret_cast<const OverHeadProfileValue*>(
               &_OverHeadProfileValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  void Swap(OverHeadProfileValue* other);
  friend void swap(OverHeadProfileValue& a, OverHeadProfileValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OverHeadProfileValue* New() const final {
    return CreateMaybeMessage<OverHeadProfileValue>(NULL);
  }

  OverHeadProfileValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OverHeadProfileValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OverHeadProfileValue& from);
  void MergeFrom(const OverHeadProfileValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverHeadProfileValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.OverHeadValue OverHeadValue_value = 1;
  int overheadvalue_value_size() const;
  void clear_overheadvalue_value();
  static const int kOverHeadValueValueFieldNumber = 1;
  ::holo::map::adasisv3::OverHeadValue* mutable_overheadvalue_value(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OverHeadValue >*
      mutable_overheadvalue_value();
  const ::holo::map::adasisv3::OverHeadValue& overheadvalue_value(int index) const;
  ::holo::map::adasisv3::OverHeadValue* add_overheadvalue_value();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OverHeadValue >&
      overheadvalue_value() const;

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.OverHeadProfileValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OverHeadValue > overheadvalue_value_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OverHeadValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.adasisv3.OverHeadValue) */ {
 public:
  OverHeadValue();
  virtual ~OverHeadValue();

  OverHeadValue(const OverHeadValue& from);

  inline OverHeadValue& operator=(const OverHeadValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OverHeadValue(OverHeadValue&& from) noexcept
    : OverHeadValue() {
    *this = ::std::move(from);
  }

  inline OverHeadValue& operator=(OverHeadValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OverHeadValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OverHeadValue* internal_default_instance() {
    return reinterpret_cast<const OverHeadValue*>(
               &_OverHeadValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  void Swap(OverHeadValue* other);
  friend void swap(OverHeadValue& a, OverHeadValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OverHeadValue* New() const final {
    return CreateMaybeMessage<OverHeadValue>(NULL);
  }

  OverHeadValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OverHeadValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OverHeadValue& from);
  void MergeFrom(const OverHeadValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OverHeadValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .holo.map.adasisv3.WGS84Point wgs84point = 2;
  int wgs84point_size() const;
  void clear_wgs84point();
  static const int kWgs84PointFieldNumber = 2;
  ::holo::map::adasisv3::WGS84Point* mutable_wgs84point(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >*
      mutable_wgs84point();
  const ::holo::map::adasisv3::WGS84Point& wgs84point(int index) const;
  ::holo::map::adasisv3::WGS84Point* add_wgs84point();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >&
      wgs84point() const;

  // required .holo.map.adasisv3.OverHeadType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::holo::map::adasisv3::OverHeadType type() const;
  void set_type(::holo::map::adasisv3::OverHeadType value);

  // @@protoc_insertion_point(class_scope:holo.map.adasisv3.OverHeadValue)
 private:
  void set_has_type();
  void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point > wgs84point_;
  int type_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Vector

// required float x = 1;
inline bool Vector::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vector::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vector::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vector::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vector::x() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Vector.x)
  return x_;
}
inline void Vector::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Vector.x)
}

// required float y = 2;
inline bool Vector::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vector::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vector::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vector::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vector::y() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Vector.y)
  return y_;
}
inline void Vector::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Vector.y)
}

// required float z = 3;
inline bool Vector::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vector::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vector::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vector::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vector::z() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Vector.z)
  return z_;
}
inline void Vector::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Vector.z)
}

// -------------------------------------------------------------------

// Speed

// required uint32 value = 1;
inline bool Speed::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Speed::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Speed::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Speed::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 Speed::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Speed.value)
  return value_;
}
inline void Speed::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Speed.value)
}

// required .holo.map.adasisv3.UnitOfSpeed unit = 2;
inline bool Speed::has_unit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Speed::set_has_unit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Speed::clear_has_unit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Speed::clear_unit() {
  unit_ = 1;
  clear_has_unit();
}
inline ::holo::map::adasisv3::UnitOfSpeed Speed::unit() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Speed.unit)
  return static_cast< ::holo::map::adasisv3::UnitOfSpeed >(unit_);
}
inline void Speed::set_unit(::holo::map::adasisv3::UnitOfSpeed value) {
  assert(::holo::map::adasisv3::UnitOfSpeed_IsValid(value));
  set_has_unit();
  unit_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Speed.unit)
}

// -------------------------------------------------------------------

// WGS84Point

// required int32 latitude = 1;
inline bool WGS84Point::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WGS84Point::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WGS84Point::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WGS84Point::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline ::google::protobuf::int32 WGS84Point::latitude() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.WGS84Point.latitude)
  return latitude_;
}
inline void WGS84Point::set_latitude(::google::protobuf::int32 value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.WGS84Point.latitude)
}

// required int32 longitude = 2;
inline bool WGS84Point::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WGS84Point::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WGS84Point::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WGS84Point::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline ::google::protobuf::int32 WGS84Point::longitude() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.WGS84Point.longitude)
  return longitude_;
}
inline void WGS84Point::set_longitude(::google::protobuf::int32 value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.WGS84Point.longitude)
}

// required int32 altitude = 3;
inline bool WGS84Point::has_altitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WGS84Point::set_has_altitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WGS84Point::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WGS84Point::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline ::google::protobuf::int32 WGS84Point::altitude() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.WGS84Point.altitude)
  return altitude_;
}
inline void WGS84Point::set_altitude(::google::protobuf::int32 value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.WGS84Point.altitude)
}

// -------------------------------------------------------------------

// VehiclePosition

// required int32 latitude = 1;
inline bool VehiclePosition::has_latitude() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VehiclePosition::set_has_latitude() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VehiclePosition::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VehiclePosition::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline ::google::protobuf::int32 VehiclePosition::latitude() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.VehiclePosition.latitude)
  return latitude_;
}
inline void VehiclePosition::set_latitude(::google::protobuf::int32 value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.VehiclePosition.latitude)
}

// required int32 longitude = 2;
inline bool VehiclePosition::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VehiclePosition::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VehiclePosition::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VehiclePosition::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline ::google::protobuf::int32 VehiclePosition::longitude() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.VehiclePosition.longitude)
  return longitude_;
}
inline void VehiclePosition::set_longitude(::google::protobuf::int32 value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.VehiclePosition.longitude)
}

// required int32 altitude = 3;
inline bool VehiclePosition::has_altitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void VehiclePosition::set_has_altitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void VehiclePosition::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void VehiclePosition::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline ::google::protobuf::int32 VehiclePosition::altitude() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.VehiclePosition.altitude)
  return altitude_;
}
inline void VehiclePosition::set_altitude(::google::protobuf::int32 value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.VehiclePosition.altitude)
}

// required uint64 timestamp = 4;
inline bool VehiclePosition::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VehiclePosition::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VehiclePosition::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VehiclePosition::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 VehiclePosition::timestamp() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.VehiclePosition.timestamp)
  return timestamp_;
}
inline void VehiclePosition::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.VehiclePosition.timestamp)
}

// required float heading = 5;
inline bool VehiclePosition::has_heading() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void VehiclePosition::set_has_heading() {
  _has_bits_[0] |= 0x00000010u;
}
inline void VehiclePosition::clear_has_heading() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void VehiclePosition::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float VehiclePosition::heading() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.VehiclePosition.heading)
  return heading_;
}
inline void VehiclePosition::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.VehiclePosition.heading)
}

// -------------------------------------------------------------------

// Position

// required uint32 pathId = 1;
inline bool Position::has_pathid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Position::set_has_pathid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Position::clear_has_pathid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Position::clear_pathid() {
  pathid_ = 0u;
  clear_has_pathid();
}
inline ::google::protobuf::uint32 Position::pathid() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Position.pathId)
  return pathid_;
}
inline void Position::set_pathid(::google::protobuf::uint32 value) {
  set_has_pathid();
  pathid_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Position.pathId)
}

// required uint32 offset = 2;
inline bool Position::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Position::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Position::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Position::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 Position::offset() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Position.offset)
  return offset_;
}
inline void Position::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Position.offset)
}

// required uint32 accuracy = 3;
inline bool Position::has_accuracy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Position::set_has_accuracy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Position::clear_has_accuracy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Position::clear_accuracy() {
  accuracy_ = 0u;
  clear_has_accuracy();
}
inline ::google::protobuf::uint32 Position::accuracy() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Position.accuracy)
  return accuracy_;
}
inline void Position::set_accuracy(::google::protobuf::uint32 value) {
  set_has_accuracy();
  accuracy_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Position.accuracy)
}

// required int32 deviation = 4;
inline bool Position::has_deviation() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Position::set_has_deviation() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Position::clear_has_deviation() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Position::clear_deviation() {
  deviation_ = 0;
  clear_has_deviation();
}
inline ::google::protobuf::int32 Position::deviation() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Position.deviation)
  return deviation_;
}
inline void Position::set_deviation(::google::protobuf::int32 value) {
  set_has_deviation();
  deviation_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Position.deviation)
}

// required float speed = 5;
inline bool Position::has_speed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Position::set_has_speed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Position::clear_has_speed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Position::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float Position::speed() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Position.speed)
  return speed_;
}
inline void Position::set_speed(float value) {
  set_has_speed();
  speed_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Position.speed)
}

// required float relativeHeading = 6;
inline bool Position::has_relativeheading() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Position::set_has_relativeheading() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Position::clear_has_relativeheading() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Position::clear_relativeheading() {
  relativeheading_ = 0;
  clear_has_relativeheading();
}
inline float Position::relativeheading() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Position.relativeHeading)
  return relativeheading_;
}
inline void Position::set_relativeheading(float value) {
  set_has_relativeheading();
  relativeheading_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Position.relativeHeading)
}

// required float probability = 7;
inline bool Position::has_probability() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Position::set_has_probability() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Position::clear_has_probability() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Position::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline float Position::probability() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Position.probability)
  return probability_;
}
inline void Position::set_probability(float value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Position.probability)
}

// required uint32 currentLane = 8;
inline bool Position::has_currentlane() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Position::set_has_currentlane() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Position::clear_has_currentlane() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Position::clear_currentlane() {
  currentlane_ = 0u;
  clear_has_currentlane();
}
inline ::google::protobuf::uint32 Position::currentlane() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Position.currentLane)
  return currentlane_;
}
inline void Position::set_currentlane(::google::protobuf::uint32 value) {
  set_has_currentlane();
  currentlane_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Position.currentLane)
}

// required uint32 preferredPath = 9;
inline bool Position::has_preferredpath() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Position::set_has_preferredpath() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Position::clear_has_preferredpath() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Position::clear_preferredpath() {
  preferredpath_ = 0u;
  clear_has_preferredpath();
}
inline ::google::protobuf::uint32 Position::preferredpath() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Position.preferredPath)
  return preferredpath_;
}
inline void Position::set_preferredpath(::google::protobuf::uint32 value) {
  set_has_preferredpath();
  preferredpath_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Position.preferredPath)
}

// -------------------------------------------------------------------

// AbsoluteVehiclePosition

// required float heading = 1;
inline bool AbsoluteVehiclePosition::has_heading() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AbsoluteVehiclePosition::set_has_heading() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AbsoluteVehiclePosition::clear_has_heading() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AbsoluteVehiclePosition::clear_heading() {
  heading_ = 0;
  clear_has_heading();
}
inline float AbsoluteVehiclePosition::heading() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.AbsoluteVehiclePosition.heading)
  return heading_;
}
inline void AbsoluteVehiclePosition::set_heading(float value) {
  set_has_heading();
  heading_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.AbsoluteVehiclePosition.heading)
}

// required .holo.map.adasisv3.WGS84Point vehiclePosition = 2;
inline bool AbsoluteVehiclePosition::has_vehicleposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AbsoluteVehiclePosition::set_has_vehicleposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AbsoluteVehiclePosition::clear_has_vehicleposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AbsoluteVehiclePosition::clear_vehicleposition() {
  if (vehicleposition_ != NULL) vehicleposition_->Clear();
  clear_has_vehicleposition();
}
inline const ::holo::map::adasisv3::WGS84Point& AbsoluteVehiclePosition::_internal_vehicleposition() const {
  return *vehicleposition_;
}
inline const ::holo::map::adasisv3::WGS84Point& AbsoluteVehiclePosition::vehicleposition() const {
  const ::holo::map::adasisv3::WGS84Point* p = vehicleposition_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.AbsoluteVehiclePosition.vehiclePosition)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::WGS84Point*>(
      &::holo::map::adasisv3::_WGS84Point_default_instance_);
}
inline ::holo::map::adasisv3::WGS84Point* AbsoluteVehiclePosition::release_vehicleposition() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.AbsoluteVehiclePosition.vehiclePosition)
  clear_has_vehicleposition();
  ::holo::map::adasisv3::WGS84Point* temp = vehicleposition_;
  vehicleposition_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::WGS84Point* AbsoluteVehiclePosition::mutable_vehicleposition() {
  set_has_vehicleposition();
  if (vehicleposition_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::WGS84Point>(GetArenaNoVirtual());
    vehicleposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.AbsoluteVehiclePosition.vehiclePosition)
  return vehicleposition_;
}
inline void AbsoluteVehiclePosition::set_allocated_vehicleposition(::holo::map::adasisv3::WGS84Point* vehicleposition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete vehicleposition_;
  }
  if (vehicleposition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      vehicleposition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, vehicleposition, submessage_arena);
    }
    set_has_vehicleposition();
  } else {
    clear_has_vehicleposition();
  }
  vehicleposition_ = vehicleposition;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.AbsoluteVehiclePosition.vehiclePosition)
}

// optional uint32 stdLateralPos = 3;
inline bool AbsoluteVehiclePosition::has_stdlateralpos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AbsoluteVehiclePosition::set_has_stdlateralpos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AbsoluteVehiclePosition::clear_has_stdlateralpos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AbsoluteVehiclePosition::clear_stdlateralpos() {
  stdlateralpos_ = 0u;
  clear_has_stdlateralpos();
}
inline ::google::protobuf::uint32 AbsoluteVehiclePosition::stdlateralpos() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.AbsoluteVehiclePosition.stdLateralPos)
  return stdlateralpos_;
}
inline void AbsoluteVehiclePosition::set_stdlateralpos(::google::protobuf::uint32 value) {
  set_has_stdlateralpos();
  stdlateralpos_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.AbsoluteVehiclePosition.stdLateralPos)
}

// optional uint32 stdLongitudinalPos = 4;
inline bool AbsoluteVehiclePosition::has_stdlongitudinalpos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AbsoluteVehiclePosition::set_has_stdlongitudinalpos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AbsoluteVehiclePosition::clear_has_stdlongitudinalpos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AbsoluteVehiclePosition::clear_stdlongitudinalpos() {
  stdlongitudinalpos_ = 0u;
  clear_has_stdlongitudinalpos();
}
inline ::google::protobuf::uint32 AbsoluteVehiclePosition::stdlongitudinalpos() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.AbsoluteVehiclePosition.stdLongitudinalPos)
  return stdlongitudinalpos_;
}
inline void AbsoluteVehiclePosition::set_stdlongitudinalpos(::google::protobuf::uint32 value) {
  set_has_stdlongitudinalpos();
  stdlongitudinalpos_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.AbsoluteVehiclePosition.stdLongitudinalPos)
}

// -------------------------------------------------------------------

// RelativePosition

// optional float locLaneSequenceConfidence = 1;
inline bool RelativePosition::has_loclanesequenceconfidence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RelativePosition::set_has_loclanesequenceconfidence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RelativePosition::clear_has_loclanesequenceconfidence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RelativePosition::clear_loclanesequenceconfidence() {
  loclanesequenceconfidence_ = 0;
  clear_has_loclanesequenceconfidence();
}
inline float RelativePosition::loclanesequenceconfidence() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RelativePosition.locLaneSequenceConfidence)
  return loclanesequenceconfidence_;
}
inline void RelativePosition::set_loclanesequenceconfidence(float value) {
  set_has_loclanesequenceconfidence();
  loclanesequenceconfidence_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.RelativePosition.locLaneSequenceConfidence)
}

// optional uint32 lateralOffsetLeft = 2;
inline bool RelativePosition::has_lateraloffsetleft() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RelativePosition::set_has_lateraloffsetleft() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RelativePosition::clear_has_lateraloffsetleft() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RelativePosition::clear_lateraloffsetleft() {
  lateraloffsetleft_ = 0u;
  clear_has_lateraloffsetleft();
}
inline ::google::protobuf::uint32 RelativePosition::lateraloffsetleft() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RelativePosition.lateralOffsetLeft)
  return lateraloffsetleft_;
}
inline void RelativePosition::set_lateraloffsetleft(::google::protobuf::uint32 value) {
  set_has_lateraloffsetleft();
  lateraloffsetleft_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.RelativePosition.lateralOffsetLeft)
}

// optional uint32 lateralOffsetRight = 3;
inline bool RelativePosition::has_lateraloffsetright() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RelativePosition::set_has_lateraloffsetright() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RelativePosition::clear_has_lateraloffsetright() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RelativePosition::clear_lateraloffsetright() {
  lateraloffsetright_ = 0u;
  clear_has_lateraloffsetright();
}
inline ::google::protobuf::uint32 RelativePosition::lateraloffsetright() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RelativePosition.lateralOffsetRight)
  return lateraloffsetright_;
}
inline void RelativePosition::set_lateraloffsetright(::google::protobuf::uint32 value) {
  set_has_lateraloffsetright();
  lateraloffsetright_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.RelativePosition.lateralOffsetRight)
}

// optional float locLeftBoundaryHeading = 4;
inline bool RelativePosition::has_locleftboundaryheading() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RelativePosition::set_has_locleftboundaryheading() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RelativePosition::clear_has_locleftboundaryheading() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RelativePosition::clear_locleftboundaryheading() {
  locleftboundaryheading_ = 0;
  clear_has_locleftboundaryheading();
}
inline float RelativePosition::locleftboundaryheading() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RelativePosition.locLeftBoundaryHeading)
  return locleftboundaryheading_;
}
inline void RelativePosition::set_locleftboundaryheading(float value) {
  set_has_locleftboundaryheading();
  locleftboundaryheading_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.RelativePosition.locLeftBoundaryHeading)
}

// optional float locRightBoundaryHeading = 5;
inline bool RelativePosition::has_locrightboundaryheading() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RelativePosition::set_has_locrightboundaryheading() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RelativePosition::clear_has_locrightboundaryheading() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RelativePosition::clear_locrightboundaryheading() {
  locrightboundaryheading_ = 0;
  clear_has_locrightboundaryheading();
}
inline float RelativePosition::locrightboundaryheading() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RelativePosition.locRightBoundaryHeading)
  return locrightboundaryheading_;
}
inline void RelativePosition::set_locrightboundaryheading(float value) {
  set_has_locrightboundaryheading();
  locrightboundaryheading_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.RelativePosition.locRightBoundaryHeading)
}

// -------------------------------------------------------------------

// PositionMessage

// required uint64 timestamp = 1;
inline bool PositionMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PositionMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PositionMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PositionMessage::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 PositionMessage::timestamp() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PositionMessage.timestamp)
  return timestamp_;
}
inline void PositionMessage::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.PositionMessage.timestamp)
}

// required uint64 positionAge = 2;
inline bool PositionMessage::has_positionage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PositionMessage::set_has_positionage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PositionMessage::clear_has_positionage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PositionMessage::clear_positionage() {
  positionage_ = GOOGLE_ULONGLONG(0);
  clear_has_positionage();
}
inline ::google::protobuf::uint64 PositionMessage::positionage() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PositionMessage.positionAge)
  return positionage_;
}
inline void PositionMessage::set_positionage(::google::protobuf::uint64 value) {
  set_has_positionage();
  positionage_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.PositionMessage.positionAge)
}

// repeated .holo.map.adasisv3.Position positions = 3;
inline int PositionMessage::positions_size() const {
  return positions_.size();
}
inline void PositionMessage::clear_positions() {
  positions_.Clear();
}
inline ::holo::map::adasisv3::Position* PositionMessage::mutable_positions(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.PositionMessage.positions)
  return positions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Position >*
PositionMessage::mutable_positions() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.PositionMessage.positions)
  return &positions_;
}
inline const ::holo::map::adasisv3::Position& PositionMessage::positions(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PositionMessage.positions)
  return positions_.Get(index);
}
inline ::holo::map::adasisv3::Position* PositionMessage::add_positions() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.PositionMessage.positions)
  return positions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Position >&
PositionMessage::positions() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.PositionMessage.positions)
  return positions_;
}

// optional .holo.map.adasisv3.AbsoluteVehiclePosition absoluteVehiclePosition = 4;
inline bool PositionMessage::has_absolutevehicleposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PositionMessage::set_has_absolutevehicleposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PositionMessage::clear_has_absolutevehicleposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PositionMessage::clear_absolutevehicleposition() {
  if (absolutevehicleposition_ != NULL) absolutevehicleposition_->Clear();
  clear_has_absolutevehicleposition();
}
inline const ::holo::map::adasisv3::AbsoluteVehiclePosition& PositionMessage::_internal_absolutevehicleposition() const {
  return *absolutevehicleposition_;
}
inline const ::holo::map::adasisv3::AbsoluteVehiclePosition& PositionMessage::absolutevehicleposition() const {
  const ::holo::map::adasisv3::AbsoluteVehiclePosition* p = absolutevehicleposition_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PositionMessage.absoluteVehiclePosition)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::AbsoluteVehiclePosition*>(
      &::holo::map::adasisv3::_AbsoluteVehiclePosition_default_instance_);
}
inline ::holo::map::adasisv3::AbsoluteVehiclePosition* PositionMessage::release_absolutevehicleposition() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.PositionMessage.absoluteVehiclePosition)
  clear_has_absolutevehicleposition();
  ::holo::map::adasisv3::AbsoluteVehiclePosition* temp = absolutevehicleposition_;
  absolutevehicleposition_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::AbsoluteVehiclePosition* PositionMessage::mutable_absolutevehicleposition() {
  set_has_absolutevehicleposition();
  if (absolutevehicleposition_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::AbsoluteVehiclePosition>(GetArenaNoVirtual());
    absolutevehicleposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.PositionMessage.absoluteVehiclePosition)
  return absolutevehicleposition_;
}
inline void PositionMessage::set_allocated_absolutevehicleposition(::holo::map::adasisv3::AbsoluteVehiclePosition* absolutevehicleposition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete absolutevehicleposition_;
  }
  if (absolutevehicleposition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      absolutevehicleposition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, absolutevehicleposition, submessage_arena);
    }
    set_has_absolutevehicleposition();
  } else {
    clear_has_absolutevehicleposition();
  }
  absolutevehicleposition_ = absolutevehicleposition;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.PositionMessage.absoluteVehiclePosition)
}

// optional .holo.map.adasisv3.RelativePosition relativePosition = 5;
inline bool PositionMessage::has_relativeposition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PositionMessage::set_has_relativeposition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PositionMessage::clear_has_relativeposition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PositionMessage::clear_relativeposition() {
  if (relativeposition_ != NULL) relativeposition_->Clear();
  clear_has_relativeposition();
}
inline const ::holo::map::adasisv3::RelativePosition& PositionMessage::_internal_relativeposition() const {
  return *relativeposition_;
}
inline const ::holo::map::adasisv3::RelativePosition& PositionMessage::relativeposition() const {
  const ::holo::map::adasisv3::RelativePosition* p = relativeposition_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PositionMessage.relativePosition)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::RelativePosition*>(
      &::holo::map::adasisv3::_RelativePosition_default_instance_);
}
inline ::holo::map::adasisv3::RelativePosition* PositionMessage::release_relativeposition() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.PositionMessage.relativePosition)
  clear_has_relativeposition();
  ::holo::map::adasisv3::RelativePosition* temp = relativeposition_;
  relativeposition_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::RelativePosition* PositionMessage::mutable_relativeposition() {
  set_has_relativeposition();
  if (relativeposition_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::RelativePosition>(GetArenaNoVirtual());
    relativeposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.PositionMessage.relativePosition)
  return relativeposition_;
}
inline void PositionMessage::set_allocated_relativeposition(::holo::map::adasisv3::RelativePosition* relativeposition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete relativeposition_;
  }
  if (relativeposition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      relativeposition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, relativeposition, submessage_arena);
    }
    set_has_relativeposition();
  } else {
    clear_has_relativeposition();
  }
  relativeposition_ = relativeposition;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.PositionMessage.relativePosition)
}

// -------------------------------------------------------------------

// ProfileEntry

// optional uint32 instanceId = 1;
inline bool ProfileEntry::has_instanceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProfileEntry::set_has_instanceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProfileEntry::clear_has_instanceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProfileEntry::clear_instanceid() {
  instanceid_ = 0u;
  clear_has_instanceid();
}
inline ::google::protobuf::uint32 ProfileEntry::instanceid() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.instanceId)
  return instanceid_;
}
inline void ProfileEntry::set_instanceid(::google::protobuf::uint32 value) {
  set_has_instanceid();
  instanceid_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.instanceId)
}

// required bool isRetransmission = 2;
inline bool ProfileEntry::has_isretransmission() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProfileEntry::set_has_isretransmission() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProfileEntry::clear_has_isretransmission() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProfileEntry::clear_isretransmission() {
  isretransmission_ = false;
  clear_has_isretransmission();
}
inline bool ProfileEntry::isretransmission() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.isRetransmission)
  return isretransmission_;
}
inline void ProfileEntry::set_isretransmission(bool value) {
  set_has_isretransmission();
  isretransmission_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.isRetransmission)
}

// required .holo.map.adasisv3.ChangeMode change = 3;
inline bool ProfileEntry::has_change() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProfileEntry::set_has_change() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProfileEntry::clear_has_change() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProfileEntry::clear_change() {
  change_ = 0;
  clear_has_change();
}
inline ::holo::map::adasisv3::ChangeMode ProfileEntry::change() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.change)
  return static_cast< ::holo::map::adasisv3::ChangeMode >(change_);
}
inline void ProfileEntry::set_change(::holo::map::adasisv3::ChangeMode value) {
  assert(::holo::map::adasisv3::ChangeMode_IsValid(value));
  set_has_change();
  change_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.change)
}

// required float confidence = 4;
inline bool ProfileEntry::has_confidence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProfileEntry::set_has_confidence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProfileEntry::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProfileEntry::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float ProfileEntry::confidence() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.confidence)
  return confidence_;
}
inline void ProfileEntry::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.confidence)
}

// required uint32 pathId = 5;
inline bool ProfileEntry::has_pathid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProfileEntry::set_has_pathid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProfileEntry::clear_has_pathid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProfileEntry::clear_pathid() {
  pathid_ = 0u;
  clear_has_pathid();
}
inline ::google::protobuf::uint32 ProfileEntry::pathid() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.pathId)
  return pathid_;
}
inline void ProfileEntry::set_pathid(::google::protobuf::uint32 value) {
  set_has_pathid();
  pathid_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.pathId)
}

// repeated uint32 laneNumbers = 6;
inline int ProfileEntry::lanenumbers_size() const {
  return lanenumbers_.size();
}
inline void ProfileEntry::clear_lanenumbers() {
  lanenumbers_.Clear();
}
inline ::google::protobuf::uint32 ProfileEntry::lanenumbers(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.laneNumbers)
  return lanenumbers_.Get(index);
}
inline void ProfileEntry::set_lanenumbers(int index, ::google::protobuf::uint32 value) {
  lanenumbers_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.laneNumbers)
}
inline void ProfileEntry::add_lanenumbers(::google::protobuf::uint32 value) {
  lanenumbers_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.ProfileEntry.laneNumbers)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ProfileEntry::lanenumbers() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.ProfileEntry.laneNumbers)
  return lanenumbers_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ProfileEntry::mutable_lanenumbers() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.ProfileEntry.laneNumbers)
  return &lanenumbers_;
}

// optional .holo.map.adasisv3.RelativeDirection direction = 7;
inline bool ProfileEntry::has_direction() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProfileEntry::set_has_direction() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProfileEntry::clear_has_direction() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProfileEntry::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::holo::map::adasisv3::RelativeDirection ProfileEntry::direction() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.direction)
  return static_cast< ::holo::map::adasisv3::RelativeDirection >(direction_);
}
inline void ProfileEntry::set_direction(::holo::map::adasisv3::RelativeDirection value) {
  assert(::holo::map::adasisv3::RelativeDirection_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.direction)
}

// required uint32 offset = 8;
inline bool ProfileEntry::has_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProfileEntry::set_has_offset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProfileEntry::clear_has_offset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProfileEntry::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 ProfileEntry::offset() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.offset)
  return offset_;
}
inline void ProfileEntry::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.offset)
}

// required uint32 endOffset = 9;
inline bool ProfileEntry::has_endoffset() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProfileEntry::set_has_endoffset() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProfileEntry::clear_has_endoffset() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProfileEntry::clear_endoffset() {
  endoffset_ = 0u;
  clear_has_endoffset();
}
inline ::google::protobuf::uint32 ProfileEntry::endoffset() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.endOffset)
  return endoffset_;
}
inline void ProfileEntry::set_endoffset(::google::protobuf::uint32 value) {
  set_has_endoffset();
  endoffset_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.endOffset)
}

// required bool endOffsetFinal = 10;
inline bool ProfileEntry::has_endoffsetfinal() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProfileEntry::set_has_endoffsetfinal() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProfileEntry::clear_has_endoffsetfinal() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProfileEntry::clear_endoffsetfinal() {
  endoffsetfinal_ = false;
  clear_has_endoffsetfinal();
}
inline bool ProfileEntry::endoffsetfinal() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.endOffsetFinal)
  return endoffsetfinal_;
}
inline void ProfileEntry::set_endoffsetfinal(bool value) {
  set_has_endoffsetfinal();
  endoffsetfinal_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.endOffsetFinal)
}

// required .holo.map.adasisv3.ProfileType type = 11;
inline bool ProfileEntry::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProfileEntry::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProfileEntry::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProfileEntry::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::holo::map::adasisv3::ProfileType ProfileEntry::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.type)
  return static_cast< ::holo::map::adasisv3::ProfileType >(type_);
}
inline void ProfileEntry::set_type(::holo::map::adasisv3::ProfileType value) {
  assert(::holo::map::adasisv3::ProfileType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.type)
}

// required .holo.map.adasisv3.Availability available = 12;
inline bool ProfileEntry::has_available() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProfileEntry::set_has_available() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProfileEntry::clear_has_available() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProfileEntry::clear_available() {
  available_ = 0;
  clear_has_available();
}
inline ::holo::map::adasisv3::Availability ProfileEntry::available() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.available)
  return static_cast< ::holo::map::adasisv3::Availability >(available_);
}
inline void ProfileEntry::set_available(::holo::map::adasisv3::Availability value) {
  assert(::holo::map::adasisv3::Availability_IsValid(value));
  set_has_available();
  available_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileEntry.available)
}

// optional .holo.map.adasisv3.UInt32ProfileValue UInt32ProfileValue_value = 13;
inline bool ProfileEntry::has_uint32profilevalue_value() const {
  return value_case() == kUInt32ProfileValueValue;
}
inline void ProfileEntry::set_has_uint32profilevalue_value() {
  _oneof_case_[0] = kUInt32ProfileValueValue;
}
inline void ProfileEntry::clear_uint32profilevalue_value() {
  if (has_uint32profilevalue_value()) {
    delete value_.uint32profilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::UInt32ProfileValue& ProfileEntry::_internal_uint32profilevalue_value() const {
  return *value_.uint32profilevalue_value_;
}
inline ::holo::map::adasisv3::UInt32ProfileValue* ProfileEntry::release_uint32profilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.UInt32ProfileValue_value)
  if (has_uint32profilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::UInt32ProfileValue* temp = value_.uint32profilevalue_value_;
    value_.uint32profilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::UInt32ProfileValue& ProfileEntry::uint32profilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.UInt32ProfileValue_value)
  return has_uint32profilevalue_value()
      ? *value_.uint32profilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::UInt32ProfileValue*>(&::holo::map::adasisv3::_UInt32ProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::UInt32ProfileValue* ProfileEntry::mutable_uint32profilevalue_value() {
  if (!has_uint32profilevalue_value()) {
    clear_value();
    set_has_uint32profilevalue_value();
    value_.uint32profilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::UInt32ProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.UInt32ProfileValue_value)
  return value_.uint32profilevalue_value_;
}

// optional .holo.map.adasisv3.Int32ProfileValue Int32ProfileValue_value = 14;
inline bool ProfileEntry::has_int32profilevalue_value() const {
  return value_case() == kInt32ProfileValueValue;
}
inline void ProfileEntry::set_has_int32profilevalue_value() {
  _oneof_case_[0] = kInt32ProfileValueValue;
}
inline void ProfileEntry::clear_int32profilevalue_value() {
  if (has_int32profilevalue_value()) {
    delete value_.int32profilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::Int32ProfileValue& ProfileEntry::_internal_int32profilevalue_value() const {
  return *value_.int32profilevalue_value_;
}
inline ::holo::map::adasisv3::Int32ProfileValue* ProfileEntry::release_int32profilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.Int32ProfileValue_value)
  if (has_int32profilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::Int32ProfileValue* temp = value_.int32profilevalue_value_;
    value_.int32profilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::Int32ProfileValue& ProfileEntry::int32profilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.Int32ProfileValue_value)
  return has_int32profilevalue_value()
      ? *value_.int32profilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::Int32ProfileValue*>(&::holo::map::adasisv3::_Int32ProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::Int32ProfileValue* ProfileEntry::mutable_int32profilevalue_value() {
  if (!has_int32profilevalue_value()) {
    clear_value();
    set_has_int32profilevalue_value();
    value_.int32profilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::Int32ProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.Int32ProfileValue_value)
  return value_.int32profilevalue_value_;
}

// optional .holo.map.adasisv3.UInt64ProfileValue UInt64ProfileValue_value = 15;
inline bool ProfileEntry::has_uint64profilevalue_value() const {
  return value_case() == kUInt64ProfileValueValue;
}
inline void ProfileEntry::set_has_uint64profilevalue_value() {
  _oneof_case_[0] = kUInt64ProfileValueValue;
}
inline void ProfileEntry::clear_uint64profilevalue_value() {
  if (has_uint64profilevalue_value()) {
    delete value_.uint64profilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::UInt64ProfileValue& ProfileEntry::_internal_uint64profilevalue_value() const {
  return *value_.uint64profilevalue_value_;
}
inline ::holo::map::adasisv3::UInt64ProfileValue* ProfileEntry::release_uint64profilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.UInt64ProfileValue_value)
  if (has_uint64profilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::UInt64ProfileValue* temp = value_.uint64profilevalue_value_;
    value_.uint64profilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::UInt64ProfileValue& ProfileEntry::uint64profilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.UInt64ProfileValue_value)
  return has_uint64profilevalue_value()
      ? *value_.uint64profilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::UInt64ProfileValue*>(&::holo::map::adasisv3::_UInt64ProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::UInt64ProfileValue* ProfileEntry::mutable_uint64profilevalue_value() {
  if (!has_uint64profilevalue_value()) {
    clear_value();
    set_has_uint64profilevalue_value();
    value_.uint64profilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::UInt64ProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.UInt64ProfileValue_value)
  return value_.uint64profilevalue_value_;
}

// optional .holo.map.adasisv3.FloatProfileValue FloatProfileValue_value = 16;
inline bool ProfileEntry::has_floatprofilevalue_value() const {
  return value_case() == kFloatProfileValueValue;
}
inline void ProfileEntry::set_has_floatprofilevalue_value() {
  _oneof_case_[0] = kFloatProfileValueValue;
}
inline void ProfileEntry::clear_floatprofilevalue_value() {
  if (has_floatprofilevalue_value()) {
    delete value_.floatprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::FloatProfileValue& ProfileEntry::_internal_floatprofilevalue_value() const {
  return *value_.floatprofilevalue_value_;
}
inline ::holo::map::adasisv3::FloatProfileValue* ProfileEntry::release_floatprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.FloatProfileValue_value)
  if (has_floatprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::FloatProfileValue* temp = value_.floatprofilevalue_value_;
    value_.floatprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::FloatProfileValue& ProfileEntry::floatprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.FloatProfileValue_value)
  return has_floatprofilevalue_value()
      ? *value_.floatprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::FloatProfileValue*>(&::holo::map::adasisv3::_FloatProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::FloatProfileValue* ProfileEntry::mutable_floatprofilevalue_value() {
  if (!has_floatprofilevalue_value()) {
    clear_value();
    set_has_floatprofilevalue_value();
    value_.floatprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::FloatProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.FloatProfileValue_value)
  return value_.floatprofilevalue_value_;
}

// optional .holo.map.adasisv3.BooleanProfileValue BooleanProfileValue_value = 17;
inline bool ProfileEntry::has_booleanprofilevalue_value() const {
  return value_case() == kBooleanProfileValueValue;
}
inline void ProfileEntry::set_has_booleanprofilevalue_value() {
  _oneof_case_[0] = kBooleanProfileValueValue;
}
inline void ProfileEntry::clear_booleanprofilevalue_value() {
  if (has_booleanprofilevalue_value()) {
    delete value_.booleanprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::BooleanProfileValue& ProfileEntry::_internal_booleanprofilevalue_value() const {
  return *value_.booleanprofilevalue_value_;
}
inline ::holo::map::adasisv3::BooleanProfileValue* ProfileEntry::release_booleanprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.BooleanProfileValue_value)
  if (has_booleanprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::BooleanProfileValue* temp = value_.booleanprofilevalue_value_;
    value_.booleanprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::BooleanProfileValue& ProfileEntry::booleanprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.BooleanProfileValue_value)
  return has_booleanprofilevalue_value()
      ? *value_.booleanprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::BooleanProfileValue*>(&::holo::map::adasisv3::_BooleanProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::BooleanProfileValue* ProfileEntry::mutable_booleanprofilevalue_value() {
  if (!has_booleanprofilevalue_value()) {
    clear_value();
    set_has_booleanprofilevalue_value();
    value_.booleanprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::BooleanProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.BooleanProfileValue_value)
  return value_.booleanprofilevalue_value_;
}

// optional .holo.map.adasisv3.YesNoUnknownProfileValue YesNoUnknownProfileValue_value = 18;
inline bool ProfileEntry::has_yesnounknownprofilevalue_value() const {
  return value_case() == kYesNoUnknownProfileValueValue;
}
inline void ProfileEntry::set_has_yesnounknownprofilevalue_value() {
  _oneof_case_[0] = kYesNoUnknownProfileValueValue;
}
inline void ProfileEntry::clear_yesnounknownprofilevalue_value() {
  if (has_yesnounknownprofilevalue_value()) {
    delete value_.yesnounknownprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::YesNoUnknownProfileValue& ProfileEntry::_internal_yesnounknownprofilevalue_value() const {
  return *value_.yesnounknownprofilevalue_value_;
}
inline ::holo::map::adasisv3::YesNoUnknownProfileValue* ProfileEntry::release_yesnounknownprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.YesNoUnknownProfileValue_value)
  if (has_yesnounknownprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::YesNoUnknownProfileValue* temp = value_.yesnounknownprofilevalue_value_;
    value_.yesnounknownprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::YesNoUnknownProfileValue& ProfileEntry::yesnounknownprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.YesNoUnknownProfileValue_value)
  return has_yesnounknownprofilevalue_value()
      ? *value_.yesnounknownprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::YesNoUnknownProfileValue*>(&::holo::map::adasisv3::_YesNoUnknownProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::YesNoUnknownProfileValue* ProfileEntry::mutable_yesnounknownprofilevalue_value() {
  if (!has_yesnounknownprofilevalue_value()) {
    clear_value();
    set_has_yesnounknownprofilevalue_value();
    value_.yesnounknownprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::YesNoUnknownProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.YesNoUnknownProfileValue_value)
  return value_.yesnounknownprofilevalue_value_;
}

// optional .holo.map.adasisv3.FormOfWayProfileValue FormOfWayProfileValue_value = 19;
inline bool ProfileEntry::has_formofwayprofilevalue_value() const {
  return value_case() == kFormOfWayProfileValueValue;
}
inline void ProfileEntry::set_has_formofwayprofilevalue_value() {
  _oneof_case_[0] = kFormOfWayProfileValueValue;
}
inline void ProfileEntry::clear_formofwayprofilevalue_value() {
  if (has_formofwayprofilevalue_value()) {
    delete value_.formofwayprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::FormOfWayProfileValue& ProfileEntry::_internal_formofwayprofilevalue_value() const {
  return *value_.formofwayprofilevalue_value_;
}
inline ::holo::map::adasisv3::FormOfWayProfileValue* ProfileEntry::release_formofwayprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.FormOfWayProfileValue_value)
  if (has_formofwayprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::FormOfWayProfileValue* temp = value_.formofwayprofilevalue_value_;
    value_.formofwayprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::FormOfWayProfileValue& ProfileEntry::formofwayprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.FormOfWayProfileValue_value)
  return has_formofwayprofilevalue_value()
      ? *value_.formofwayprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::FormOfWayProfileValue*>(&::holo::map::adasisv3::_FormOfWayProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::FormOfWayProfileValue* ProfileEntry::mutable_formofwayprofilevalue_value() {
  if (!has_formofwayprofilevalue_value()) {
    clear_value();
    set_has_formofwayprofilevalue_value();
    value_.formofwayprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::FormOfWayProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.FormOfWayProfileValue_value)
  return value_.formofwayprofilevalue_value_;
}

// optional .holo.map.adasisv3.DrivingSideProfileValue DrivingSideProfileValue_value = 20;
inline bool ProfileEntry::has_drivingsideprofilevalue_value() const {
  return value_case() == kDrivingSideProfileValueValue;
}
inline void ProfileEntry::set_has_drivingsideprofilevalue_value() {
  _oneof_case_[0] = kDrivingSideProfileValueValue;
}
inline void ProfileEntry::clear_drivingsideprofilevalue_value() {
  if (has_drivingsideprofilevalue_value()) {
    delete value_.drivingsideprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::DrivingSideProfileValue& ProfileEntry::_internal_drivingsideprofilevalue_value() const {
  return *value_.drivingsideprofilevalue_value_;
}
inline ::holo::map::adasisv3::DrivingSideProfileValue* ProfileEntry::release_drivingsideprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.DrivingSideProfileValue_value)
  if (has_drivingsideprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::DrivingSideProfileValue* temp = value_.drivingsideprofilevalue_value_;
    value_.drivingsideprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::DrivingSideProfileValue& ProfileEntry::drivingsideprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.DrivingSideProfileValue_value)
  return has_drivingsideprofilevalue_value()
      ? *value_.drivingsideprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::DrivingSideProfileValue*>(&::holo::map::adasisv3::_DrivingSideProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::DrivingSideProfileValue* ProfileEntry::mutable_drivingsideprofilevalue_value() {
  if (!has_drivingsideprofilevalue_value()) {
    clear_value();
    set_has_drivingsideprofilevalue_value();
    value_.drivingsideprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::DrivingSideProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.DrivingSideProfileValue_value)
  return value_.drivingsideprofilevalue_value_;
}

// optional .holo.map.adasisv3.UnitSystemProfileValue UnitSystemProfileValue_value = 21;
inline bool ProfileEntry::has_unitsystemprofilevalue_value() const {
  return value_case() == kUnitSystemProfileValueValue;
}
inline void ProfileEntry::set_has_unitsystemprofilevalue_value() {
  _oneof_case_[0] = kUnitSystemProfileValueValue;
}
inline void ProfileEntry::clear_unitsystemprofilevalue_value() {
  if (has_unitsystemprofilevalue_value()) {
    delete value_.unitsystemprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::UnitSystemProfileValue& ProfileEntry::_internal_unitsystemprofilevalue_value() const {
  return *value_.unitsystemprofilevalue_value_;
}
inline ::holo::map::adasisv3::UnitSystemProfileValue* ProfileEntry::release_unitsystemprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.UnitSystemProfileValue_value)
  if (has_unitsystemprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::UnitSystemProfileValue* temp = value_.unitsystemprofilevalue_value_;
    value_.unitsystemprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::UnitSystemProfileValue& ProfileEntry::unitsystemprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.UnitSystemProfileValue_value)
  return has_unitsystemprofilevalue_value()
      ? *value_.unitsystemprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::UnitSystemProfileValue*>(&::holo::map::adasisv3::_UnitSystemProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::UnitSystemProfileValue* ProfileEntry::mutable_unitsystemprofilevalue_value() {
  if (!has_unitsystemprofilevalue_value()) {
    clear_value();
    set_has_unitsystemprofilevalue_value();
    value_.unitsystemprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::UnitSystemProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.UnitSystemProfileValue_value)
  return value_.unitsystemprofilevalue_value_;
}

// optional .holo.map.adasisv3.SpecialSituationProfileValue SpecialSituationProfileValue_value = 22;
inline bool ProfileEntry::has_specialsituationprofilevalue_value() const {
  return value_case() == kSpecialSituationProfileValueValue;
}
inline void ProfileEntry::set_has_specialsituationprofilevalue_value() {
  _oneof_case_[0] = kSpecialSituationProfileValueValue;
}
inline void ProfileEntry::clear_specialsituationprofilevalue_value() {
  if (has_specialsituationprofilevalue_value()) {
    delete value_.specialsituationprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::SpecialSituationProfileValue& ProfileEntry::_internal_specialsituationprofilevalue_value() const {
  return *value_.specialsituationprofilevalue_value_;
}
inline ::holo::map::adasisv3::SpecialSituationProfileValue* ProfileEntry::release_specialsituationprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.SpecialSituationProfileValue_value)
  if (has_specialsituationprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::SpecialSituationProfileValue* temp = value_.specialsituationprofilevalue_value_;
    value_.specialsituationprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::SpecialSituationProfileValue& ProfileEntry::specialsituationprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.SpecialSituationProfileValue_value)
  return has_specialsituationprofilevalue_value()
      ? *value_.specialsituationprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::SpecialSituationProfileValue*>(&::holo::map::adasisv3::_SpecialSituationProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::SpecialSituationProfileValue* ProfileEntry::mutable_specialsituationprofilevalue_value() {
  if (!has_specialsituationprofilevalue_value()) {
    clear_value();
    set_has_specialsituationprofilevalue_value();
    value_.specialsituationprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::SpecialSituationProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.SpecialSituationProfileValue_value)
  return value_.specialsituationprofilevalue_value_;
}

// optional .holo.map.adasisv3.RoadConditionProfileValue RoadConditionProfileValue_value = 23;
inline bool ProfileEntry::has_roadconditionprofilevalue_value() const {
  return value_case() == kRoadConditionProfileValueValue;
}
inline void ProfileEntry::set_has_roadconditionprofilevalue_value() {
  _oneof_case_[0] = kRoadConditionProfileValueValue;
}
inline void ProfileEntry::clear_roadconditionprofilevalue_value() {
  if (has_roadconditionprofilevalue_value()) {
    delete value_.roadconditionprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::RoadConditionProfileValue& ProfileEntry::_internal_roadconditionprofilevalue_value() const {
  return *value_.roadconditionprofilevalue_value_;
}
inline ::holo::map::adasisv3::RoadConditionProfileValue* ProfileEntry::release_roadconditionprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.RoadConditionProfileValue_value)
  if (has_roadconditionprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::RoadConditionProfileValue* temp = value_.roadconditionprofilevalue_value_;
    value_.roadconditionprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::RoadConditionProfileValue& ProfileEntry::roadconditionprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.RoadConditionProfileValue_value)
  return has_roadconditionprofilevalue_value()
      ? *value_.roadconditionprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::RoadConditionProfileValue*>(&::holo::map::adasisv3::_RoadConditionProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::RoadConditionProfileValue* ProfileEntry::mutable_roadconditionprofilevalue_value() {
  if (!has_roadconditionprofilevalue_value()) {
    clear_value();
    set_has_roadconditionprofilevalue_value();
    value_.roadconditionprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::RoadConditionProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.RoadConditionProfileValue_value)
  return value_.roadconditionprofilevalue_value_;
}

// optional .holo.map.adasisv3.WeatherProfileValue WeatherProfileValue_value = 24;
inline bool ProfileEntry::has_weatherprofilevalue_value() const {
  return value_case() == kWeatherProfileValueValue;
}
inline void ProfileEntry::set_has_weatherprofilevalue_value() {
  _oneof_case_[0] = kWeatherProfileValueValue;
}
inline void ProfileEntry::clear_weatherprofilevalue_value() {
  if (has_weatherprofilevalue_value()) {
    delete value_.weatherprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::WeatherProfileValue& ProfileEntry::_internal_weatherprofilevalue_value() const {
  return *value_.weatherprofilevalue_value_;
}
inline ::holo::map::adasisv3::WeatherProfileValue* ProfileEntry::release_weatherprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.WeatherProfileValue_value)
  if (has_weatherprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::WeatherProfileValue* temp = value_.weatherprofilevalue_value_;
    value_.weatherprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::WeatherProfileValue& ProfileEntry::weatherprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.WeatherProfileValue_value)
  return has_weatherprofilevalue_value()
      ? *value_.weatherprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::WeatherProfileValue*>(&::holo::map::adasisv3::_WeatherProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::WeatherProfileValue* ProfileEntry::mutable_weatherprofilevalue_value() {
  if (!has_weatherprofilevalue_value()) {
    clear_value();
    set_has_weatherprofilevalue_value();
    value_.weatherprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::WeatherProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.WeatherProfileValue_value)
  return value_.weatherprofilevalue_value_;
}

// optional .holo.map.adasisv3.MapProviderProfileValue MapProviderProfileValue_value = 25;
inline bool ProfileEntry::has_mapproviderprofilevalue_value() const {
  return value_case() == kMapProviderProfileValueValue;
}
inline void ProfileEntry::set_has_mapproviderprofilevalue_value() {
  _oneof_case_[0] = kMapProviderProfileValueValue;
}
inline void ProfileEntry::clear_mapproviderprofilevalue_value() {
  if (has_mapproviderprofilevalue_value()) {
    delete value_.mapproviderprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::MapProviderProfileValue& ProfileEntry::_internal_mapproviderprofilevalue_value() const {
  return *value_.mapproviderprofilevalue_value_;
}
inline ::holo::map::adasisv3::MapProviderProfileValue* ProfileEntry::release_mapproviderprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.MapProviderProfileValue_value)
  if (has_mapproviderprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::MapProviderProfileValue* temp = value_.mapproviderprofilevalue_value_;
    value_.mapproviderprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::MapProviderProfileValue& ProfileEntry::mapproviderprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.MapProviderProfileValue_value)
  return has_mapproviderprofilevalue_value()
      ? *value_.mapproviderprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::MapProviderProfileValue*>(&::holo::map::adasisv3::_MapProviderProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::MapProviderProfileValue* ProfileEntry::mutable_mapproviderprofilevalue_value() {
  if (!has_mapproviderprofilevalue_value()) {
    clear_value();
    set_has_mapproviderprofilevalue_value();
    value_.mapproviderprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::MapProviderProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.MapProviderProfileValue_value)
  return value_.mapproviderprofilevalue_value_;
}

// optional .holo.map.adasisv3.MapStatusProfileValue MapStatusProfileValue_value = 26;
inline bool ProfileEntry::has_mapstatusprofilevalue_value() const {
  return value_case() == kMapStatusProfileValueValue;
}
inline void ProfileEntry::set_has_mapstatusprofilevalue_value() {
  _oneof_case_[0] = kMapStatusProfileValueValue;
}
inline void ProfileEntry::clear_mapstatusprofilevalue_value() {
  if (has_mapstatusprofilevalue_value()) {
    delete value_.mapstatusprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::MapStatusProfileValue& ProfileEntry::_internal_mapstatusprofilevalue_value() const {
  return *value_.mapstatusprofilevalue_value_;
}
inline ::holo::map::adasisv3::MapStatusProfileValue* ProfileEntry::release_mapstatusprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.MapStatusProfileValue_value)
  if (has_mapstatusprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::MapStatusProfileValue* temp = value_.mapstatusprofilevalue_value_;
    value_.mapstatusprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::MapStatusProfileValue& ProfileEntry::mapstatusprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.MapStatusProfileValue_value)
  return has_mapstatusprofilevalue_value()
      ? *value_.mapstatusprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::MapStatusProfileValue*>(&::holo::map::adasisv3::_MapStatusProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::MapStatusProfileValue* ProfileEntry::mutable_mapstatusprofilevalue_value() {
  if (!has_mapstatusprofilevalue_value()) {
    clear_value();
    set_has_mapstatusprofilevalue_value();
    value_.mapstatusprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::MapStatusProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.MapStatusProfileValue_value)
  return value_.mapstatusprofilevalue_value_;
}

// optional .holo.map.adasisv3.OffsetFloatProfileValue OffsetFloatProfileValue_value = 27;
inline bool ProfileEntry::has_offsetfloatprofilevalue_value() const {
  return value_case() == kOffsetFloatProfileValueValue;
}
inline void ProfileEntry::set_has_offsetfloatprofilevalue_value() {
  _oneof_case_[0] = kOffsetFloatProfileValueValue;
}
inline void ProfileEntry::clear_offsetfloatprofilevalue_value() {
  if (has_offsetfloatprofilevalue_value()) {
    delete value_.offsetfloatprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::OffsetFloatProfileValue& ProfileEntry::_internal_offsetfloatprofilevalue_value() const {
  return *value_.offsetfloatprofilevalue_value_;
}
inline ::holo::map::adasisv3::OffsetFloatProfileValue* ProfileEntry::release_offsetfloatprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.OffsetFloatProfileValue_value)
  if (has_offsetfloatprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::OffsetFloatProfileValue* temp = value_.offsetfloatprofilevalue_value_;
    value_.offsetfloatprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::OffsetFloatProfileValue& ProfileEntry::offsetfloatprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.OffsetFloatProfileValue_value)
  return has_offsetfloatprofilevalue_value()
      ? *value_.offsetfloatprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::OffsetFloatProfileValue*>(&::holo::map::adasisv3::_OffsetFloatProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::OffsetFloatProfileValue* ProfileEntry::mutable_offsetfloatprofilevalue_value() {
  if (!has_offsetfloatprofilevalue_value()) {
    clear_value();
    set_has_offsetfloatprofilevalue_value();
    value_.offsetfloatprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::OffsetFloatProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.OffsetFloatProfileValue_value)
  return value_.offsetfloatprofilevalue_value_;
}

// optional .holo.map.adasisv3.NodeProfileValue NodeProfileValue_value = 28;
inline bool ProfileEntry::has_nodeprofilevalue_value() const {
  return value_case() == kNodeProfileValueValue;
}
inline void ProfileEntry::set_has_nodeprofilevalue_value() {
  _oneof_case_[0] = kNodeProfileValueValue;
}
inline void ProfileEntry::clear_nodeprofilevalue_value() {
  if (has_nodeprofilevalue_value()) {
    delete value_.nodeprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::NodeProfileValue& ProfileEntry::_internal_nodeprofilevalue_value() const {
  return *value_.nodeprofilevalue_value_;
}
inline ::holo::map::adasisv3::NodeProfileValue* ProfileEntry::release_nodeprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.NodeProfileValue_value)
  if (has_nodeprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::NodeProfileValue* temp = value_.nodeprofilevalue_value_;
    value_.nodeprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::NodeProfileValue& ProfileEntry::nodeprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.NodeProfileValue_value)
  return has_nodeprofilevalue_value()
      ? *value_.nodeprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::NodeProfileValue*>(&::holo::map::adasisv3::_NodeProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::NodeProfileValue* ProfileEntry::mutable_nodeprofilevalue_value() {
  if (!has_nodeprofilevalue_value()) {
    clear_value();
    set_has_nodeprofilevalue_value();
    value_.nodeprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::NodeProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.NodeProfileValue_value)
  return value_.nodeprofilevalue_value_;
}

// optional .holo.map.adasisv3.SystemStatusProfileValue SystemStatusProfileValue_value = 29;
inline bool ProfileEntry::has_systemstatusprofilevalue_value() const {
  return value_case() == kSystemStatusProfileValueValue;
}
inline void ProfileEntry::set_has_systemstatusprofilevalue_value() {
  _oneof_case_[0] = kSystemStatusProfileValueValue;
}
inline void ProfileEntry::clear_systemstatusprofilevalue_value() {
  if (has_systemstatusprofilevalue_value()) {
    delete value_.systemstatusprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::SystemStatusProfileValue& ProfileEntry::_internal_systemstatusprofilevalue_value() const {
  return *value_.systemstatusprofilevalue_value_;
}
inline ::holo::map::adasisv3::SystemStatusProfileValue* ProfileEntry::release_systemstatusprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.SystemStatusProfileValue_value)
  if (has_systemstatusprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::SystemStatusProfileValue* temp = value_.systemstatusprofilevalue_value_;
    value_.systemstatusprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::SystemStatusProfileValue& ProfileEntry::systemstatusprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.SystemStatusProfileValue_value)
  return has_systemstatusprofilevalue_value()
      ? *value_.systemstatusprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::SystemStatusProfileValue*>(&::holo::map::adasisv3::_SystemStatusProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::SystemStatusProfileValue* ProfileEntry::mutable_systemstatusprofilevalue_value() {
  if (!has_systemstatusprofilevalue_value()) {
    clear_value();
    set_has_systemstatusprofilevalue_value();
    value_.systemstatusprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::SystemStatusProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.SystemStatusProfileValue_value)
  return value_.systemstatusprofilevalue_value_;
}

// optional .holo.map.adasisv3.AbsoluteVehiclePositionProfileValue AbsoluteVehiclePositionProfileValue_value = 30;
inline bool ProfileEntry::has_absolutevehiclepositionprofilevalue_value() const {
  return value_case() == kAbsoluteVehiclePositionProfileValueValue;
}
inline void ProfileEntry::set_has_absolutevehiclepositionprofilevalue_value() {
  _oneof_case_[0] = kAbsoluteVehiclePositionProfileValueValue;
}
inline void ProfileEntry::clear_absolutevehiclepositionprofilevalue_value() {
  if (has_absolutevehiclepositionprofilevalue_value()) {
    delete value_.absolutevehiclepositionprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue& ProfileEntry::_internal_absolutevehiclepositionprofilevalue_value() const {
  return *value_.absolutevehiclepositionprofilevalue_value_;
}
inline ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* ProfileEntry::release_absolutevehiclepositionprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.AbsoluteVehiclePositionProfileValue_value)
  if (has_absolutevehiclepositionprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* temp = value_.absolutevehiclepositionprofilevalue_value_;
    value_.absolutevehiclepositionprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue& ProfileEntry::absolutevehiclepositionprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.AbsoluteVehiclePositionProfileValue_value)
  return has_absolutevehiclepositionprofilevalue_value()
      ? *value_.absolutevehiclepositionprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue*>(&::holo::map::adasisv3::_AbsoluteVehiclePositionProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* ProfileEntry::mutable_absolutevehiclepositionprofilevalue_value() {
  if (!has_absolutevehiclepositionprofilevalue_value()) {
    clear_value();
    set_has_absolutevehiclepositionprofilevalue_value();
    value_.absolutevehiclepositionprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.AbsoluteVehiclePositionProfileValue_value)
  return value_.absolutevehiclepositionprofilevalue_value_;
}

// optional .holo.map.adasisv3.SurfaceConditionProfileValue SurfaceConditionProfileValue_value = 31;
inline bool ProfileEntry::has_surfaceconditionprofilevalue_value() const {
  return value_case() == kSurfaceConditionProfileValueValue;
}
inline void ProfileEntry::set_has_surfaceconditionprofilevalue_value() {
  _oneof_case_[0] = kSurfaceConditionProfileValueValue;
}
inline void ProfileEntry::clear_surfaceconditionprofilevalue_value() {
  if (has_surfaceconditionprofilevalue_value()) {
    delete value_.surfaceconditionprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::SurfaceConditionProfileValue& ProfileEntry::_internal_surfaceconditionprofilevalue_value() const {
  return *value_.surfaceconditionprofilevalue_value_;
}
inline ::holo::map::adasisv3::SurfaceConditionProfileValue* ProfileEntry::release_surfaceconditionprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.SurfaceConditionProfileValue_value)
  if (has_surfaceconditionprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::SurfaceConditionProfileValue* temp = value_.surfaceconditionprofilevalue_value_;
    value_.surfaceconditionprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::SurfaceConditionProfileValue& ProfileEntry::surfaceconditionprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.SurfaceConditionProfileValue_value)
  return has_surfaceconditionprofilevalue_value()
      ? *value_.surfaceconditionprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::SurfaceConditionProfileValue*>(&::holo::map::adasisv3::_SurfaceConditionProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::SurfaceConditionProfileValue* ProfileEntry::mutable_surfaceconditionprofilevalue_value() {
  if (!has_surfaceconditionprofilevalue_value()) {
    clear_value();
    set_has_surfaceconditionprofilevalue_value();
    value_.surfaceconditionprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::SurfaceConditionProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.SurfaceConditionProfileValue_value)
  return value_.surfaceconditionprofilevalue_value_;
}

// optional .holo.map.adasisv3.SpeedProfileValue SpeedProfileValue_value = 32;
inline bool ProfileEntry::has_speedprofilevalue_value() const {
  return value_case() == kSpeedProfileValueValue;
}
inline void ProfileEntry::set_has_speedprofilevalue_value() {
  _oneof_case_[0] = kSpeedProfileValueValue;
}
inline void ProfileEntry::clear_speedprofilevalue_value() {
  if (has_speedprofilevalue_value()) {
    delete value_.speedprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::SpeedProfileValue& ProfileEntry::_internal_speedprofilevalue_value() const {
  return *value_.speedprofilevalue_value_;
}
inline ::holo::map::adasisv3::SpeedProfileValue* ProfileEntry::release_speedprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.SpeedProfileValue_value)
  if (has_speedprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::SpeedProfileValue* temp = value_.speedprofilevalue_value_;
    value_.speedprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::SpeedProfileValue& ProfileEntry::speedprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.SpeedProfileValue_value)
  return has_speedprofilevalue_value()
      ? *value_.speedprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::SpeedProfileValue*>(&::holo::map::adasisv3::_SpeedProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::SpeedProfileValue* ProfileEntry::mutable_speedprofilevalue_value() {
  if (!has_speedprofilevalue_value()) {
    clear_value();
    set_has_speedprofilevalue_value();
    value_.speedprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::SpeedProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.SpeedProfileValue_value)
  return value_.speedprofilevalue_value_;
}

// optional .holo.map.adasisv3.LaneModelValue LaneModelValue_value = 33;
inline bool ProfileEntry::has_lanemodelvalue_value() const {
  return value_case() == kLaneModelValueValue;
}
inline void ProfileEntry::set_has_lanemodelvalue_value() {
  _oneof_case_[0] = kLaneModelValueValue;
}
inline void ProfileEntry::clear_lanemodelvalue_value() {
  if (has_lanemodelvalue_value()) {
    delete value_.lanemodelvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LaneModelValue& ProfileEntry::_internal_lanemodelvalue_value() const {
  return *value_.lanemodelvalue_value_;
}
inline ::holo::map::adasisv3::LaneModelValue* ProfileEntry::release_lanemodelvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.LaneModelValue_value)
  if (has_lanemodelvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LaneModelValue* temp = value_.lanemodelvalue_value_;
    value_.lanemodelvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LaneModelValue& ProfileEntry::lanemodelvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.LaneModelValue_value)
  return has_lanemodelvalue_value()
      ? *value_.lanemodelvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LaneModelValue*>(&::holo::map::adasisv3::_LaneModelValue_default_instance_);
}
inline ::holo::map::adasisv3::LaneModelValue* ProfileEntry::mutable_lanemodelvalue_value() {
  if (!has_lanemodelvalue_value()) {
    clear_value();
    set_has_lanemodelvalue_value();
    value_.lanemodelvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LaneModelValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.LaneModelValue_value)
  return value_.lanemodelvalue_value_;
}

// optional .holo.map.adasisv3.LaneConnectivityValue LaneConnectivityValue_value = 34;
inline bool ProfileEntry::has_laneconnectivityvalue_value() const {
  return value_case() == kLaneConnectivityValueValue;
}
inline void ProfileEntry::set_has_laneconnectivityvalue_value() {
  _oneof_case_[0] = kLaneConnectivityValueValue;
}
inline void ProfileEntry::clear_laneconnectivityvalue_value() {
  if (has_laneconnectivityvalue_value()) {
    delete value_.laneconnectivityvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LaneConnectivityValue& ProfileEntry::_internal_laneconnectivityvalue_value() const {
  return *value_.laneconnectivityvalue_value_;
}
inline ::holo::map::adasisv3::LaneConnectivityValue* ProfileEntry::release_laneconnectivityvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.LaneConnectivityValue_value)
  if (has_laneconnectivityvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LaneConnectivityValue* temp = value_.laneconnectivityvalue_value_;
    value_.laneconnectivityvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LaneConnectivityValue& ProfileEntry::laneconnectivityvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.LaneConnectivityValue_value)
  return has_laneconnectivityvalue_value()
      ? *value_.laneconnectivityvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LaneConnectivityValue*>(&::holo::map::adasisv3::_LaneConnectivityValue_default_instance_);
}
inline ::holo::map::adasisv3::LaneConnectivityValue* ProfileEntry::mutable_laneconnectivityvalue_value() {
  if (!has_laneconnectivityvalue_value()) {
    clear_value();
    set_has_laneconnectivityvalue_value();
    value_.laneconnectivityvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LaneConnectivityValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.LaneConnectivityValue_value)
  return value_.laneconnectivityvalue_value_;
}

// optional .holo.map.adasisv3.LinearObjectDefinitionValue LinearObjectDefinitionValue_value = 35;
inline bool ProfileEntry::has_linearobjectdefinitionvalue_value() const {
  return value_case() == kLinearObjectDefinitionValueValue;
}
inline void ProfileEntry::set_has_linearobjectdefinitionvalue_value() {
  _oneof_case_[0] = kLinearObjectDefinitionValueValue;
}
inline void ProfileEntry::clear_linearobjectdefinitionvalue_value() {
  if (has_linearobjectdefinitionvalue_value()) {
    delete value_.linearobjectdefinitionvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LinearObjectDefinitionValue& ProfileEntry::_internal_linearobjectdefinitionvalue_value() const {
  return *value_.linearobjectdefinitionvalue_value_;
}
inline ::holo::map::adasisv3::LinearObjectDefinitionValue* ProfileEntry::release_linearobjectdefinitionvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.LinearObjectDefinitionValue_value)
  if (has_linearobjectdefinitionvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LinearObjectDefinitionValue* temp = value_.linearobjectdefinitionvalue_value_;
    value_.linearobjectdefinitionvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LinearObjectDefinitionValue& ProfileEntry::linearobjectdefinitionvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.LinearObjectDefinitionValue_value)
  return has_linearobjectdefinitionvalue_value()
      ? *value_.linearobjectdefinitionvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LinearObjectDefinitionValue*>(&::holo::map::adasisv3::_LinearObjectDefinitionValue_default_instance_);
}
inline ::holo::map::adasisv3::LinearObjectDefinitionValue* ProfileEntry::mutable_linearobjectdefinitionvalue_value() {
  if (!has_linearobjectdefinitionvalue_value()) {
    clear_value();
    set_has_linearobjectdefinitionvalue_value();
    value_.linearobjectdefinitionvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LinearObjectDefinitionValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.LinearObjectDefinitionValue_value)
  return value_.linearobjectdefinitionvalue_value_;
}

// optional .holo.map.adasisv3.LanesGeometryProfileValue LanesGeometryProfileValue_value = 36;
inline bool ProfileEntry::has_lanesgeometryprofilevalue_value() const {
  return value_case() == kLanesGeometryProfileValueValue;
}
inline void ProfileEntry::set_has_lanesgeometryprofilevalue_value() {
  _oneof_case_[0] = kLanesGeometryProfileValueValue;
}
inline void ProfileEntry::clear_lanesgeometryprofilevalue_value() {
  if (has_lanesgeometryprofilevalue_value()) {
    delete value_.lanesgeometryprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LanesGeometryProfileValue& ProfileEntry::_internal_lanesgeometryprofilevalue_value() const {
  return *value_.lanesgeometryprofilevalue_value_;
}
inline ::holo::map::adasisv3::LanesGeometryProfileValue* ProfileEntry::release_lanesgeometryprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.LanesGeometryProfileValue_value)
  if (has_lanesgeometryprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LanesGeometryProfileValue* temp = value_.lanesgeometryprofilevalue_value_;
    value_.lanesgeometryprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LanesGeometryProfileValue& ProfileEntry::lanesgeometryprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.LanesGeometryProfileValue_value)
  return has_lanesgeometryprofilevalue_value()
      ? *value_.lanesgeometryprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LanesGeometryProfileValue*>(&::holo::map::adasisv3::_LanesGeometryProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::LanesGeometryProfileValue* ProfileEntry::mutable_lanesgeometryprofilevalue_value() {
  if (!has_lanesgeometryprofilevalue_value()) {
    clear_value();
    set_has_lanesgeometryprofilevalue_value();
    value_.lanesgeometryprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LanesGeometryProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.LanesGeometryProfileValue_value)
  return value_.lanesgeometryprofilevalue_value_;
}

// optional .holo.map.adasisv3.RoadGeometryProfileValue RoadGeometryProfileValue_value = 37;
inline bool ProfileEntry::has_roadgeometryprofilevalue_value() const {
  return value_case() == kRoadGeometryProfileValueValue;
}
inline void ProfileEntry::set_has_roadgeometryprofilevalue_value() {
  _oneof_case_[0] = kRoadGeometryProfileValueValue;
}
inline void ProfileEntry::clear_roadgeometryprofilevalue_value() {
  if (has_roadgeometryprofilevalue_value()) {
    delete value_.roadgeometryprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::RoadGeometryProfileValue& ProfileEntry::_internal_roadgeometryprofilevalue_value() const {
  return *value_.roadgeometryprofilevalue_value_;
}
inline ::holo::map::adasisv3::RoadGeometryProfileValue* ProfileEntry::release_roadgeometryprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.RoadGeometryProfileValue_value)
  if (has_roadgeometryprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::RoadGeometryProfileValue* temp = value_.roadgeometryprofilevalue_value_;
    value_.roadgeometryprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::RoadGeometryProfileValue& ProfileEntry::roadgeometryprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.RoadGeometryProfileValue_value)
  return has_roadgeometryprofilevalue_value()
      ? *value_.roadgeometryprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::RoadGeometryProfileValue*>(&::holo::map::adasisv3::_RoadGeometryProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::RoadGeometryProfileValue* ProfileEntry::mutable_roadgeometryprofilevalue_value() {
  if (!has_roadgeometryprofilevalue_value()) {
    clear_value();
    set_has_roadgeometryprofilevalue_value();
    value_.roadgeometryprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::RoadGeometryProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.RoadGeometryProfileValue_value)
  return value_.roadgeometryprofilevalue_value_;
}

// optional .holo.map.adasisv3.TrafficLightProfileValue TrafficLightProfileValue_value = 38;
inline bool ProfileEntry::has_trafficlightprofilevalue_value() const {
  return value_case() == kTrafficLightProfileValueValue;
}
inline void ProfileEntry::set_has_trafficlightprofilevalue_value() {
  _oneof_case_[0] = kTrafficLightProfileValueValue;
}
inline void ProfileEntry::clear_trafficlightprofilevalue_value() {
  if (has_trafficlightprofilevalue_value()) {
    delete value_.trafficlightprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::TrafficLightProfileValue& ProfileEntry::_internal_trafficlightprofilevalue_value() const {
  return *value_.trafficlightprofilevalue_value_;
}
inline ::holo::map::adasisv3::TrafficLightProfileValue* ProfileEntry::release_trafficlightprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.TrafficLightProfileValue_value)
  if (has_trafficlightprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::TrafficLightProfileValue* temp = value_.trafficlightprofilevalue_value_;
    value_.trafficlightprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::TrafficLightProfileValue& ProfileEntry::trafficlightprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.TrafficLightProfileValue_value)
  return has_trafficlightprofilevalue_value()
      ? *value_.trafficlightprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::TrafficLightProfileValue*>(&::holo::map::adasisv3::_TrafficLightProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::TrafficLightProfileValue* ProfileEntry::mutable_trafficlightprofilevalue_value() {
  if (!has_trafficlightprofilevalue_value()) {
    clear_value();
    set_has_trafficlightprofilevalue_value();
    value_.trafficlightprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::TrafficLightProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.TrafficLightProfileValue_value)
  return value_.trafficlightprofilevalue_value_;
}

// optional .holo.map.adasisv3.EffectiveSpeedLimit EffectiveSpeedLimit_value = 39;
inline bool ProfileEntry::has_effectivespeedlimit_value() const {
  return value_case() == kEffectiveSpeedLimitValue;
}
inline void ProfileEntry::set_has_effectivespeedlimit_value() {
  _oneof_case_[0] = kEffectiveSpeedLimitValue;
}
inline void ProfileEntry::clear_effectivespeedlimit_value() {
  if (has_effectivespeedlimit_value()) {
    delete value_.effectivespeedlimit_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::EffectiveSpeedLimit& ProfileEntry::_internal_effectivespeedlimit_value() const {
  return *value_.effectivespeedlimit_value_;
}
inline ::holo::map::adasisv3::EffectiveSpeedLimit* ProfileEntry::release_effectivespeedlimit_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.EffectiveSpeedLimit_value)
  if (has_effectivespeedlimit_value()) {
    clear_has_value();
      ::holo::map::adasisv3::EffectiveSpeedLimit* temp = value_.effectivespeedlimit_value_;
    value_.effectivespeedlimit_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::EffectiveSpeedLimit& ProfileEntry::effectivespeedlimit_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.EffectiveSpeedLimit_value)
  return has_effectivespeedlimit_value()
      ? *value_.effectivespeedlimit_value_
      : *reinterpret_cast< ::holo::map::adasisv3::EffectiveSpeedLimit*>(&::holo::map::adasisv3::_EffectiveSpeedLimit_default_instance_);
}
inline ::holo::map::adasisv3::EffectiveSpeedLimit* ProfileEntry::mutable_effectivespeedlimit_value() {
  if (!has_effectivespeedlimit_value()) {
    clear_value();
    set_has_effectivespeedlimit_value();
    value_.effectivespeedlimit_value_ = CreateMaybeMessage< ::holo::map::adasisv3::EffectiveSpeedLimit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.EffectiveSpeedLimit_value)
  return value_.effectivespeedlimit_value_;
}

// optional .holo.map.adasisv3.LocationObject LocationObject_value = 40;
inline bool ProfileEntry::has_locationobject_value() const {
  return value_case() == kLocationObjectValue;
}
inline void ProfileEntry::set_has_locationobject_value() {
  _oneof_case_[0] = kLocationObjectValue;
}
inline void ProfileEntry::clear_locationobject_value() {
  if (has_locationobject_value()) {
    delete value_.locationobject_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LocationObject& ProfileEntry::_internal_locationobject_value() const {
  return *value_.locationobject_value_;
}
inline ::holo::map::adasisv3::LocationObject* ProfileEntry::release_locationobject_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.LocationObject_value)
  if (has_locationobject_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LocationObject* temp = value_.locationobject_value_;
    value_.locationobject_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LocationObject& ProfileEntry::locationobject_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.LocationObject_value)
  return has_locationobject_value()
      ? *value_.locationobject_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LocationObject*>(&::holo::map::adasisv3::_LocationObject_default_instance_);
}
inline ::holo::map::adasisv3::LocationObject* ProfileEntry::mutable_locationobject_value() {
  if (!has_locationobject_value()) {
    clear_value();
    set_has_locationobject_value();
    value_.locationobject_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LocationObject >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.LocationObject_value)
  return value_.locationobject_value_;
}

// optional .holo.map.adasisv3.RegionCodeValue RegionCodeValue_value = 41;
inline bool ProfileEntry::has_regioncodevalue_value() const {
  return value_case() == kRegionCodeValueValue;
}
inline void ProfileEntry::set_has_regioncodevalue_value() {
  _oneof_case_[0] = kRegionCodeValueValue;
}
inline void ProfileEntry::clear_regioncodevalue_value() {
  if (has_regioncodevalue_value()) {
    delete value_.regioncodevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::RegionCodeValue& ProfileEntry::_internal_regioncodevalue_value() const {
  return *value_.regioncodevalue_value_;
}
inline ::holo::map::adasisv3::RegionCodeValue* ProfileEntry::release_regioncodevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.RegionCodeValue_value)
  if (has_regioncodevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::RegionCodeValue* temp = value_.regioncodevalue_value_;
    value_.regioncodevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::RegionCodeValue& ProfileEntry::regioncodevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.RegionCodeValue_value)
  return has_regioncodevalue_value()
      ? *value_.regioncodevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::RegionCodeValue*>(&::holo::map::adasisv3::_RegionCodeValue_default_instance_);
}
inline ::holo::map::adasisv3::RegionCodeValue* ProfileEntry::mutable_regioncodevalue_value() {
  if (!has_regioncodevalue_value()) {
    clear_value();
    set_has_regioncodevalue_value();
    value_.regioncodevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::RegionCodeValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.RegionCodeValue_value)
  return value_.regioncodevalue_value_;
}

// optional .holo.map.adasisv3.ExtendedSpeedLimitValue ExtendedSpeedLimitValue_value = 42;
inline bool ProfileEntry::has_extendedspeedlimitvalue_value() const {
  return value_case() == kExtendedSpeedLimitValueValue;
}
inline void ProfileEntry::set_has_extendedspeedlimitvalue_value() {
  _oneof_case_[0] = kExtendedSpeedLimitValueValue;
}
inline void ProfileEntry::clear_extendedspeedlimitvalue_value() {
  if (has_extendedspeedlimitvalue_value()) {
    delete value_.extendedspeedlimitvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::ExtendedSpeedLimitValue& ProfileEntry::_internal_extendedspeedlimitvalue_value() const {
  return *value_.extendedspeedlimitvalue_value_;
}
inline ::holo::map::adasisv3::ExtendedSpeedLimitValue* ProfileEntry::release_extendedspeedlimitvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.ExtendedSpeedLimitValue_value)
  if (has_extendedspeedlimitvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::ExtendedSpeedLimitValue* temp = value_.extendedspeedlimitvalue_value_;
    value_.extendedspeedlimitvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ExtendedSpeedLimitValue& ProfileEntry::extendedspeedlimitvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.ExtendedSpeedLimitValue_value)
  return has_extendedspeedlimitvalue_value()
      ? *value_.extendedspeedlimitvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::ExtendedSpeedLimitValue*>(&::holo::map::adasisv3::_ExtendedSpeedLimitValue_default_instance_);
}
inline ::holo::map::adasisv3::ExtendedSpeedLimitValue* ProfileEntry::mutable_extendedspeedlimitvalue_value() {
  if (!has_extendedspeedlimitvalue_value()) {
    clear_value();
    set_has_extendedspeedlimitvalue_value();
    value_.extendedspeedlimitvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::ExtendedSpeedLimitValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.ExtendedSpeedLimitValue_value)
  return value_.extendedspeedlimitvalue_value_;
}

// optional .holo.map.adasisv3.TrafficSignValue TrafficSignValue_value = 43;
inline bool ProfileEntry::has_trafficsignvalue_value() const {
  return value_case() == kTrafficSignValueValue;
}
inline void ProfileEntry::set_has_trafficsignvalue_value() {
  _oneof_case_[0] = kTrafficSignValueValue;
}
inline void ProfileEntry::clear_trafficsignvalue_value() {
  if (has_trafficsignvalue_value()) {
    delete value_.trafficsignvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::TrafficSignValue& ProfileEntry::_internal_trafficsignvalue_value() const {
  return *value_.trafficsignvalue_value_;
}
inline ::holo::map::adasisv3::TrafficSignValue* ProfileEntry::release_trafficsignvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.TrafficSignValue_value)
  if (has_trafficsignvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::TrafficSignValue* temp = value_.trafficsignvalue_value_;
    value_.trafficsignvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::TrafficSignValue& ProfileEntry::trafficsignvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.TrafficSignValue_value)
  return has_trafficsignvalue_value()
      ? *value_.trafficsignvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::TrafficSignValue*>(&::holo::map::adasisv3::_TrafficSignValue_default_instance_);
}
inline ::holo::map::adasisv3::TrafficSignValue* ProfileEntry::mutable_trafficsignvalue_value() {
  if (!has_trafficsignvalue_value()) {
    clear_value();
    set_has_trafficsignvalue_value();
    value_.trafficsignvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::TrafficSignValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.TrafficSignValue_value)
  return value_.trafficsignvalue_value_;
}

// optional .holo.map.adasisv3.ConditionalRestrictionProfileValue ConditionalRestrictionProfileValue_value = 44;
inline bool ProfileEntry::has_conditionalrestrictionprofilevalue_value() const {
  return value_case() == kConditionalRestrictionProfileValueValue;
}
inline void ProfileEntry::set_has_conditionalrestrictionprofilevalue_value() {
  _oneof_case_[0] = kConditionalRestrictionProfileValueValue;
}
inline void ProfileEntry::clear_conditionalrestrictionprofilevalue_value() {
  if (has_conditionalrestrictionprofilevalue_value()) {
    delete value_.conditionalrestrictionprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::ConditionalRestrictionProfileValue& ProfileEntry::_internal_conditionalrestrictionprofilevalue_value() const {
  return *value_.conditionalrestrictionprofilevalue_value_;
}
inline ::holo::map::adasisv3::ConditionalRestrictionProfileValue* ProfileEntry::release_conditionalrestrictionprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.ConditionalRestrictionProfileValue_value)
  if (has_conditionalrestrictionprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::ConditionalRestrictionProfileValue* temp = value_.conditionalrestrictionprofilevalue_value_;
    value_.conditionalrestrictionprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ConditionalRestrictionProfileValue& ProfileEntry::conditionalrestrictionprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.ConditionalRestrictionProfileValue_value)
  return has_conditionalrestrictionprofilevalue_value()
      ? *value_.conditionalrestrictionprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::ConditionalRestrictionProfileValue*>(&::holo::map::adasisv3::_ConditionalRestrictionProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::ConditionalRestrictionProfileValue* ProfileEntry::mutable_conditionalrestrictionprofilevalue_value() {
  if (!has_conditionalrestrictionprofilevalue_value()) {
    clear_value();
    set_has_conditionalrestrictionprofilevalue_value();
    value_.conditionalrestrictionprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::ConditionalRestrictionProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.ConditionalRestrictionProfileValue_value)
  return value_.conditionalrestrictionprofilevalue_value_;
}

// optional .holo.map.adasisv3.RoadSurfaceProfileValue RoadSurfaceProfileValue_value = 45;
inline bool ProfileEntry::has_roadsurfaceprofilevalue_value() const {
  return value_case() == kRoadSurfaceProfileValueValue;
}
inline void ProfileEntry::set_has_roadsurfaceprofilevalue_value() {
  _oneof_case_[0] = kRoadSurfaceProfileValueValue;
}
inline void ProfileEntry::clear_roadsurfaceprofilevalue_value() {
  if (has_roadsurfaceprofilevalue_value()) {
    delete value_.roadsurfaceprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::RoadSurfaceProfileValue& ProfileEntry::_internal_roadsurfaceprofilevalue_value() const {
  return *value_.roadsurfaceprofilevalue_value_;
}
inline ::holo::map::adasisv3::RoadSurfaceProfileValue* ProfileEntry::release_roadsurfaceprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.RoadSurfaceProfileValue_value)
  if (has_roadsurfaceprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::RoadSurfaceProfileValue* temp = value_.roadsurfaceprofilevalue_value_;
    value_.roadsurfaceprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::RoadSurfaceProfileValue& ProfileEntry::roadsurfaceprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.RoadSurfaceProfileValue_value)
  return has_roadsurfaceprofilevalue_value()
      ? *value_.roadsurfaceprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::RoadSurfaceProfileValue*>(&::holo::map::adasisv3::_RoadSurfaceProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::RoadSurfaceProfileValue* ProfileEntry::mutable_roadsurfaceprofilevalue_value() {
  if (!has_roadsurfaceprofilevalue_value()) {
    clear_value();
    set_has_roadsurfaceprofilevalue_value();
    value_.roadsurfaceprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::RoadSurfaceProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.RoadSurfaceProfileValue_value)
  return value_.roadsurfaceprofilevalue_value_;
}

// optional .holo.map.adasisv3.PoleProfileValue PoleProfileValue_value = 46;
inline bool ProfileEntry::has_poleprofilevalue_value() const {
  return value_case() == kPoleProfileValueValue;
}
inline void ProfileEntry::set_has_poleprofilevalue_value() {
  _oneof_case_[0] = kPoleProfileValueValue;
}
inline void ProfileEntry::clear_poleprofilevalue_value() {
  if (has_poleprofilevalue_value()) {
    delete value_.poleprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::PoleProfileValue& ProfileEntry::_internal_poleprofilevalue_value() const {
  return *value_.poleprofilevalue_value_;
}
inline ::holo::map::adasisv3::PoleProfileValue* ProfileEntry::release_poleprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.PoleProfileValue_value)
  if (has_poleprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::PoleProfileValue* temp = value_.poleprofilevalue_value_;
    value_.poleprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::PoleProfileValue& ProfileEntry::poleprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.PoleProfileValue_value)
  return has_poleprofilevalue_value()
      ? *value_.poleprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::PoleProfileValue*>(&::holo::map::adasisv3::_PoleProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::PoleProfileValue* ProfileEntry::mutable_poleprofilevalue_value() {
  if (!has_poleprofilevalue_value()) {
    clear_value();
    set_has_poleprofilevalue_value();
    value_.poleprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::PoleProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.PoleProfileValue_value)
  return value_.poleprofilevalue_value_;
}

// optional .holo.map.adasisv3.TrafficFlowProfileValue TrafficFlowProfileValue_value = 47;
inline bool ProfileEntry::has_trafficflowprofilevalue_value() const {
  return value_case() == kTrafficFlowProfileValueValue;
}
inline void ProfileEntry::set_has_trafficflowprofilevalue_value() {
  _oneof_case_[0] = kTrafficFlowProfileValueValue;
}
inline void ProfileEntry::clear_trafficflowprofilevalue_value() {
  if (has_trafficflowprofilevalue_value()) {
    delete value_.trafficflowprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::TrafficFlowProfileValue& ProfileEntry::_internal_trafficflowprofilevalue_value() const {
  return *value_.trafficflowprofilevalue_value_;
}
inline ::holo::map::adasisv3::TrafficFlowProfileValue* ProfileEntry::release_trafficflowprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.TrafficFlowProfileValue_value)
  if (has_trafficflowprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::TrafficFlowProfileValue* temp = value_.trafficflowprofilevalue_value_;
    value_.trafficflowprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::TrafficFlowProfileValue& ProfileEntry::trafficflowprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.TrafficFlowProfileValue_value)
  return has_trafficflowprofilevalue_value()
      ? *value_.trafficflowprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::TrafficFlowProfileValue*>(&::holo::map::adasisv3::_TrafficFlowProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::TrafficFlowProfileValue* ProfileEntry::mutable_trafficflowprofilevalue_value() {
  if (!has_trafficflowprofilevalue_value()) {
    clear_value();
    set_has_trafficflowprofilevalue_value();
    value_.trafficflowprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::TrafficFlowProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.TrafficFlowProfileValue_value)
  return value_.trafficflowprofilevalue_value_;
}

// optional .holo.map.adasisv3.TrafficEventProfileValue TrafficEventProfileValue_value = 48;
inline bool ProfileEntry::has_trafficeventprofilevalue_value() const {
  return value_case() == kTrafficEventProfileValueValue;
}
inline void ProfileEntry::set_has_trafficeventprofilevalue_value() {
  _oneof_case_[0] = kTrafficEventProfileValueValue;
}
inline void ProfileEntry::clear_trafficeventprofilevalue_value() {
  if (has_trafficeventprofilevalue_value()) {
    delete value_.trafficeventprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::TrafficEventProfileValue& ProfileEntry::_internal_trafficeventprofilevalue_value() const {
  return *value_.trafficeventprofilevalue_value_;
}
inline ::holo::map::adasisv3::TrafficEventProfileValue* ProfileEntry::release_trafficeventprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.TrafficEventProfileValue_value)
  if (has_trafficeventprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::TrafficEventProfileValue* temp = value_.trafficeventprofilevalue_value_;
    value_.trafficeventprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::TrafficEventProfileValue& ProfileEntry::trafficeventprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.TrafficEventProfileValue_value)
  return has_trafficeventprofilevalue_value()
      ? *value_.trafficeventprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::TrafficEventProfileValue*>(&::holo::map::adasisv3::_TrafficEventProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::TrafficEventProfileValue* ProfileEntry::mutable_trafficeventprofilevalue_value() {
  if (!has_trafficeventprofilevalue_value()) {
    clear_value();
    set_has_trafficeventprofilevalue_value();
    value_.trafficeventprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::TrafficEventProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.TrafficEventProfileValue_value)
  return value_.trafficeventprofilevalue_value_;
}

// optional .holo.map.adasisv3.StaticODDProfileValue StaticODDProfileValue_value = 49;
inline bool ProfileEntry::has_staticoddprofilevalue_value() const {
  return value_case() == kStaticODDProfileValueValue;
}
inline void ProfileEntry::set_has_staticoddprofilevalue_value() {
  _oneof_case_[0] = kStaticODDProfileValueValue;
}
inline void ProfileEntry::clear_staticoddprofilevalue_value() {
  if (has_staticoddprofilevalue_value()) {
    delete value_.staticoddprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::StaticODDProfileValue& ProfileEntry::_internal_staticoddprofilevalue_value() const {
  return *value_.staticoddprofilevalue_value_;
}
inline ::holo::map::adasisv3::StaticODDProfileValue* ProfileEntry::release_staticoddprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.StaticODDProfileValue_value)
  if (has_staticoddprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::StaticODDProfileValue* temp = value_.staticoddprofilevalue_value_;
    value_.staticoddprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::StaticODDProfileValue& ProfileEntry::staticoddprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.StaticODDProfileValue_value)
  return has_staticoddprofilevalue_value()
      ? *value_.staticoddprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::StaticODDProfileValue*>(&::holo::map::adasisv3::_StaticODDProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::StaticODDProfileValue* ProfileEntry::mutable_staticoddprofilevalue_value() {
  if (!has_staticoddprofilevalue_value()) {
    clear_value();
    set_has_staticoddprofilevalue_value();
    value_.staticoddprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::StaticODDProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.StaticODDProfileValue_value)
  return value_.staticoddprofilevalue_value_;
}

// optional .holo.map.adasisv3.StaticNotODDProfileValue StaticNotODDProfileValue_value = 50;
inline bool ProfileEntry::has_staticnotoddprofilevalue_value() const {
  return value_case() == kStaticNotODDProfileValueValue;
}
inline void ProfileEntry::set_has_staticnotoddprofilevalue_value() {
  _oneof_case_[0] = kStaticNotODDProfileValueValue;
}
inline void ProfileEntry::clear_staticnotoddprofilevalue_value() {
  if (has_staticnotoddprofilevalue_value()) {
    delete value_.staticnotoddprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::StaticNotODDProfileValue& ProfileEntry::_internal_staticnotoddprofilevalue_value() const {
  return *value_.staticnotoddprofilevalue_value_;
}
inline ::holo::map::adasisv3::StaticNotODDProfileValue* ProfileEntry::release_staticnotoddprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.StaticNotODDProfileValue_value)
  if (has_staticnotoddprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::StaticNotODDProfileValue* temp = value_.staticnotoddprofilevalue_value_;
    value_.staticnotoddprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::StaticNotODDProfileValue& ProfileEntry::staticnotoddprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.StaticNotODDProfileValue_value)
  return has_staticnotoddprofilevalue_value()
      ? *value_.staticnotoddprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::StaticNotODDProfileValue*>(&::holo::map::adasisv3::_StaticNotODDProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::StaticNotODDProfileValue* ProfileEntry::mutable_staticnotoddprofilevalue_value() {
  if (!has_staticnotoddprofilevalue_value()) {
    clear_value();
    set_has_staticnotoddprofilevalue_value();
    value_.staticnotoddprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::StaticNotODDProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.StaticNotODDProfileValue_value)
  return value_.staticnotoddprofilevalue_value_;
}

// optional .holo.map.adasisv3.DecelerationZoneProfileValue DecelerationzoneProfileValue_value = 51;
inline bool ProfileEntry::has_decelerationzoneprofilevalue_value() const {
  return value_case() == kDecelerationzoneProfileValueValue;
}
inline void ProfileEntry::set_has_decelerationzoneprofilevalue_value() {
  _oneof_case_[0] = kDecelerationzoneProfileValueValue;
}
inline void ProfileEntry::clear_decelerationzoneprofilevalue_value() {
  if (has_decelerationzoneprofilevalue_value()) {
    delete value_.decelerationzoneprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::DecelerationZoneProfileValue& ProfileEntry::_internal_decelerationzoneprofilevalue_value() const {
  return *value_.decelerationzoneprofilevalue_value_;
}
inline ::holo::map::adasisv3::DecelerationZoneProfileValue* ProfileEntry::release_decelerationzoneprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.DecelerationzoneProfileValue_value)
  if (has_decelerationzoneprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::DecelerationZoneProfileValue* temp = value_.decelerationzoneprofilevalue_value_;
    value_.decelerationzoneprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::DecelerationZoneProfileValue& ProfileEntry::decelerationzoneprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.DecelerationzoneProfileValue_value)
  return has_decelerationzoneprofilevalue_value()
      ? *value_.decelerationzoneprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::DecelerationZoneProfileValue*>(&::holo::map::adasisv3::_DecelerationZoneProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::DecelerationZoneProfileValue* ProfileEntry::mutable_decelerationzoneprofilevalue_value() {
  if (!has_decelerationzoneprofilevalue_value()) {
    clear_value();
    set_has_decelerationzoneprofilevalue_value();
    value_.decelerationzoneprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::DecelerationZoneProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.DecelerationzoneProfileValue_value)
  return value_.decelerationzoneprofilevalue_value_;
}

// optional .holo.map.adasisv3.OverHeadProfileValue OverHeadProfileValue_value = 52;
inline bool ProfileEntry::has_overheadprofilevalue_value() const {
  return value_case() == kOverHeadProfileValueValue;
}
inline void ProfileEntry::set_has_overheadprofilevalue_value() {
  _oneof_case_[0] = kOverHeadProfileValueValue;
}
inline void ProfileEntry::clear_overheadprofilevalue_value() {
  if (has_overheadprofilevalue_value()) {
    delete value_.overheadprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::OverHeadProfileValue& ProfileEntry::_internal_overheadprofilevalue_value() const {
  return *value_.overheadprofilevalue_value_;
}
inline ::holo::map::adasisv3::OverHeadProfileValue* ProfileEntry::release_overheadprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ProfileEntry.OverHeadProfileValue_value)
  if (has_overheadprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::OverHeadProfileValue* temp = value_.overheadprofilevalue_value_;
    value_.overheadprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::OverHeadProfileValue& ProfileEntry::overheadprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileEntry.OverHeadProfileValue_value)
  return has_overheadprofilevalue_value()
      ? *value_.overheadprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::OverHeadProfileValue*>(&::holo::map::adasisv3::_OverHeadProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::OverHeadProfileValue* ProfileEntry::mutable_overheadprofilevalue_value() {
  if (!has_overheadprofilevalue_value()) {
    clear_value();
    set_has_overheadprofilevalue_value();
    value_.overheadprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::OverHeadProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileEntry.OverHeadProfileValue_value)
  return value_.overheadprofilevalue_value_;
}

inline bool ProfileEntry::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void ProfileEntry::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline ProfileEntry::ValueCase ProfileEntry::value_case() const {
  return ProfileEntry::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProfileMessage

// repeated .holo.map.adasisv3.ProfileEntry profiles = 1;
inline int ProfileMessage::profiles_size() const {
  return profiles_.size();
}
inline void ProfileMessage::clear_profiles() {
  profiles_.Clear();
}
inline ::holo::map::adasisv3::ProfileEntry* ProfileMessage::mutable_profiles(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileMessage.profiles)
  return profiles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileEntry >*
ProfileMessage::mutable_profiles() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.ProfileMessage.profiles)
  return &profiles_;
}
inline const ::holo::map::adasisv3::ProfileEntry& ProfileMessage::profiles(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileMessage.profiles)
  return profiles_.Get(index);
}
inline ::holo::map::adasisv3::ProfileEntry* ProfileMessage::add_profiles() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.ProfileMessage.profiles)
  return profiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileEntry >&
ProfileMessage::profiles() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.ProfileMessage.profiles)
  return profiles_;
}

// -------------------------------------------------------------------

// GlobalData

// required .holo.map.adasisv3.ProfileType type = 1;
inline bool GlobalData::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GlobalData::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GlobalData::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GlobalData::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::holo::map::adasisv3::ProfileType GlobalData::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.type)
  return static_cast< ::holo::map::adasisv3::ProfileType >(type_);
}
inline void GlobalData::set_type(::holo::map::adasisv3::ProfileType value) {
  assert(::holo::map::adasisv3::ProfileType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.GlobalData.type)
}

// required .holo.map.adasisv3.Availability available = 2;
inline bool GlobalData::has_available() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GlobalData::set_has_available() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GlobalData::clear_has_available() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GlobalData::clear_available() {
  available_ = 0;
  clear_has_available();
}
inline ::holo::map::adasisv3::Availability GlobalData::available() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.available)
  return static_cast< ::holo::map::adasisv3::Availability >(available_);
}
inline void GlobalData::set_available(::holo::map::adasisv3::Availability value) {
  assert(::holo::map::adasisv3::Availability_IsValid(value));
  set_has_available();
  available_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.GlobalData.available)
}

// optional .holo.map.adasisv3.UInt32ProfileValue UInt32ProfileValue_value = 3;
inline bool GlobalData::has_uint32profilevalue_value() const {
  return value_case() == kUInt32ProfileValueValue;
}
inline void GlobalData::set_has_uint32profilevalue_value() {
  _oneof_case_[0] = kUInt32ProfileValueValue;
}
inline void GlobalData::clear_uint32profilevalue_value() {
  if (has_uint32profilevalue_value()) {
    delete value_.uint32profilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::UInt32ProfileValue& GlobalData::_internal_uint32profilevalue_value() const {
  return *value_.uint32profilevalue_value_;
}
inline ::holo::map::adasisv3::UInt32ProfileValue* GlobalData::release_uint32profilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.UInt32ProfileValue_value)
  if (has_uint32profilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::UInt32ProfileValue* temp = value_.uint32profilevalue_value_;
    value_.uint32profilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::UInt32ProfileValue& GlobalData::uint32profilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.UInt32ProfileValue_value)
  return has_uint32profilevalue_value()
      ? *value_.uint32profilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::UInt32ProfileValue*>(&::holo::map::adasisv3::_UInt32ProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::UInt32ProfileValue* GlobalData::mutable_uint32profilevalue_value() {
  if (!has_uint32profilevalue_value()) {
    clear_value();
    set_has_uint32profilevalue_value();
    value_.uint32profilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::UInt32ProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.UInt32ProfileValue_value)
  return value_.uint32profilevalue_value_;
}

// optional .holo.map.adasisv3.Int32ProfileValue Int32ProfileValue_value = 4;
inline bool GlobalData::has_int32profilevalue_value() const {
  return value_case() == kInt32ProfileValueValue;
}
inline void GlobalData::set_has_int32profilevalue_value() {
  _oneof_case_[0] = kInt32ProfileValueValue;
}
inline void GlobalData::clear_int32profilevalue_value() {
  if (has_int32profilevalue_value()) {
    delete value_.int32profilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::Int32ProfileValue& GlobalData::_internal_int32profilevalue_value() const {
  return *value_.int32profilevalue_value_;
}
inline ::holo::map::adasisv3::Int32ProfileValue* GlobalData::release_int32profilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.Int32ProfileValue_value)
  if (has_int32profilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::Int32ProfileValue* temp = value_.int32profilevalue_value_;
    value_.int32profilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::Int32ProfileValue& GlobalData::int32profilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.Int32ProfileValue_value)
  return has_int32profilevalue_value()
      ? *value_.int32profilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::Int32ProfileValue*>(&::holo::map::adasisv3::_Int32ProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::Int32ProfileValue* GlobalData::mutable_int32profilevalue_value() {
  if (!has_int32profilevalue_value()) {
    clear_value();
    set_has_int32profilevalue_value();
    value_.int32profilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::Int32ProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.Int32ProfileValue_value)
  return value_.int32profilevalue_value_;
}

// optional .holo.map.adasisv3.UInt64ProfileValue UInt64ProfileValue_value = 5;
inline bool GlobalData::has_uint64profilevalue_value() const {
  return value_case() == kUInt64ProfileValueValue;
}
inline void GlobalData::set_has_uint64profilevalue_value() {
  _oneof_case_[0] = kUInt64ProfileValueValue;
}
inline void GlobalData::clear_uint64profilevalue_value() {
  if (has_uint64profilevalue_value()) {
    delete value_.uint64profilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::UInt64ProfileValue& GlobalData::_internal_uint64profilevalue_value() const {
  return *value_.uint64profilevalue_value_;
}
inline ::holo::map::adasisv3::UInt64ProfileValue* GlobalData::release_uint64profilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.UInt64ProfileValue_value)
  if (has_uint64profilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::UInt64ProfileValue* temp = value_.uint64profilevalue_value_;
    value_.uint64profilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::UInt64ProfileValue& GlobalData::uint64profilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.UInt64ProfileValue_value)
  return has_uint64profilevalue_value()
      ? *value_.uint64profilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::UInt64ProfileValue*>(&::holo::map::adasisv3::_UInt64ProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::UInt64ProfileValue* GlobalData::mutable_uint64profilevalue_value() {
  if (!has_uint64profilevalue_value()) {
    clear_value();
    set_has_uint64profilevalue_value();
    value_.uint64profilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::UInt64ProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.UInt64ProfileValue_value)
  return value_.uint64profilevalue_value_;
}

// optional .holo.map.adasisv3.FloatProfileValue FloatProfileValue_value = 6;
inline bool GlobalData::has_floatprofilevalue_value() const {
  return value_case() == kFloatProfileValueValue;
}
inline void GlobalData::set_has_floatprofilevalue_value() {
  _oneof_case_[0] = kFloatProfileValueValue;
}
inline void GlobalData::clear_floatprofilevalue_value() {
  if (has_floatprofilevalue_value()) {
    delete value_.floatprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::FloatProfileValue& GlobalData::_internal_floatprofilevalue_value() const {
  return *value_.floatprofilevalue_value_;
}
inline ::holo::map::adasisv3::FloatProfileValue* GlobalData::release_floatprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.FloatProfileValue_value)
  if (has_floatprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::FloatProfileValue* temp = value_.floatprofilevalue_value_;
    value_.floatprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::FloatProfileValue& GlobalData::floatprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.FloatProfileValue_value)
  return has_floatprofilevalue_value()
      ? *value_.floatprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::FloatProfileValue*>(&::holo::map::adasisv3::_FloatProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::FloatProfileValue* GlobalData::mutable_floatprofilevalue_value() {
  if (!has_floatprofilevalue_value()) {
    clear_value();
    set_has_floatprofilevalue_value();
    value_.floatprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::FloatProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.FloatProfileValue_value)
  return value_.floatprofilevalue_value_;
}

// optional .holo.map.adasisv3.BooleanProfileValue BooleanProfileValue_value = 7;
inline bool GlobalData::has_booleanprofilevalue_value() const {
  return value_case() == kBooleanProfileValueValue;
}
inline void GlobalData::set_has_booleanprofilevalue_value() {
  _oneof_case_[0] = kBooleanProfileValueValue;
}
inline void GlobalData::clear_booleanprofilevalue_value() {
  if (has_booleanprofilevalue_value()) {
    delete value_.booleanprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::BooleanProfileValue& GlobalData::_internal_booleanprofilevalue_value() const {
  return *value_.booleanprofilevalue_value_;
}
inline ::holo::map::adasisv3::BooleanProfileValue* GlobalData::release_booleanprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.BooleanProfileValue_value)
  if (has_booleanprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::BooleanProfileValue* temp = value_.booleanprofilevalue_value_;
    value_.booleanprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::BooleanProfileValue& GlobalData::booleanprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.BooleanProfileValue_value)
  return has_booleanprofilevalue_value()
      ? *value_.booleanprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::BooleanProfileValue*>(&::holo::map::adasisv3::_BooleanProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::BooleanProfileValue* GlobalData::mutable_booleanprofilevalue_value() {
  if (!has_booleanprofilevalue_value()) {
    clear_value();
    set_has_booleanprofilevalue_value();
    value_.booleanprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::BooleanProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.BooleanProfileValue_value)
  return value_.booleanprofilevalue_value_;
}

// optional .holo.map.adasisv3.YesNoUnknownProfileValue YesNoUnknownProfileValue_value = 8;
inline bool GlobalData::has_yesnounknownprofilevalue_value() const {
  return value_case() == kYesNoUnknownProfileValueValue;
}
inline void GlobalData::set_has_yesnounknownprofilevalue_value() {
  _oneof_case_[0] = kYesNoUnknownProfileValueValue;
}
inline void GlobalData::clear_yesnounknownprofilevalue_value() {
  if (has_yesnounknownprofilevalue_value()) {
    delete value_.yesnounknownprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::YesNoUnknownProfileValue& GlobalData::_internal_yesnounknownprofilevalue_value() const {
  return *value_.yesnounknownprofilevalue_value_;
}
inline ::holo::map::adasisv3::YesNoUnknownProfileValue* GlobalData::release_yesnounknownprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.YesNoUnknownProfileValue_value)
  if (has_yesnounknownprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::YesNoUnknownProfileValue* temp = value_.yesnounknownprofilevalue_value_;
    value_.yesnounknownprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::YesNoUnknownProfileValue& GlobalData::yesnounknownprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.YesNoUnknownProfileValue_value)
  return has_yesnounknownprofilevalue_value()
      ? *value_.yesnounknownprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::YesNoUnknownProfileValue*>(&::holo::map::adasisv3::_YesNoUnknownProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::YesNoUnknownProfileValue* GlobalData::mutable_yesnounknownprofilevalue_value() {
  if (!has_yesnounknownprofilevalue_value()) {
    clear_value();
    set_has_yesnounknownprofilevalue_value();
    value_.yesnounknownprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::YesNoUnknownProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.YesNoUnknownProfileValue_value)
  return value_.yesnounknownprofilevalue_value_;
}

// optional .holo.map.adasisv3.FormOfWayProfileValue FormOfWayProfileValue_value = 9;
inline bool GlobalData::has_formofwayprofilevalue_value() const {
  return value_case() == kFormOfWayProfileValueValue;
}
inline void GlobalData::set_has_formofwayprofilevalue_value() {
  _oneof_case_[0] = kFormOfWayProfileValueValue;
}
inline void GlobalData::clear_formofwayprofilevalue_value() {
  if (has_formofwayprofilevalue_value()) {
    delete value_.formofwayprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::FormOfWayProfileValue& GlobalData::_internal_formofwayprofilevalue_value() const {
  return *value_.formofwayprofilevalue_value_;
}
inline ::holo::map::adasisv3::FormOfWayProfileValue* GlobalData::release_formofwayprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.FormOfWayProfileValue_value)
  if (has_formofwayprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::FormOfWayProfileValue* temp = value_.formofwayprofilevalue_value_;
    value_.formofwayprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::FormOfWayProfileValue& GlobalData::formofwayprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.FormOfWayProfileValue_value)
  return has_formofwayprofilevalue_value()
      ? *value_.formofwayprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::FormOfWayProfileValue*>(&::holo::map::adasisv3::_FormOfWayProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::FormOfWayProfileValue* GlobalData::mutable_formofwayprofilevalue_value() {
  if (!has_formofwayprofilevalue_value()) {
    clear_value();
    set_has_formofwayprofilevalue_value();
    value_.formofwayprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::FormOfWayProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.FormOfWayProfileValue_value)
  return value_.formofwayprofilevalue_value_;
}

// optional .holo.map.adasisv3.DrivingSideProfileValue DrivingSideProfileValue_value = 10;
inline bool GlobalData::has_drivingsideprofilevalue_value() const {
  return value_case() == kDrivingSideProfileValueValue;
}
inline void GlobalData::set_has_drivingsideprofilevalue_value() {
  _oneof_case_[0] = kDrivingSideProfileValueValue;
}
inline void GlobalData::clear_drivingsideprofilevalue_value() {
  if (has_drivingsideprofilevalue_value()) {
    delete value_.drivingsideprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::DrivingSideProfileValue& GlobalData::_internal_drivingsideprofilevalue_value() const {
  return *value_.drivingsideprofilevalue_value_;
}
inline ::holo::map::adasisv3::DrivingSideProfileValue* GlobalData::release_drivingsideprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.DrivingSideProfileValue_value)
  if (has_drivingsideprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::DrivingSideProfileValue* temp = value_.drivingsideprofilevalue_value_;
    value_.drivingsideprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::DrivingSideProfileValue& GlobalData::drivingsideprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.DrivingSideProfileValue_value)
  return has_drivingsideprofilevalue_value()
      ? *value_.drivingsideprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::DrivingSideProfileValue*>(&::holo::map::adasisv3::_DrivingSideProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::DrivingSideProfileValue* GlobalData::mutable_drivingsideprofilevalue_value() {
  if (!has_drivingsideprofilevalue_value()) {
    clear_value();
    set_has_drivingsideprofilevalue_value();
    value_.drivingsideprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::DrivingSideProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.DrivingSideProfileValue_value)
  return value_.drivingsideprofilevalue_value_;
}

// optional .holo.map.adasisv3.UnitSystemProfileValue UnitSystemProfileValue_value = 11;
inline bool GlobalData::has_unitsystemprofilevalue_value() const {
  return value_case() == kUnitSystemProfileValueValue;
}
inline void GlobalData::set_has_unitsystemprofilevalue_value() {
  _oneof_case_[0] = kUnitSystemProfileValueValue;
}
inline void GlobalData::clear_unitsystemprofilevalue_value() {
  if (has_unitsystemprofilevalue_value()) {
    delete value_.unitsystemprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::UnitSystemProfileValue& GlobalData::_internal_unitsystemprofilevalue_value() const {
  return *value_.unitsystemprofilevalue_value_;
}
inline ::holo::map::adasisv3::UnitSystemProfileValue* GlobalData::release_unitsystemprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.UnitSystemProfileValue_value)
  if (has_unitsystemprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::UnitSystemProfileValue* temp = value_.unitsystemprofilevalue_value_;
    value_.unitsystemprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::UnitSystemProfileValue& GlobalData::unitsystemprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.UnitSystemProfileValue_value)
  return has_unitsystemprofilevalue_value()
      ? *value_.unitsystemprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::UnitSystemProfileValue*>(&::holo::map::adasisv3::_UnitSystemProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::UnitSystemProfileValue* GlobalData::mutable_unitsystemprofilevalue_value() {
  if (!has_unitsystemprofilevalue_value()) {
    clear_value();
    set_has_unitsystemprofilevalue_value();
    value_.unitsystemprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::UnitSystemProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.UnitSystemProfileValue_value)
  return value_.unitsystemprofilevalue_value_;
}

// optional .holo.map.adasisv3.SpecialSituationProfileValue SpecialSituationProfileValue_value = 12;
inline bool GlobalData::has_specialsituationprofilevalue_value() const {
  return value_case() == kSpecialSituationProfileValueValue;
}
inline void GlobalData::set_has_specialsituationprofilevalue_value() {
  _oneof_case_[0] = kSpecialSituationProfileValueValue;
}
inline void GlobalData::clear_specialsituationprofilevalue_value() {
  if (has_specialsituationprofilevalue_value()) {
    delete value_.specialsituationprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::SpecialSituationProfileValue& GlobalData::_internal_specialsituationprofilevalue_value() const {
  return *value_.specialsituationprofilevalue_value_;
}
inline ::holo::map::adasisv3::SpecialSituationProfileValue* GlobalData::release_specialsituationprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.SpecialSituationProfileValue_value)
  if (has_specialsituationprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::SpecialSituationProfileValue* temp = value_.specialsituationprofilevalue_value_;
    value_.specialsituationprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::SpecialSituationProfileValue& GlobalData::specialsituationprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.SpecialSituationProfileValue_value)
  return has_specialsituationprofilevalue_value()
      ? *value_.specialsituationprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::SpecialSituationProfileValue*>(&::holo::map::adasisv3::_SpecialSituationProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::SpecialSituationProfileValue* GlobalData::mutable_specialsituationprofilevalue_value() {
  if (!has_specialsituationprofilevalue_value()) {
    clear_value();
    set_has_specialsituationprofilevalue_value();
    value_.specialsituationprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::SpecialSituationProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.SpecialSituationProfileValue_value)
  return value_.specialsituationprofilevalue_value_;
}

// optional .holo.map.adasisv3.RoadConditionProfileValue RoadConditionProfileValue_value = 13;
inline bool GlobalData::has_roadconditionprofilevalue_value() const {
  return value_case() == kRoadConditionProfileValueValue;
}
inline void GlobalData::set_has_roadconditionprofilevalue_value() {
  _oneof_case_[0] = kRoadConditionProfileValueValue;
}
inline void GlobalData::clear_roadconditionprofilevalue_value() {
  if (has_roadconditionprofilevalue_value()) {
    delete value_.roadconditionprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::RoadConditionProfileValue& GlobalData::_internal_roadconditionprofilevalue_value() const {
  return *value_.roadconditionprofilevalue_value_;
}
inline ::holo::map::adasisv3::RoadConditionProfileValue* GlobalData::release_roadconditionprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.RoadConditionProfileValue_value)
  if (has_roadconditionprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::RoadConditionProfileValue* temp = value_.roadconditionprofilevalue_value_;
    value_.roadconditionprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::RoadConditionProfileValue& GlobalData::roadconditionprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.RoadConditionProfileValue_value)
  return has_roadconditionprofilevalue_value()
      ? *value_.roadconditionprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::RoadConditionProfileValue*>(&::holo::map::adasisv3::_RoadConditionProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::RoadConditionProfileValue* GlobalData::mutable_roadconditionprofilevalue_value() {
  if (!has_roadconditionprofilevalue_value()) {
    clear_value();
    set_has_roadconditionprofilevalue_value();
    value_.roadconditionprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::RoadConditionProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.RoadConditionProfileValue_value)
  return value_.roadconditionprofilevalue_value_;
}

// optional .holo.map.adasisv3.WeatherProfileValue WeatherProfileValue_value = 14;
inline bool GlobalData::has_weatherprofilevalue_value() const {
  return value_case() == kWeatherProfileValueValue;
}
inline void GlobalData::set_has_weatherprofilevalue_value() {
  _oneof_case_[0] = kWeatherProfileValueValue;
}
inline void GlobalData::clear_weatherprofilevalue_value() {
  if (has_weatherprofilevalue_value()) {
    delete value_.weatherprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::WeatherProfileValue& GlobalData::_internal_weatherprofilevalue_value() const {
  return *value_.weatherprofilevalue_value_;
}
inline ::holo::map::adasisv3::WeatherProfileValue* GlobalData::release_weatherprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.WeatherProfileValue_value)
  if (has_weatherprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::WeatherProfileValue* temp = value_.weatherprofilevalue_value_;
    value_.weatherprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::WeatherProfileValue& GlobalData::weatherprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.WeatherProfileValue_value)
  return has_weatherprofilevalue_value()
      ? *value_.weatherprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::WeatherProfileValue*>(&::holo::map::adasisv3::_WeatherProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::WeatherProfileValue* GlobalData::mutable_weatherprofilevalue_value() {
  if (!has_weatherprofilevalue_value()) {
    clear_value();
    set_has_weatherprofilevalue_value();
    value_.weatherprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::WeatherProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.WeatherProfileValue_value)
  return value_.weatherprofilevalue_value_;
}

// optional .holo.map.adasisv3.MapProviderProfileValue MapProviderProfileValue_value = 15;
inline bool GlobalData::has_mapproviderprofilevalue_value() const {
  return value_case() == kMapProviderProfileValueValue;
}
inline void GlobalData::set_has_mapproviderprofilevalue_value() {
  _oneof_case_[0] = kMapProviderProfileValueValue;
}
inline void GlobalData::clear_mapproviderprofilevalue_value() {
  if (has_mapproviderprofilevalue_value()) {
    delete value_.mapproviderprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::MapProviderProfileValue& GlobalData::_internal_mapproviderprofilevalue_value() const {
  return *value_.mapproviderprofilevalue_value_;
}
inline ::holo::map::adasisv3::MapProviderProfileValue* GlobalData::release_mapproviderprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.MapProviderProfileValue_value)
  if (has_mapproviderprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::MapProviderProfileValue* temp = value_.mapproviderprofilevalue_value_;
    value_.mapproviderprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::MapProviderProfileValue& GlobalData::mapproviderprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.MapProviderProfileValue_value)
  return has_mapproviderprofilevalue_value()
      ? *value_.mapproviderprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::MapProviderProfileValue*>(&::holo::map::adasisv3::_MapProviderProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::MapProviderProfileValue* GlobalData::mutable_mapproviderprofilevalue_value() {
  if (!has_mapproviderprofilevalue_value()) {
    clear_value();
    set_has_mapproviderprofilevalue_value();
    value_.mapproviderprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::MapProviderProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.MapProviderProfileValue_value)
  return value_.mapproviderprofilevalue_value_;
}

// optional .holo.map.adasisv3.MapStatusProfileValue MapStatusProfileValue_value = 16;
inline bool GlobalData::has_mapstatusprofilevalue_value() const {
  return value_case() == kMapStatusProfileValueValue;
}
inline void GlobalData::set_has_mapstatusprofilevalue_value() {
  _oneof_case_[0] = kMapStatusProfileValueValue;
}
inline void GlobalData::clear_mapstatusprofilevalue_value() {
  if (has_mapstatusprofilevalue_value()) {
    delete value_.mapstatusprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::MapStatusProfileValue& GlobalData::_internal_mapstatusprofilevalue_value() const {
  return *value_.mapstatusprofilevalue_value_;
}
inline ::holo::map::adasisv3::MapStatusProfileValue* GlobalData::release_mapstatusprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.MapStatusProfileValue_value)
  if (has_mapstatusprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::MapStatusProfileValue* temp = value_.mapstatusprofilevalue_value_;
    value_.mapstatusprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::MapStatusProfileValue& GlobalData::mapstatusprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.MapStatusProfileValue_value)
  return has_mapstatusprofilevalue_value()
      ? *value_.mapstatusprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::MapStatusProfileValue*>(&::holo::map::adasisv3::_MapStatusProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::MapStatusProfileValue* GlobalData::mutable_mapstatusprofilevalue_value() {
  if (!has_mapstatusprofilevalue_value()) {
    clear_value();
    set_has_mapstatusprofilevalue_value();
    value_.mapstatusprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::MapStatusProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.MapStatusProfileValue_value)
  return value_.mapstatusprofilevalue_value_;
}

// optional .holo.map.adasisv3.OffsetFloatProfileValue OffsetFloatProfileValue_value = 17;
inline bool GlobalData::has_offsetfloatprofilevalue_value() const {
  return value_case() == kOffsetFloatProfileValueValue;
}
inline void GlobalData::set_has_offsetfloatprofilevalue_value() {
  _oneof_case_[0] = kOffsetFloatProfileValueValue;
}
inline void GlobalData::clear_offsetfloatprofilevalue_value() {
  if (has_offsetfloatprofilevalue_value()) {
    delete value_.offsetfloatprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::OffsetFloatProfileValue& GlobalData::_internal_offsetfloatprofilevalue_value() const {
  return *value_.offsetfloatprofilevalue_value_;
}
inline ::holo::map::adasisv3::OffsetFloatProfileValue* GlobalData::release_offsetfloatprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.OffsetFloatProfileValue_value)
  if (has_offsetfloatprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::OffsetFloatProfileValue* temp = value_.offsetfloatprofilevalue_value_;
    value_.offsetfloatprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::OffsetFloatProfileValue& GlobalData::offsetfloatprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.OffsetFloatProfileValue_value)
  return has_offsetfloatprofilevalue_value()
      ? *value_.offsetfloatprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::OffsetFloatProfileValue*>(&::holo::map::adasisv3::_OffsetFloatProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::OffsetFloatProfileValue* GlobalData::mutable_offsetfloatprofilevalue_value() {
  if (!has_offsetfloatprofilevalue_value()) {
    clear_value();
    set_has_offsetfloatprofilevalue_value();
    value_.offsetfloatprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::OffsetFloatProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.OffsetFloatProfileValue_value)
  return value_.offsetfloatprofilevalue_value_;
}

// optional .holo.map.adasisv3.NodeProfileValue NodeProfileValue_value = 18;
inline bool GlobalData::has_nodeprofilevalue_value() const {
  return value_case() == kNodeProfileValueValue;
}
inline void GlobalData::set_has_nodeprofilevalue_value() {
  _oneof_case_[0] = kNodeProfileValueValue;
}
inline void GlobalData::clear_nodeprofilevalue_value() {
  if (has_nodeprofilevalue_value()) {
    delete value_.nodeprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::NodeProfileValue& GlobalData::_internal_nodeprofilevalue_value() const {
  return *value_.nodeprofilevalue_value_;
}
inline ::holo::map::adasisv3::NodeProfileValue* GlobalData::release_nodeprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.NodeProfileValue_value)
  if (has_nodeprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::NodeProfileValue* temp = value_.nodeprofilevalue_value_;
    value_.nodeprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::NodeProfileValue& GlobalData::nodeprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.NodeProfileValue_value)
  return has_nodeprofilevalue_value()
      ? *value_.nodeprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::NodeProfileValue*>(&::holo::map::adasisv3::_NodeProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::NodeProfileValue* GlobalData::mutable_nodeprofilevalue_value() {
  if (!has_nodeprofilevalue_value()) {
    clear_value();
    set_has_nodeprofilevalue_value();
    value_.nodeprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::NodeProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.NodeProfileValue_value)
  return value_.nodeprofilevalue_value_;
}

// optional .holo.map.adasisv3.SystemStatusProfileValue SystemStatusProfileValue_value = 19;
inline bool GlobalData::has_systemstatusprofilevalue_value() const {
  return value_case() == kSystemStatusProfileValueValue;
}
inline void GlobalData::set_has_systemstatusprofilevalue_value() {
  _oneof_case_[0] = kSystemStatusProfileValueValue;
}
inline void GlobalData::clear_systemstatusprofilevalue_value() {
  if (has_systemstatusprofilevalue_value()) {
    delete value_.systemstatusprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::SystemStatusProfileValue& GlobalData::_internal_systemstatusprofilevalue_value() const {
  return *value_.systemstatusprofilevalue_value_;
}
inline ::holo::map::adasisv3::SystemStatusProfileValue* GlobalData::release_systemstatusprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.SystemStatusProfileValue_value)
  if (has_systemstatusprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::SystemStatusProfileValue* temp = value_.systemstatusprofilevalue_value_;
    value_.systemstatusprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::SystemStatusProfileValue& GlobalData::systemstatusprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.SystemStatusProfileValue_value)
  return has_systemstatusprofilevalue_value()
      ? *value_.systemstatusprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::SystemStatusProfileValue*>(&::holo::map::adasisv3::_SystemStatusProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::SystemStatusProfileValue* GlobalData::mutable_systemstatusprofilevalue_value() {
  if (!has_systemstatusprofilevalue_value()) {
    clear_value();
    set_has_systemstatusprofilevalue_value();
    value_.systemstatusprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::SystemStatusProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.SystemStatusProfileValue_value)
  return value_.systemstatusprofilevalue_value_;
}

// optional .holo.map.adasisv3.AbsoluteVehiclePositionProfileValue AbsoluteVehiclePositionProfileValue_value = 20;
inline bool GlobalData::has_absolutevehiclepositionprofilevalue_value() const {
  return value_case() == kAbsoluteVehiclePositionProfileValueValue;
}
inline void GlobalData::set_has_absolutevehiclepositionprofilevalue_value() {
  _oneof_case_[0] = kAbsoluteVehiclePositionProfileValueValue;
}
inline void GlobalData::clear_absolutevehiclepositionprofilevalue_value() {
  if (has_absolutevehiclepositionprofilevalue_value()) {
    delete value_.absolutevehiclepositionprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue& GlobalData::_internal_absolutevehiclepositionprofilevalue_value() const {
  return *value_.absolutevehiclepositionprofilevalue_value_;
}
inline ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* GlobalData::release_absolutevehiclepositionprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.AbsoluteVehiclePositionProfileValue_value)
  if (has_absolutevehiclepositionprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* temp = value_.absolutevehiclepositionprofilevalue_value_;
    value_.absolutevehiclepositionprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue& GlobalData::absolutevehiclepositionprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.AbsoluteVehiclePositionProfileValue_value)
  return has_absolutevehiclepositionprofilevalue_value()
      ? *value_.absolutevehiclepositionprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue*>(&::holo::map::adasisv3::_AbsoluteVehiclePositionProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue* GlobalData::mutable_absolutevehiclepositionprofilevalue_value() {
  if (!has_absolutevehiclepositionprofilevalue_value()) {
    clear_value();
    set_has_absolutevehiclepositionprofilevalue_value();
    value_.absolutevehiclepositionprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::AbsoluteVehiclePositionProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.AbsoluteVehiclePositionProfileValue_value)
  return value_.absolutevehiclepositionprofilevalue_value_;
}

// optional .holo.map.adasisv3.SurfaceConditionProfileValue SurfaceConditionProfileValue_value = 21;
inline bool GlobalData::has_surfaceconditionprofilevalue_value() const {
  return value_case() == kSurfaceConditionProfileValueValue;
}
inline void GlobalData::set_has_surfaceconditionprofilevalue_value() {
  _oneof_case_[0] = kSurfaceConditionProfileValueValue;
}
inline void GlobalData::clear_surfaceconditionprofilevalue_value() {
  if (has_surfaceconditionprofilevalue_value()) {
    delete value_.surfaceconditionprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::SurfaceConditionProfileValue& GlobalData::_internal_surfaceconditionprofilevalue_value() const {
  return *value_.surfaceconditionprofilevalue_value_;
}
inline ::holo::map::adasisv3::SurfaceConditionProfileValue* GlobalData::release_surfaceconditionprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.SurfaceConditionProfileValue_value)
  if (has_surfaceconditionprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::SurfaceConditionProfileValue* temp = value_.surfaceconditionprofilevalue_value_;
    value_.surfaceconditionprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::SurfaceConditionProfileValue& GlobalData::surfaceconditionprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.SurfaceConditionProfileValue_value)
  return has_surfaceconditionprofilevalue_value()
      ? *value_.surfaceconditionprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::SurfaceConditionProfileValue*>(&::holo::map::adasisv3::_SurfaceConditionProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::SurfaceConditionProfileValue* GlobalData::mutable_surfaceconditionprofilevalue_value() {
  if (!has_surfaceconditionprofilevalue_value()) {
    clear_value();
    set_has_surfaceconditionprofilevalue_value();
    value_.surfaceconditionprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::SurfaceConditionProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.SurfaceConditionProfileValue_value)
  return value_.surfaceconditionprofilevalue_value_;
}

// optional .holo.map.adasisv3.SpeedProfileValue SpeedProfileValue_value = 22;
inline bool GlobalData::has_speedprofilevalue_value() const {
  return value_case() == kSpeedProfileValueValue;
}
inline void GlobalData::set_has_speedprofilevalue_value() {
  _oneof_case_[0] = kSpeedProfileValueValue;
}
inline void GlobalData::clear_speedprofilevalue_value() {
  if (has_speedprofilevalue_value()) {
    delete value_.speedprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::SpeedProfileValue& GlobalData::_internal_speedprofilevalue_value() const {
  return *value_.speedprofilevalue_value_;
}
inline ::holo::map::adasisv3::SpeedProfileValue* GlobalData::release_speedprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.SpeedProfileValue_value)
  if (has_speedprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::SpeedProfileValue* temp = value_.speedprofilevalue_value_;
    value_.speedprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::SpeedProfileValue& GlobalData::speedprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.SpeedProfileValue_value)
  return has_speedprofilevalue_value()
      ? *value_.speedprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::SpeedProfileValue*>(&::holo::map::adasisv3::_SpeedProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::SpeedProfileValue* GlobalData::mutable_speedprofilevalue_value() {
  if (!has_speedprofilevalue_value()) {
    clear_value();
    set_has_speedprofilevalue_value();
    value_.speedprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::SpeedProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.SpeedProfileValue_value)
  return value_.speedprofilevalue_value_;
}

// optional .holo.map.adasisv3.LaneModelValue LaneModelValue_value = 23;
inline bool GlobalData::has_lanemodelvalue_value() const {
  return value_case() == kLaneModelValueValue;
}
inline void GlobalData::set_has_lanemodelvalue_value() {
  _oneof_case_[0] = kLaneModelValueValue;
}
inline void GlobalData::clear_lanemodelvalue_value() {
  if (has_lanemodelvalue_value()) {
    delete value_.lanemodelvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LaneModelValue& GlobalData::_internal_lanemodelvalue_value() const {
  return *value_.lanemodelvalue_value_;
}
inline ::holo::map::adasisv3::LaneModelValue* GlobalData::release_lanemodelvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.LaneModelValue_value)
  if (has_lanemodelvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LaneModelValue* temp = value_.lanemodelvalue_value_;
    value_.lanemodelvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LaneModelValue& GlobalData::lanemodelvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.LaneModelValue_value)
  return has_lanemodelvalue_value()
      ? *value_.lanemodelvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LaneModelValue*>(&::holo::map::adasisv3::_LaneModelValue_default_instance_);
}
inline ::holo::map::adasisv3::LaneModelValue* GlobalData::mutable_lanemodelvalue_value() {
  if (!has_lanemodelvalue_value()) {
    clear_value();
    set_has_lanemodelvalue_value();
    value_.lanemodelvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LaneModelValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.LaneModelValue_value)
  return value_.lanemodelvalue_value_;
}

// optional .holo.map.adasisv3.LaneConnectivityValue LaneConnectivityValue_value = 24;
inline bool GlobalData::has_laneconnectivityvalue_value() const {
  return value_case() == kLaneConnectivityValueValue;
}
inline void GlobalData::set_has_laneconnectivityvalue_value() {
  _oneof_case_[0] = kLaneConnectivityValueValue;
}
inline void GlobalData::clear_laneconnectivityvalue_value() {
  if (has_laneconnectivityvalue_value()) {
    delete value_.laneconnectivityvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LaneConnectivityValue& GlobalData::_internal_laneconnectivityvalue_value() const {
  return *value_.laneconnectivityvalue_value_;
}
inline ::holo::map::adasisv3::LaneConnectivityValue* GlobalData::release_laneconnectivityvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.LaneConnectivityValue_value)
  if (has_laneconnectivityvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LaneConnectivityValue* temp = value_.laneconnectivityvalue_value_;
    value_.laneconnectivityvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LaneConnectivityValue& GlobalData::laneconnectivityvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.LaneConnectivityValue_value)
  return has_laneconnectivityvalue_value()
      ? *value_.laneconnectivityvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LaneConnectivityValue*>(&::holo::map::adasisv3::_LaneConnectivityValue_default_instance_);
}
inline ::holo::map::adasisv3::LaneConnectivityValue* GlobalData::mutable_laneconnectivityvalue_value() {
  if (!has_laneconnectivityvalue_value()) {
    clear_value();
    set_has_laneconnectivityvalue_value();
    value_.laneconnectivityvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LaneConnectivityValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.LaneConnectivityValue_value)
  return value_.laneconnectivityvalue_value_;
}

// optional .holo.map.adasisv3.LinearObjectDefinitionValue LinearObjectDefinitionValue_value = 25;
inline bool GlobalData::has_linearobjectdefinitionvalue_value() const {
  return value_case() == kLinearObjectDefinitionValueValue;
}
inline void GlobalData::set_has_linearobjectdefinitionvalue_value() {
  _oneof_case_[0] = kLinearObjectDefinitionValueValue;
}
inline void GlobalData::clear_linearobjectdefinitionvalue_value() {
  if (has_linearobjectdefinitionvalue_value()) {
    delete value_.linearobjectdefinitionvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LinearObjectDefinitionValue& GlobalData::_internal_linearobjectdefinitionvalue_value() const {
  return *value_.linearobjectdefinitionvalue_value_;
}
inline ::holo::map::adasisv3::LinearObjectDefinitionValue* GlobalData::release_linearobjectdefinitionvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.LinearObjectDefinitionValue_value)
  if (has_linearobjectdefinitionvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LinearObjectDefinitionValue* temp = value_.linearobjectdefinitionvalue_value_;
    value_.linearobjectdefinitionvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LinearObjectDefinitionValue& GlobalData::linearobjectdefinitionvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.LinearObjectDefinitionValue_value)
  return has_linearobjectdefinitionvalue_value()
      ? *value_.linearobjectdefinitionvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LinearObjectDefinitionValue*>(&::holo::map::adasisv3::_LinearObjectDefinitionValue_default_instance_);
}
inline ::holo::map::adasisv3::LinearObjectDefinitionValue* GlobalData::mutable_linearobjectdefinitionvalue_value() {
  if (!has_linearobjectdefinitionvalue_value()) {
    clear_value();
    set_has_linearobjectdefinitionvalue_value();
    value_.linearobjectdefinitionvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LinearObjectDefinitionValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.LinearObjectDefinitionValue_value)
  return value_.linearobjectdefinitionvalue_value_;
}

// optional .holo.map.adasisv3.LanesGeometryProfileValue LanesGeometryProfileValue_value = 26;
inline bool GlobalData::has_lanesgeometryprofilevalue_value() const {
  return value_case() == kLanesGeometryProfileValueValue;
}
inline void GlobalData::set_has_lanesgeometryprofilevalue_value() {
  _oneof_case_[0] = kLanesGeometryProfileValueValue;
}
inline void GlobalData::clear_lanesgeometryprofilevalue_value() {
  if (has_lanesgeometryprofilevalue_value()) {
    delete value_.lanesgeometryprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LanesGeometryProfileValue& GlobalData::_internal_lanesgeometryprofilevalue_value() const {
  return *value_.lanesgeometryprofilevalue_value_;
}
inline ::holo::map::adasisv3::LanesGeometryProfileValue* GlobalData::release_lanesgeometryprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.LanesGeometryProfileValue_value)
  if (has_lanesgeometryprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LanesGeometryProfileValue* temp = value_.lanesgeometryprofilevalue_value_;
    value_.lanesgeometryprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LanesGeometryProfileValue& GlobalData::lanesgeometryprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.LanesGeometryProfileValue_value)
  return has_lanesgeometryprofilevalue_value()
      ? *value_.lanesgeometryprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LanesGeometryProfileValue*>(&::holo::map::adasisv3::_LanesGeometryProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::LanesGeometryProfileValue* GlobalData::mutable_lanesgeometryprofilevalue_value() {
  if (!has_lanesgeometryprofilevalue_value()) {
    clear_value();
    set_has_lanesgeometryprofilevalue_value();
    value_.lanesgeometryprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LanesGeometryProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.LanesGeometryProfileValue_value)
  return value_.lanesgeometryprofilevalue_value_;
}

// optional .holo.map.adasisv3.RoadGeometryProfileValue RoadGeometryProfileValue_value = 27;
inline bool GlobalData::has_roadgeometryprofilevalue_value() const {
  return value_case() == kRoadGeometryProfileValueValue;
}
inline void GlobalData::set_has_roadgeometryprofilevalue_value() {
  _oneof_case_[0] = kRoadGeometryProfileValueValue;
}
inline void GlobalData::clear_roadgeometryprofilevalue_value() {
  if (has_roadgeometryprofilevalue_value()) {
    delete value_.roadgeometryprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::RoadGeometryProfileValue& GlobalData::_internal_roadgeometryprofilevalue_value() const {
  return *value_.roadgeometryprofilevalue_value_;
}
inline ::holo::map::adasisv3::RoadGeometryProfileValue* GlobalData::release_roadgeometryprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.RoadGeometryProfileValue_value)
  if (has_roadgeometryprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::RoadGeometryProfileValue* temp = value_.roadgeometryprofilevalue_value_;
    value_.roadgeometryprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::RoadGeometryProfileValue& GlobalData::roadgeometryprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.RoadGeometryProfileValue_value)
  return has_roadgeometryprofilevalue_value()
      ? *value_.roadgeometryprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::RoadGeometryProfileValue*>(&::holo::map::adasisv3::_RoadGeometryProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::RoadGeometryProfileValue* GlobalData::mutable_roadgeometryprofilevalue_value() {
  if (!has_roadgeometryprofilevalue_value()) {
    clear_value();
    set_has_roadgeometryprofilevalue_value();
    value_.roadgeometryprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::RoadGeometryProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.RoadGeometryProfileValue_value)
  return value_.roadgeometryprofilevalue_value_;
}

// optional .holo.map.adasisv3.TrafficLightProfileValue TrafficLightProfileValue_value = 28;
inline bool GlobalData::has_trafficlightprofilevalue_value() const {
  return value_case() == kTrafficLightProfileValueValue;
}
inline void GlobalData::set_has_trafficlightprofilevalue_value() {
  _oneof_case_[0] = kTrafficLightProfileValueValue;
}
inline void GlobalData::clear_trafficlightprofilevalue_value() {
  if (has_trafficlightprofilevalue_value()) {
    delete value_.trafficlightprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::TrafficLightProfileValue& GlobalData::_internal_trafficlightprofilevalue_value() const {
  return *value_.trafficlightprofilevalue_value_;
}
inline ::holo::map::adasisv3::TrafficLightProfileValue* GlobalData::release_trafficlightprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.TrafficLightProfileValue_value)
  if (has_trafficlightprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::TrafficLightProfileValue* temp = value_.trafficlightprofilevalue_value_;
    value_.trafficlightprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::TrafficLightProfileValue& GlobalData::trafficlightprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.TrafficLightProfileValue_value)
  return has_trafficlightprofilevalue_value()
      ? *value_.trafficlightprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::TrafficLightProfileValue*>(&::holo::map::adasisv3::_TrafficLightProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::TrafficLightProfileValue* GlobalData::mutable_trafficlightprofilevalue_value() {
  if (!has_trafficlightprofilevalue_value()) {
    clear_value();
    set_has_trafficlightprofilevalue_value();
    value_.trafficlightprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::TrafficLightProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.TrafficLightProfileValue_value)
  return value_.trafficlightprofilevalue_value_;
}

// optional .holo.map.adasisv3.EffectiveSpeedLimit EffectiveSpeedLimit_value = 29;
inline bool GlobalData::has_effectivespeedlimit_value() const {
  return value_case() == kEffectiveSpeedLimitValue;
}
inline void GlobalData::set_has_effectivespeedlimit_value() {
  _oneof_case_[0] = kEffectiveSpeedLimitValue;
}
inline void GlobalData::clear_effectivespeedlimit_value() {
  if (has_effectivespeedlimit_value()) {
    delete value_.effectivespeedlimit_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::EffectiveSpeedLimit& GlobalData::_internal_effectivespeedlimit_value() const {
  return *value_.effectivespeedlimit_value_;
}
inline ::holo::map::adasisv3::EffectiveSpeedLimit* GlobalData::release_effectivespeedlimit_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.EffectiveSpeedLimit_value)
  if (has_effectivespeedlimit_value()) {
    clear_has_value();
      ::holo::map::adasisv3::EffectiveSpeedLimit* temp = value_.effectivespeedlimit_value_;
    value_.effectivespeedlimit_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::EffectiveSpeedLimit& GlobalData::effectivespeedlimit_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.EffectiveSpeedLimit_value)
  return has_effectivespeedlimit_value()
      ? *value_.effectivespeedlimit_value_
      : *reinterpret_cast< ::holo::map::adasisv3::EffectiveSpeedLimit*>(&::holo::map::adasisv3::_EffectiveSpeedLimit_default_instance_);
}
inline ::holo::map::adasisv3::EffectiveSpeedLimit* GlobalData::mutable_effectivespeedlimit_value() {
  if (!has_effectivespeedlimit_value()) {
    clear_value();
    set_has_effectivespeedlimit_value();
    value_.effectivespeedlimit_value_ = CreateMaybeMessage< ::holo::map::adasisv3::EffectiveSpeedLimit >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.EffectiveSpeedLimit_value)
  return value_.effectivespeedlimit_value_;
}

// optional .holo.map.adasisv3.LocationObject LocationObject_value = 30;
inline bool GlobalData::has_locationobject_value() const {
  return value_case() == kLocationObjectValue;
}
inline void GlobalData::set_has_locationobject_value() {
  _oneof_case_[0] = kLocationObjectValue;
}
inline void GlobalData::clear_locationobject_value() {
  if (has_locationobject_value()) {
    delete value_.locationobject_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::LocationObject& GlobalData::_internal_locationobject_value() const {
  return *value_.locationobject_value_;
}
inline ::holo::map::adasisv3::LocationObject* GlobalData::release_locationobject_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.LocationObject_value)
  if (has_locationobject_value()) {
    clear_has_value();
      ::holo::map::adasisv3::LocationObject* temp = value_.locationobject_value_;
    value_.locationobject_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::LocationObject& GlobalData::locationobject_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.LocationObject_value)
  return has_locationobject_value()
      ? *value_.locationobject_value_
      : *reinterpret_cast< ::holo::map::adasisv3::LocationObject*>(&::holo::map::adasisv3::_LocationObject_default_instance_);
}
inline ::holo::map::adasisv3::LocationObject* GlobalData::mutable_locationobject_value() {
  if (!has_locationobject_value()) {
    clear_value();
    set_has_locationobject_value();
    value_.locationobject_value_ = CreateMaybeMessage< ::holo::map::adasisv3::LocationObject >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.LocationObject_value)
  return value_.locationobject_value_;
}

// optional .holo.map.adasisv3.RegionCodeValue RegionCodeValue_value = 31;
inline bool GlobalData::has_regioncodevalue_value() const {
  return value_case() == kRegionCodeValueValue;
}
inline void GlobalData::set_has_regioncodevalue_value() {
  _oneof_case_[0] = kRegionCodeValueValue;
}
inline void GlobalData::clear_regioncodevalue_value() {
  if (has_regioncodevalue_value()) {
    delete value_.regioncodevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::RegionCodeValue& GlobalData::_internal_regioncodevalue_value() const {
  return *value_.regioncodevalue_value_;
}
inline ::holo::map::adasisv3::RegionCodeValue* GlobalData::release_regioncodevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.RegionCodeValue_value)
  if (has_regioncodevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::RegionCodeValue* temp = value_.regioncodevalue_value_;
    value_.regioncodevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::RegionCodeValue& GlobalData::regioncodevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.RegionCodeValue_value)
  return has_regioncodevalue_value()
      ? *value_.regioncodevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::RegionCodeValue*>(&::holo::map::adasisv3::_RegionCodeValue_default_instance_);
}
inline ::holo::map::adasisv3::RegionCodeValue* GlobalData::mutable_regioncodevalue_value() {
  if (!has_regioncodevalue_value()) {
    clear_value();
    set_has_regioncodevalue_value();
    value_.regioncodevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::RegionCodeValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.RegionCodeValue_value)
  return value_.regioncodevalue_value_;
}

// optional .holo.map.adasisv3.ExtendedSpeedLimitValue ExtendedSpeedLimitValue_value = 32;
inline bool GlobalData::has_extendedspeedlimitvalue_value() const {
  return value_case() == kExtendedSpeedLimitValueValue;
}
inline void GlobalData::set_has_extendedspeedlimitvalue_value() {
  _oneof_case_[0] = kExtendedSpeedLimitValueValue;
}
inline void GlobalData::clear_extendedspeedlimitvalue_value() {
  if (has_extendedspeedlimitvalue_value()) {
    delete value_.extendedspeedlimitvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::ExtendedSpeedLimitValue& GlobalData::_internal_extendedspeedlimitvalue_value() const {
  return *value_.extendedspeedlimitvalue_value_;
}
inline ::holo::map::adasisv3::ExtendedSpeedLimitValue* GlobalData::release_extendedspeedlimitvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.ExtendedSpeedLimitValue_value)
  if (has_extendedspeedlimitvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::ExtendedSpeedLimitValue* temp = value_.extendedspeedlimitvalue_value_;
    value_.extendedspeedlimitvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ExtendedSpeedLimitValue& GlobalData::extendedspeedlimitvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.ExtendedSpeedLimitValue_value)
  return has_extendedspeedlimitvalue_value()
      ? *value_.extendedspeedlimitvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::ExtendedSpeedLimitValue*>(&::holo::map::adasisv3::_ExtendedSpeedLimitValue_default_instance_);
}
inline ::holo::map::adasisv3::ExtendedSpeedLimitValue* GlobalData::mutable_extendedspeedlimitvalue_value() {
  if (!has_extendedspeedlimitvalue_value()) {
    clear_value();
    set_has_extendedspeedlimitvalue_value();
    value_.extendedspeedlimitvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::ExtendedSpeedLimitValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.ExtendedSpeedLimitValue_value)
  return value_.extendedspeedlimitvalue_value_;
}

// optional .holo.map.adasisv3.TrafficSignValue TrafficSignValue_value = 33;
inline bool GlobalData::has_trafficsignvalue_value() const {
  return value_case() == kTrafficSignValueValue;
}
inline void GlobalData::set_has_trafficsignvalue_value() {
  _oneof_case_[0] = kTrafficSignValueValue;
}
inline void GlobalData::clear_trafficsignvalue_value() {
  if (has_trafficsignvalue_value()) {
    delete value_.trafficsignvalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::TrafficSignValue& GlobalData::_internal_trafficsignvalue_value() const {
  return *value_.trafficsignvalue_value_;
}
inline ::holo::map::adasisv3::TrafficSignValue* GlobalData::release_trafficsignvalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.TrafficSignValue_value)
  if (has_trafficsignvalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::TrafficSignValue* temp = value_.trafficsignvalue_value_;
    value_.trafficsignvalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::TrafficSignValue& GlobalData::trafficsignvalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.TrafficSignValue_value)
  return has_trafficsignvalue_value()
      ? *value_.trafficsignvalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::TrafficSignValue*>(&::holo::map::adasisv3::_TrafficSignValue_default_instance_);
}
inline ::holo::map::adasisv3::TrafficSignValue* GlobalData::mutable_trafficsignvalue_value() {
  if (!has_trafficsignvalue_value()) {
    clear_value();
    set_has_trafficsignvalue_value();
    value_.trafficsignvalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::TrafficSignValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.TrafficSignValue_value)
  return value_.trafficsignvalue_value_;
}

// optional .holo.map.adasisv3.ConditionalRestrictionProfileValue ConditionalRestrictionProfileValue_value = 34;
inline bool GlobalData::has_conditionalrestrictionprofilevalue_value() const {
  return value_case() == kConditionalRestrictionProfileValueValue;
}
inline void GlobalData::set_has_conditionalrestrictionprofilevalue_value() {
  _oneof_case_[0] = kConditionalRestrictionProfileValueValue;
}
inline void GlobalData::clear_conditionalrestrictionprofilevalue_value() {
  if (has_conditionalrestrictionprofilevalue_value()) {
    delete value_.conditionalrestrictionprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::ConditionalRestrictionProfileValue& GlobalData::_internal_conditionalrestrictionprofilevalue_value() const {
  return *value_.conditionalrestrictionprofilevalue_value_;
}
inline ::holo::map::adasisv3::ConditionalRestrictionProfileValue* GlobalData::release_conditionalrestrictionprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.ConditionalRestrictionProfileValue_value)
  if (has_conditionalrestrictionprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::ConditionalRestrictionProfileValue* temp = value_.conditionalrestrictionprofilevalue_value_;
    value_.conditionalrestrictionprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ConditionalRestrictionProfileValue& GlobalData::conditionalrestrictionprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.ConditionalRestrictionProfileValue_value)
  return has_conditionalrestrictionprofilevalue_value()
      ? *value_.conditionalrestrictionprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::ConditionalRestrictionProfileValue*>(&::holo::map::adasisv3::_ConditionalRestrictionProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::ConditionalRestrictionProfileValue* GlobalData::mutable_conditionalrestrictionprofilevalue_value() {
  if (!has_conditionalrestrictionprofilevalue_value()) {
    clear_value();
    set_has_conditionalrestrictionprofilevalue_value();
    value_.conditionalrestrictionprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::ConditionalRestrictionProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.ConditionalRestrictionProfileValue_value)
  return value_.conditionalrestrictionprofilevalue_value_;
}

// optional .holo.map.adasisv3.OverHeadProfileValue OverHeadProfileValue_value = 35;
inline bool GlobalData::has_overheadprofilevalue_value() const {
  return value_case() == kOverHeadProfileValueValue;
}
inline void GlobalData::set_has_overheadprofilevalue_value() {
  _oneof_case_[0] = kOverHeadProfileValueValue;
}
inline void GlobalData::clear_overheadprofilevalue_value() {
  if (has_overheadprofilevalue_value()) {
    delete value_.overheadprofilevalue_value_;
    clear_has_value();
  }
}
inline const ::holo::map::adasisv3::OverHeadProfileValue& GlobalData::_internal_overheadprofilevalue_value() const {
  return *value_.overheadprofilevalue_value_;
}
inline ::holo::map::adasisv3::OverHeadProfileValue* GlobalData::release_overheadprofilevalue_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.GlobalData.OverHeadProfileValue_value)
  if (has_overheadprofilevalue_value()) {
    clear_has_value();
      ::holo::map::adasisv3::OverHeadProfileValue* temp = value_.overheadprofilevalue_value_;
    value_.overheadprofilevalue_value_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::OverHeadProfileValue& GlobalData::overheadprofilevalue_value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalData.OverHeadProfileValue_value)
  return has_overheadprofilevalue_value()
      ? *value_.overheadprofilevalue_value_
      : *reinterpret_cast< ::holo::map::adasisv3::OverHeadProfileValue*>(&::holo::map::adasisv3::_OverHeadProfileValue_default_instance_);
}
inline ::holo::map::adasisv3::OverHeadProfileValue* GlobalData::mutable_overheadprofilevalue_value() {
  if (!has_overheadprofilevalue_value()) {
    clear_value();
    set_has_overheadprofilevalue_value();
    value_.overheadprofilevalue_value_ = CreateMaybeMessage< ::holo::map::adasisv3::OverHeadProfileValue >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalData.OverHeadProfileValue_value)
  return value_.overheadprofilevalue_value_;
}

inline bool GlobalData::has_value() const {
  return value_case() != VALUE_NOT_SET;
}
inline void GlobalData::clear_has_value() {
  _oneof_case_[0] = VALUE_NOT_SET;
}
inline GlobalData::ValueCase GlobalData::value_case() const {
  return GlobalData::ValueCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GlobalDataMessage

// repeated .holo.map.adasisv3.GlobalData data = 1;
inline int GlobalDataMessage::data_size() const {
  return data_.size();
}
inline void GlobalDataMessage::clear_data() {
  data_.Clear();
}
inline ::holo::map::adasisv3::GlobalData* GlobalDataMessage::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.GlobalDataMessage.data)
  return data_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::GlobalData >*
GlobalDataMessage::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.GlobalDataMessage.data)
  return &data_;
}
inline const ::holo::map::adasisv3::GlobalData& GlobalDataMessage::data(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.GlobalDataMessage.data)
  return data_.Get(index);
}
inline ::holo::map::adasisv3::GlobalData* GlobalDataMessage::add_data() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.GlobalDataMessage.data)
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::GlobalData >&
GlobalDataMessage::data() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.GlobalDataMessage.data)
  return data_;
}

// -------------------------------------------------------------------

// ProfileControl

// required uint32 pathId = 1;
inline bool ProfileControl::has_pathid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProfileControl::set_has_pathid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProfileControl::clear_has_pathid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProfileControl::clear_pathid() {
  pathid_ = 0u;
  clear_has_pathid();
}
inline ::google::protobuf::uint32 ProfileControl::pathid() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileControl.pathId)
  return pathid_;
}
inline void ProfileControl::set_pathid(::google::protobuf::uint32 value) {
  set_has_pathid();
  pathid_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileControl.pathId)
}

// required uint32 offset = 2;
inline bool ProfileControl::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProfileControl::set_has_offset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProfileControl::clear_has_offset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProfileControl::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 ProfileControl::offset() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileControl.offset)
  return offset_;
}
inline void ProfileControl::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ProfileControl.offset)
}

// -------------------------------------------------------------------

// ProfileControlMessage

// repeated .holo.map.adasisv3.ProfileControl values = 1;
inline int ProfileControlMessage::values_size() const {
  return values_.size();
}
inline void ProfileControlMessage::clear_values() {
  values_.Clear();
}
inline ::holo::map::adasisv3::ProfileControl* ProfileControlMessage::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ProfileControlMessage.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileControl >*
ProfileControlMessage::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.ProfileControlMessage.values)
  return &values_;
}
inline const ::holo::map::adasisv3::ProfileControl& ProfileControlMessage::values(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ProfileControlMessage.values)
  return values_.Get(index);
}
inline ::holo::map::adasisv3::ProfileControl* ProfileControlMessage::add_values() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.ProfileControlMessage.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::ProfileControl >&
ProfileControlMessage::values() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.ProfileControlMessage.values)
  return values_;
}

// -------------------------------------------------------------------

// PathControl

// required uint32 Id = 1;
inline bool PathControl::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathControl::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathControl::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathControl::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 PathControl::id() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PathControl.Id)
  return id_;
}
inline void PathControl::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.PathControl.Id)
}

// required uint32 parentId = 2;
inline bool PathControl::has_parentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathControl::set_has_parentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathControl::clear_has_parentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathControl::clear_parentid() {
  parentid_ = 0u;
  clear_has_parentid();
}
inline ::google::protobuf::uint32 PathControl::parentid() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PathControl.parentId)
  return parentid_;
}
inline void PathControl::set_parentid(::google::protobuf::uint32 value) {
  set_has_parentid();
  parentid_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.PathControl.parentId)
}

// required uint32 offset = 3;
inline bool PathControl::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PathControl::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PathControl::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PathControl::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 PathControl::offset() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PathControl.offset)
  return offset_;
}
inline void PathControl::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.PathControl.offset)
}

// -------------------------------------------------------------------

// PathControlMessage

// required uint32 idFirst = 1;
inline bool PathControlMessage::has_idfirst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PathControlMessage::set_has_idfirst() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PathControlMessage::clear_has_idfirst() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PathControlMessage::clear_idfirst() {
  idfirst_ = 0u;
  clear_has_idfirst();
}
inline ::google::protobuf::uint32 PathControlMessage::idfirst() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PathControlMessage.idFirst)
  return idfirst_;
}
inline void PathControlMessage::set_idfirst(::google::protobuf::uint32 value) {
  set_has_idfirst();
  idfirst_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.PathControlMessage.idFirst)
}

// required uint32 idLast = 2;
inline bool PathControlMessage::has_idlast() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PathControlMessage::set_has_idlast() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PathControlMessage::clear_has_idlast() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PathControlMessage::clear_idlast() {
  idlast_ = 0u;
  clear_has_idlast();
}
inline ::google::protobuf::uint32 PathControlMessage::idlast() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PathControlMessage.idLast)
  return idlast_;
}
inline void PathControlMessage::set_idlast(::google::protobuf::uint32 value) {
  set_has_idlast();
  idlast_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.PathControlMessage.idLast)
}

// repeated .holo.map.adasisv3.PathControl values = 3;
inline int PathControlMessage::values_size() const {
  return values_.size();
}
inline void PathControlMessage::clear_values() {
  values_.Clear();
}
inline ::holo::map::adasisv3::PathControl* PathControlMessage::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.PathControlMessage.values)
  return values_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::PathControl >*
PathControlMessage::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.PathControlMessage.values)
  return &values_;
}
inline const ::holo::map::adasisv3::PathControl& PathControlMessage::values(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PathControlMessage.values)
  return values_.Get(index);
}
inline ::holo::map::adasisv3::PathControl* PathControlMessage::add_values() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.PathControlMessage.values)
  return values_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::PathControl >&
PathControlMessage::values() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.PathControlMessage.values)
  return values_;
}

// -------------------------------------------------------------------

// ReasonMessage

// required .holo.map.adasisv3.ReasonType type = 1;
inline bool ReasonMessage::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReasonMessage::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReasonMessage::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReasonMessage::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::holo::map::adasisv3::ReasonType ReasonMessage::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ReasonMessage.type)
  return static_cast< ::holo::map::adasisv3::ReasonType >(type_);
}
inline void ReasonMessage::set_type(::holo::map::adasisv3::ReasonType value) {
  assert(::holo::map::adasisv3::ReasonType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ReasonMessage.type)
}

// required uint32 value = 2;
inline bool ReasonMessage::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReasonMessage::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReasonMessage::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReasonMessage::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ReasonMessage::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ReasonMessage.value)
  return value_;
}
inline void ReasonMessage::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ReasonMessage.value)
}

// -------------------------------------------------------------------

// MessageOnBus

// required uint32 cyclicCounter = 1;
inline bool MessageOnBus::has_cycliccounter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageOnBus::set_has_cycliccounter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageOnBus::clear_has_cycliccounter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageOnBus::clear_cycliccounter() {
  cycliccounter_ = 0u;
  clear_has_cycliccounter();
}
inline ::google::protobuf::uint32 MessageOnBus::cycliccounter() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MessageOnBus.cyclicCounter)
  return cycliccounter_;
}
inline void MessageOnBus::set_cycliccounter(::google::protobuf::uint32 value) {
  set_has_cycliccounter();
  cycliccounter_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.MessageOnBus.cyclicCounter)
}

// required .holo.map.adasisv3.MessageType type = 2;
inline bool MessageOnBus::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageOnBus::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageOnBus::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageOnBus::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::holo::map::adasisv3::MessageType MessageOnBus::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MessageOnBus.type)
  return static_cast< ::holo::map::adasisv3::MessageType >(type_);
}
inline void MessageOnBus::set_type(::holo::map::adasisv3::MessageType value) {
  assert(::holo::map::adasisv3::MessageType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.MessageOnBus.type)
}

// optional .holo.map.adasisv3.PositionMessage PositionMessage_message = 3;
inline bool MessageOnBus::has_positionmessage_message() const {
  return message_case() == kPositionMessageMessage;
}
inline void MessageOnBus::set_has_positionmessage_message() {
  _oneof_case_[0] = kPositionMessageMessage;
}
inline void MessageOnBus::clear_positionmessage_message() {
  if (has_positionmessage_message()) {
    delete message_.positionmessage_message_;
    clear_has_message();
  }
}
inline const ::holo::map::adasisv3::PositionMessage& MessageOnBus::_internal_positionmessage_message() const {
  return *message_.positionmessage_message_;
}
inline ::holo::map::adasisv3::PositionMessage* MessageOnBus::release_positionmessage_message() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.MessageOnBus.PositionMessage_message)
  if (has_positionmessage_message()) {
    clear_has_message();
      ::holo::map::adasisv3::PositionMessage* temp = message_.positionmessage_message_;
    message_.positionmessage_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::PositionMessage& MessageOnBus::positionmessage_message() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MessageOnBus.PositionMessage_message)
  return has_positionmessage_message()
      ? *message_.positionmessage_message_
      : *reinterpret_cast< ::holo::map::adasisv3::PositionMessage*>(&::holo::map::adasisv3::_PositionMessage_default_instance_);
}
inline ::holo::map::adasisv3::PositionMessage* MessageOnBus::mutable_positionmessage_message() {
  if (!has_positionmessage_message()) {
    clear_message();
    set_has_positionmessage_message();
    message_.positionmessage_message_ = CreateMaybeMessage< ::holo::map::adasisv3::PositionMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.MessageOnBus.PositionMessage_message)
  return message_.positionmessage_message_;
}

// optional .holo.map.adasisv3.ProfileMessage ProfileMessage_message = 4;
inline bool MessageOnBus::has_profilemessage_message() const {
  return message_case() == kProfileMessageMessage;
}
inline void MessageOnBus::set_has_profilemessage_message() {
  _oneof_case_[0] = kProfileMessageMessage;
}
inline void MessageOnBus::clear_profilemessage_message() {
  if (has_profilemessage_message()) {
    delete message_.profilemessage_message_;
    clear_has_message();
  }
}
inline const ::holo::map::adasisv3::ProfileMessage& MessageOnBus::_internal_profilemessage_message() const {
  return *message_.profilemessage_message_;
}
inline ::holo::map::adasisv3::ProfileMessage* MessageOnBus::release_profilemessage_message() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.MessageOnBus.ProfileMessage_message)
  if (has_profilemessage_message()) {
    clear_has_message();
      ::holo::map::adasisv3::ProfileMessage* temp = message_.profilemessage_message_;
    message_.profilemessage_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ProfileMessage& MessageOnBus::profilemessage_message() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MessageOnBus.ProfileMessage_message)
  return has_profilemessage_message()
      ? *message_.profilemessage_message_
      : *reinterpret_cast< ::holo::map::adasisv3::ProfileMessage*>(&::holo::map::adasisv3::_ProfileMessage_default_instance_);
}
inline ::holo::map::adasisv3::ProfileMessage* MessageOnBus::mutable_profilemessage_message() {
  if (!has_profilemessage_message()) {
    clear_message();
    set_has_profilemessage_message();
    message_.profilemessage_message_ = CreateMaybeMessage< ::holo::map::adasisv3::ProfileMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.MessageOnBus.ProfileMessage_message)
  return message_.profilemessage_message_;
}

// optional .holo.map.adasisv3.GlobalDataMessage GlobalDataMessage_message = 5;
inline bool MessageOnBus::has_globaldatamessage_message() const {
  return message_case() == kGlobalDataMessageMessage;
}
inline void MessageOnBus::set_has_globaldatamessage_message() {
  _oneof_case_[0] = kGlobalDataMessageMessage;
}
inline void MessageOnBus::clear_globaldatamessage_message() {
  if (has_globaldatamessage_message()) {
    delete message_.globaldatamessage_message_;
    clear_has_message();
  }
}
inline const ::holo::map::adasisv3::GlobalDataMessage& MessageOnBus::_internal_globaldatamessage_message() const {
  return *message_.globaldatamessage_message_;
}
inline ::holo::map::adasisv3::GlobalDataMessage* MessageOnBus::release_globaldatamessage_message() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.MessageOnBus.GlobalDataMessage_message)
  if (has_globaldatamessage_message()) {
    clear_has_message();
      ::holo::map::adasisv3::GlobalDataMessage* temp = message_.globaldatamessage_message_;
    message_.globaldatamessage_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::GlobalDataMessage& MessageOnBus::globaldatamessage_message() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MessageOnBus.GlobalDataMessage_message)
  return has_globaldatamessage_message()
      ? *message_.globaldatamessage_message_
      : *reinterpret_cast< ::holo::map::adasisv3::GlobalDataMessage*>(&::holo::map::adasisv3::_GlobalDataMessage_default_instance_);
}
inline ::holo::map::adasisv3::GlobalDataMessage* MessageOnBus::mutable_globaldatamessage_message() {
  if (!has_globaldatamessage_message()) {
    clear_message();
    set_has_globaldatamessage_message();
    message_.globaldatamessage_message_ = CreateMaybeMessage< ::holo::map::adasisv3::GlobalDataMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.MessageOnBus.GlobalDataMessage_message)
  return message_.globaldatamessage_message_;
}

// optional .holo.map.adasisv3.ProfileControlMessage ProfileControlMessage_message = 6;
inline bool MessageOnBus::has_profilecontrolmessage_message() const {
  return message_case() == kProfileControlMessageMessage;
}
inline void MessageOnBus::set_has_profilecontrolmessage_message() {
  _oneof_case_[0] = kProfileControlMessageMessage;
}
inline void MessageOnBus::clear_profilecontrolmessage_message() {
  if (has_profilecontrolmessage_message()) {
    delete message_.profilecontrolmessage_message_;
    clear_has_message();
  }
}
inline const ::holo::map::adasisv3::ProfileControlMessage& MessageOnBus::_internal_profilecontrolmessage_message() const {
  return *message_.profilecontrolmessage_message_;
}
inline ::holo::map::adasisv3::ProfileControlMessage* MessageOnBus::release_profilecontrolmessage_message() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.MessageOnBus.ProfileControlMessage_message)
  if (has_profilecontrolmessage_message()) {
    clear_has_message();
      ::holo::map::adasisv3::ProfileControlMessage* temp = message_.profilecontrolmessage_message_;
    message_.profilecontrolmessage_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ProfileControlMessage& MessageOnBus::profilecontrolmessage_message() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MessageOnBus.ProfileControlMessage_message)
  return has_profilecontrolmessage_message()
      ? *message_.profilecontrolmessage_message_
      : *reinterpret_cast< ::holo::map::adasisv3::ProfileControlMessage*>(&::holo::map::adasisv3::_ProfileControlMessage_default_instance_);
}
inline ::holo::map::adasisv3::ProfileControlMessage* MessageOnBus::mutable_profilecontrolmessage_message() {
  if (!has_profilecontrolmessage_message()) {
    clear_message();
    set_has_profilecontrolmessage_message();
    message_.profilecontrolmessage_message_ = CreateMaybeMessage< ::holo::map::adasisv3::ProfileControlMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.MessageOnBus.ProfileControlMessage_message)
  return message_.profilecontrolmessage_message_;
}

// optional .holo.map.adasisv3.PathControlMessage PathControlMessage_message = 7;
inline bool MessageOnBus::has_pathcontrolmessage_message() const {
  return message_case() == kPathControlMessageMessage;
}
inline void MessageOnBus::set_has_pathcontrolmessage_message() {
  _oneof_case_[0] = kPathControlMessageMessage;
}
inline void MessageOnBus::clear_pathcontrolmessage_message() {
  if (has_pathcontrolmessage_message()) {
    delete message_.pathcontrolmessage_message_;
    clear_has_message();
  }
}
inline const ::holo::map::adasisv3::PathControlMessage& MessageOnBus::_internal_pathcontrolmessage_message() const {
  return *message_.pathcontrolmessage_message_;
}
inline ::holo::map::adasisv3::PathControlMessage* MessageOnBus::release_pathcontrolmessage_message() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.MessageOnBus.PathControlMessage_message)
  if (has_pathcontrolmessage_message()) {
    clear_has_message();
      ::holo::map::adasisv3::PathControlMessage* temp = message_.pathcontrolmessage_message_;
    message_.pathcontrolmessage_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::PathControlMessage& MessageOnBus::pathcontrolmessage_message() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MessageOnBus.PathControlMessage_message)
  return has_pathcontrolmessage_message()
      ? *message_.pathcontrolmessage_message_
      : *reinterpret_cast< ::holo::map::adasisv3::PathControlMessage*>(&::holo::map::adasisv3::_PathControlMessage_default_instance_);
}
inline ::holo::map::adasisv3::PathControlMessage* MessageOnBus::mutable_pathcontrolmessage_message() {
  if (!has_pathcontrolmessage_message()) {
    clear_message();
    set_has_pathcontrolmessage_message();
    message_.pathcontrolmessage_message_ = CreateMaybeMessage< ::holo::map::adasisv3::PathControlMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.MessageOnBus.PathControlMessage_message)
  return message_.pathcontrolmessage_message_;
}

// optional .holo.map.adasisv3.ReasonMessage ReasonMessage_message = 8;
inline bool MessageOnBus::has_reasonmessage_message() const {
  return message_case() == kReasonMessageMessage;
}
inline void MessageOnBus::set_has_reasonmessage_message() {
  _oneof_case_[0] = kReasonMessageMessage;
}
inline void MessageOnBus::clear_reasonmessage_message() {
  if (has_reasonmessage_message()) {
    delete message_.reasonmessage_message_;
    clear_has_message();
  }
}
inline const ::holo::map::adasisv3::ReasonMessage& MessageOnBus::_internal_reasonmessage_message() const {
  return *message_.reasonmessage_message_;
}
inline ::holo::map::adasisv3::ReasonMessage* MessageOnBus::release_reasonmessage_message() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.MessageOnBus.ReasonMessage_message)
  if (has_reasonmessage_message()) {
    clear_has_message();
      ::holo::map::adasisv3::ReasonMessage* temp = message_.reasonmessage_message_;
    message_.reasonmessage_message_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ReasonMessage& MessageOnBus::reasonmessage_message() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MessageOnBus.ReasonMessage_message)
  return has_reasonmessage_message()
      ? *message_.reasonmessage_message_
      : *reinterpret_cast< ::holo::map::adasisv3::ReasonMessage*>(&::holo::map::adasisv3::_ReasonMessage_default_instance_);
}
inline ::holo::map::adasisv3::ReasonMessage* MessageOnBus::mutable_reasonmessage_message() {
  if (!has_reasonmessage_message()) {
    clear_message();
    set_has_reasonmessage_message();
    message_.reasonmessage_message_ = CreateMaybeMessage< ::holo::map::adasisv3::ReasonMessage >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.MessageOnBus.ReasonMessage_message)
  return message_.reasonmessage_message_;
}

inline bool MessageOnBus::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void MessageOnBus::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline MessageOnBus::MessageCase MessageOnBus::message_case() const {
  return MessageOnBus::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// UInt32ProfileValue

// required uint32 value = 1;
inline bool UInt32ProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UInt32ProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UInt32ProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UInt32ProfileValue::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 UInt32ProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.UInt32ProfileValue.value)
  return value_;
}
inline void UInt32ProfileValue::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.UInt32ProfileValue.value)
}

// -------------------------------------------------------------------

// Int32ProfileValue

// required int32 value = 1;
inline bool Int32ProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Int32ProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Int32ProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Int32ProfileValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 Int32ProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Int32ProfileValue.value)
  return value_;
}
inline void Int32ProfileValue::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Int32ProfileValue.value)
}

// -------------------------------------------------------------------

// UInt64ProfileValue

// required uint64 value = 1;
inline bool UInt64ProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UInt64ProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UInt64ProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UInt64ProfileValue::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 UInt64ProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.UInt64ProfileValue.value)
  return value_;
}
inline void UInt64ProfileValue::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.UInt64ProfileValue.value)
}

// -------------------------------------------------------------------

// FloatProfileValue

// required float value = 1;
inline bool FloatProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloatProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloatProfileValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float FloatProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.FloatProfileValue.value)
  return value_;
}
inline void FloatProfileValue::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.FloatProfileValue.value)
}

// -------------------------------------------------------------------

// BooleanProfileValue

// required bool value = 1;
inline bool BooleanProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BooleanProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BooleanProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BooleanProfileValue::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool BooleanProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.BooleanProfileValue.value)
  return value_;
}
inline void BooleanProfileValue::set_value(bool value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.BooleanProfileValue.value)
}

// -------------------------------------------------------------------

// YesNoUnknownProfileValue

// required .holo.map.adasisv3.YesNoUnknown value = 1;
inline bool YesNoUnknownProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YesNoUnknownProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YesNoUnknownProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YesNoUnknownProfileValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::holo::map::adasisv3::YesNoUnknown YesNoUnknownProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.YesNoUnknownProfileValue.value)
  return static_cast< ::holo::map::adasisv3::YesNoUnknown >(value_);
}
inline void YesNoUnknownProfileValue::set_value(::holo::map::adasisv3::YesNoUnknown value) {
  assert(::holo::map::adasisv3::YesNoUnknown_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.YesNoUnknownProfileValue.value)
}

// -------------------------------------------------------------------

// FormOfWayProfileValue

// required .holo.map.adasisv3.FormOfWay value = 1;
inline bool FormOfWayProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FormOfWayProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FormOfWayProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FormOfWayProfileValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::holo::map::adasisv3::FormOfWay FormOfWayProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.FormOfWayProfileValue.value)
  return static_cast< ::holo::map::adasisv3::FormOfWay >(value_);
}
inline void FormOfWayProfileValue::set_value(::holo::map::adasisv3::FormOfWay value) {
  assert(::holo::map::adasisv3::FormOfWay_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.FormOfWayProfileValue.value)
}

// -------------------------------------------------------------------

// DrivingSideProfileValue

// required .holo.map.adasisv3.DrivingSide value = 1;
inline bool DrivingSideProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DrivingSideProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DrivingSideProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DrivingSideProfileValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::holo::map::adasisv3::DrivingSide DrivingSideProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.DrivingSideProfileValue.value)
  return static_cast< ::holo::map::adasisv3::DrivingSide >(value_);
}
inline void DrivingSideProfileValue::set_value(::holo::map::adasisv3::DrivingSide value) {
  assert(::holo::map::adasisv3::DrivingSide_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.DrivingSideProfileValue.value)
}

// -------------------------------------------------------------------

// UnitSystemProfileValue

// required .holo.map.adasisv3.UnitOfSystem value = 1;
inline bool UnitSystemProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitSystemProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitSystemProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitSystemProfileValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::holo::map::adasisv3::UnitOfSystem UnitSystemProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.UnitSystemProfileValue.value)
  return static_cast< ::holo::map::adasisv3::UnitOfSystem >(value_);
}
inline void UnitSystemProfileValue::set_value(::holo::map::adasisv3::UnitOfSystem value) {
  assert(::holo::map::adasisv3::UnitOfSystem_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.UnitSystemProfileValue.value)
}

// -------------------------------------------------------------------

// SpecialSituationProfileValue

// required .holo.map.adasisv3.SpecialSituationType value = 1;
inline bool SpecialSituationProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpecialSituationProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpecialSituationProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpecialSituationProfileValue::clear_value() {
  value_ = 248;
  clear_has_value();
}
inline ::holo::map::adasisv3::SpecialSituationType SpecialSituationProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.SpecialSituationProfileValue.value)
  return static_cast< ::holo::map::adasisv3::SpecialSituationType >(value_);
}
inline void SpecialSituationProfileValue::set_value(::holo::map::adasisv3::SpecialSituationType value) {
  assert(::holo::map::adasisv3::SpecialSituationType_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.SpecialSituationProfileValue.value)
}

// -------------------------------------------------------------------

// RoadConditionProfileValue

// required .holo.map.adasisv3.RoadCondition value = 1;
inline bool RoadConditionProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadConditionProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadConditionProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadConditionProfileValue::clear_value() {
  value_ = 1;
  clear_has_value();
}
inline ::holo::map::adasisv3::RoadCondition RoadConditionProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RoadConditionProfileValue.value)
  return static_cast< ::holo::map::adasisv3::RoadCondition >(value_);
}
inline void RoadConditionProfileValue::set_value(::holo::map::adasisv3::RoadCondition value) {
  assert(::holo::map::adasisv3::RoadCondition_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.RoadConditionProfileValue.value)
}

// -------------------------------------------------------------------

// WeatherProfileValue

// required .holo.map.adasisv3.WeatherRedefine value = 1;
inline bool WeatherProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeatherProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeatherProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeatherProfileValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::holo::map::adasisv3::WeatherRedefine WeatherProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.WeatherProfileValue.value)
  return static_cast< ::holo::map::adasisv3::WeatherRedefine >(value_);
}
inline void WeatherProfileValue::set_value(::holo::map::adasisv3::WeatherRedefine value) {
  assert(::holo::map::adasisv3::WeatherRedefine_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.WeatherProfileValue.value)
}

// -------------------------------------------------------------------

// MapProviderProfileValue

// required .holo.map.adasisv3.MapProvider value = 1;
inline bool MapProviderProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapProviderProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapProviderProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapProviderProfileValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::holo::map::adasisv3::MapProvider MapProviderProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MapProviderProfileValue.value)
  return static_cast< ::holo::map::adasisv3::MapProvider >(value_);
}
inline void MapProviderProfileValue::set_value(::holo::map::adasisv3::MapProvider value) {
  assert(::holo::map::adasisv3::MapProvider_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.MapProviderProfileValue.value)
}

// -------------------------------------------------------------------

// MapStatusProfileValue

// required .holo.map.adasisv3.MapStatus value = 1;
inline bool MapStatusProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapStatusProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapStatusProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapStatusProfileValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::holo::map::adasisv3::MapStatus MapStatusProfileValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.MapStatusProfileValue.value)
  return static_cast< ::holo::map::adasisv3::MapStatus >(value_);
}
inline void MapStatusProfileValue::set_value(::holo::map::adasisv3::MapStatus value) {
  assert(::holo::map::adasisv3::MapStatus_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.MapStatusProfileValue.value)
}

// -------------------------------------------------------------------

// OffsetFloatEntry

// required uint32 offset = 1;
inline bool OffsetFloatEntry::has_offset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OffsetFloatEntry::set_has_offset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OffsetFloatEntry::clear_has_offset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OffsetFloatEntry::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 OffsetFloatEntry::offset() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.OffsetFloatEntry.offset)
  return offset_;
}
inline void OffsetFloatEntry::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.OffsetFloatEntry.offset)
}

// required float value = 2;
inline bool OffsetFloatEntry::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OffsetFloatEntry::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OffsetFloatEntry::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OffsetFloatEntry::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float OffsetFloatEntry::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.OffsetFloatEntry.value)
  return value_;
}
inline void OffsetFloatEntry::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.OffsetFloatEntry.value)
}

// -------------------------------------------------------------------

// OffsetFloatProfileValue

// repeated .holo.map.adasisv3.OffsetFloatEntry entries = 1;
inline int OffsetFloatProfileValue::entries_size() const {
  return entries_.size();
}
inline void OffsetFloatProfileValue::clear_entries() {
  entries_.Clear();
}
inline ::holo::map::adasisv3::OffsetFloatEntry* OffsetFloatProfileValue::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.OffsetFloatProfileValue.entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OffsetFloatEntry >*
OffsetFloatProfileValue::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.OffsetFloatProfileValue.entries)
  return &entries_;
}
inline const ::holo::map::adasisv3::OffsetFloatEntry& OffsetFloatProfileValue::entries(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.OffsetFloatProfileValue.entries)
  return entries_.Get(index);
}
inline ::holo::map::adasisv3::OffsetFloatEntry* OffsetFloatProfileValue::add_entries() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.OffsetFloatProfileValue.entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OffsetFloatEntry >&
OffsetFloatProfileValue::entries() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.OffsetFloatProfileValue.entries)
  return entries_;
}

// -------------------------------------------------------------------

// NodeArm

// required uint32 subPath = 1;
inline bool NodeArm::has_subpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeArm::set_has_subpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeArm::clear_has_subpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeArm::clear_subpath() {
  subpath_ = 0u;
  clear_has_subpath();
}
inline ::google::protobuf::uint32 NodeArm::subpath() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.NodeArm.subPath)
  return subpath_;
}
inline void NodeArm::set_subpath(::google::protobuf::uint32 value) {
  set_has_subpath();
  subpath_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.NodeArm.subPath)
}

// required float probability = 2;
inline bool NodeArm::has_probability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeArm::set_has_probability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeArm::clear_has_probability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeArm::clear_probability() {
  probability_ = 0;
  clear_has_probability();
}
inline float NodeArm::probability() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.NodeArm.probability)
  return probability_;
}
inline void NodeArm::set_probability(float value) {
  set_has_probability();
  probability_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.NodeArm.probability)
}

// required float turnAngle = 3;
inline bool NodeArm::has_turnangle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeArm::set_has_turnangle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeArm::clear_has_turnangle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeArm::clear_turnangle() {
  turnangle_ = 0;
  clear_has_turnangle();
}
inline float NodeArm::turnangle() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.NodeArm.turnAngle)
  return turnangle_;
}
inline void NodeArm::set_turnangle(float value) {
  set_has_turnangle();
  turnangle_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.NodeArm.turnAngle)
}

// required bool isComplexIntersection = 4;
inline bool NodeArm::has_iscomplexintersection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeArm::set_has_iscomplexintersection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeArm::clear_has_iscomplexintersection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeArm::clear_iscomplexintersection() {
  iscomplexintersection_ = false;
  clear_has_iscomplexintersection();
}
inline bool NodeArm::iscomplexintersection() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.NodeArm.isComplexIntersection)
  return iscomplexintersection_;
}
inline void NodeArm::set_iscomplexintersection(bool value) {
  set_has_iscomplexintersection();
  iscomplexintersection_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.NodeArm.isComplexIntersection)
}

// required .holo.map.adasisv3.RightOfWay rightOfWay = 5;
inline bool NodeArm::has_rightofway() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeArm::set_has_rightofway() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeArm::clear_has_rightofway() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeArm::clear_rightofway() {
  rightofway_ = 0;
  clear_has_rightofway();
}
inline ::holo::map::adasisv3::RightOfWay NodeArm::rightofway() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.NodeArm.rightOfWay)
  return static_cast< ::holo::map::adasisv3::RightOfWay >(rightofway_);
}
inline void NodeArm::set_rightofway(::holo::map::adasisv3::RightOfWay value) {
  assert(::holo::map::adasisv3::RightOfWay_IsValid(value));
  set_has_rightofway();
  rightofway_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.NodeArm.rightOfWay)
}

// -------------------------------------------------------------------

// NodeProfileValue

// repeated .holo.map.adasisv3.NodeArm arms = 1;
inline int NodeProfileValue::arms_size() const {
  return arms_.size();
}
inline void NodeProfileValue::clear_arms() {
  arms_.Clear();
}
inline ::holo::map::adasisv3::NodeArm* NodeProfileValue::mutable_arms(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.NodeProfileValue.arms)
  return arms_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::NodeArm >*
NodeProfileValue::mutable_arms() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.NodeProfileValue.arms)
  return &arms_;
}
inline const ::holo::map::adasisv3::NodeArm& NodeProfileValue::arms(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.NodeProfileValue.arms)
  return arms_.Get(index);
}
inline ::holo::map::adasisv3::NodeArm* NodeProfileValue::add_arms() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.NodeProfileValue.arms)
  return arms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::NodeArm >&
NodeProfileValue::arms() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.NodeProfileValue.arms)
  return arms_;
}

// -------------------------------------------------------------------

// SystemStatusProfileValue

// required .holo.map.adasisv3.GuidanceMode guidance = 1;
inline bool SystemStatusProfileValue::has_guidance() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SystemStatusProfileValue::set_has_guidance() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SystemStatusProfileValue::clear_has_guidance() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SystemStatusProfileValue::clear_guidance() {
  guidance_ = 1;
  clear_has_guidance();
}
inline ::holo::map::adasisv3::GuidanceMode SystemStatusProfileValue::guidance() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.SystemStatusProfileValue.guidance)
  return static_cast< ::holo::map::adasisv3::GuidanceMode >(guidance_);
}
inline void SystemStatusProfileValue::set_guidance(::holo::map::adasisv3::GuidanceMode value) {
  assert(::holo::map::adasisv3::GuidanceMode_IsValid(value));
  set_has_guidance();
  guidance_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.SystemStatusProfileValue.guidance)
}

// required bool simulating = 2;
inline bool SystemStatusProfileValue::has_simulating() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SystemStatusProfileValue::set_has_simulating() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SystemStatusProfileValue::clear_has_simulating() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SystemStatusProfileValue::clear_simulating() {
  simulating_ = false;
  clear_has_simulating();
}
inline bool SystemStatusProfileValue::simulating() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.SystemStatusProfileValue.simulating)
  return simulating_;
}
inline void SystemStatusProfileValue::set_simulating(bool value) {
  set_has_simulating();
  simulating_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.SystemStatusProfileValue.simulating)
}

// -------------------------------------------------------------------

// AbsoluteVehiclePositionProfileValue

// required .holo.map.adasisv3.VehiclePosition position = 1;
inline bool AbsoluteVehiclePositionProfileValue::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AbsoluteVehiclePositionProfileValue::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AbsoluteVehiclePositionProfileValue::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AbsoluteVehiclePositionProfileValue::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::holo::map::adasisv3::VehiclePosition& AbsoluteVehiclePositionProfileValue::_internal_position() const {
  return *position_;
}
inline const ::holo::map::adasisv3::VehiclePosition& AbsoluteVehiclePositionProfileValue::position() const {
  const ::holo::map::adasisv3::VehiclePosition* p = position_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.AbsoluteVehiclePositionProfileValue.position)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::VehiclePosition*>(
      &::holo::map::adasisv3::_VehiclePosition_default_instance_);
}
inline ::holo::map::adasisv3::VehiclePosition* AbsoluteVehiclePositionProfileValue::release_position() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.AbsoluteVehiclePositionProfileValue.position)
  clear_has_position();
  ::holo::map::adasisv3::VehiclePosition* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::VehiclePosition* AbsoluteVehiclePositionProfileValue::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::VehiclePosition>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.AbsoluteVehiclePositionProfileValue.position)
  return position_;
}
inline void AbsoluteVehiclePositionProfileValue::set_allocated_position(::holo::map::adasisv3::VehiclePosition* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.AbsoluteVehiclePositionProfileValue.position)
}

// -------------------------------------------------------------------

// SurfaceConditionProfileValue

// required .holo.map.adasisv3.Quality general = 1;
inline bool SurfaceConditionProfileValue::has_general() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SurfaceConditionProfileValue::set_has_general() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SurfaceConditionProfileValue::clear_has_general() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SurfaceConditionProfileValue::clear_general() {
  general_ = 1;
  clear_has_general();
}
inline ::holo::map::adasisv3::Quality SurfaceConditionProfileValue::general() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.SurfaceConditionProfileValue.general)
  return static_cast< ::holo::map::adasisv3::Quality >(general_);
}
inline void SurfaceConditionProfileValue::set_general(::holo::map::adasisv3::Quality value) {
  assert(::holo::map::adasisv3::Quality_IsValid(value));
  set_has_general();
  general_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.SurfaceConditionProfileValue.general)
}

// required .holo.map.adasisv3.SurfaceCondition surface = 2;
inline bool SurfaceConditionProfileValue::has_surface() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SurfaceConditionProfileValue::set_has_surface() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SurfaceConditionProfileValue::clear_has_surface() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SurfaceConditionProfileValue::clear_surface() {
  surface_ = 1;
  clear_has_surface();
}
inline ::holo::map::adasisv3::SurfaceCondition SurfaceConditionProfileValue::surface() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.SurfaceConditionProfileValue.surface)
  return static_cast< ::holo::map::adasisv3::SurfaceCondition >(surface_);
}
inline void SurfaceConditionProfileValue::set_surface(::holo::map::adasisv3::SurfaceCondition value) {
  assert(::holo::map::adasisv3::SurfaceCondition_IsValid(value));
  set_has_surface();
  surface_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.SurfaceConditionProfileValue.surface)
}

// -------------------------------------------------------------------

// SpeedProfileValue

// required .holo.map.adasisv3.Speed value = 1;
inline bool SpeedProfileValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpeedProfileValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpeedProfileValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpeedProfileValue::clear_value() {
  if (value_ != NULL) value_->Clear();
  clear_has_value();
}
inline const ::holo::map::adasisv3::Speed& SpeedProfileValue::_internal_value() const {
  return *value_;
}
inline const ::holo::map::adasisv3::Speed& SpeedProfileValue::value() const {
  const ::holo::map::adasisv3::Speed* p = value_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.SpeedProfileValue.value)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::Speed*>(
      &::holo::map::adasisv3::_Speed_default_instance_);
}
inline ::holo::map::adasisv3::Speed* SpeedProfileValue::release_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.SpeedProfileValue.value)
  clear_has_value();
  ::holo::map::adasisv3::Speed* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::Speed* SpeedProfileValue::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::Speed>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.SpeedProfileValue.value)
  return value_;
}
inline void SpeedProfileValue::set_allocated_value(::holo::map::adasisv3::Speed* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.SpeedProfileValue.value)
}

// -------------------------------------------------------------------

// LaneInfo

// required uint32 laneNumber = 1;
inline bool LaneInfo::has_lanenumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneInfo::set_has_lanenumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneInfo::clear_has_lanenumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneInfo::clear_lanenumber() {
  lanenumber_ = 0u;
  clear_has_lanenumber();
}
inline ::google::protobuf::uint32 LaneInfo::lanenumber() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneInfo.laneNumber)
  return lanenumber_;
}
inline void LaneInfo::set_lanenumber(::google::protobuf::uint32 value) {
  set_has_lanenumber();
  lanenumber_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneInfo.laneNumber)
}

// required .holo.map.adasisv3.RelativeDirection direction = 2;
inline bool LaneInfo::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneInfo::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneInfo::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneInfo::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::holo::map::adasisv3::RelativeDirection LaneInfo::direction() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneInfo.direction)
  return static_cast< ::holo::map::adasisv3::RelativeDirection >(direction_);
}
inline void LaneInfo::set_direction(::holo::map::adasisv3::RelativeDirection value) {
  assert(::holo::map::adasisv3::RelativeDirection_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneInfo.direction)
}

// required .holo.map.adasisv3.LaneTransition transition = 3;
inline bool LaneInfo::has_transition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneInfo::set_has_transition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneInfo::clear_has_transition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneInfo::clear_transition() {
  transition_ = 0;
  clear_has_transition();
}
inline ::holo::map::adasisv3::LaneTransition LaneInfo::transition() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneInfo.transition)
  return static_cast< ::holo::map::adasisv3::LaneTransition >(transition_);
}
inline void LaneInfo::set_transition(::holo::map::adasisv3::LaneTransition value) {
  assert(::holo::map::adasisv3::LaneTransition_IsValid(value));
  set_has_transition();
  transition_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneInfo.transition)
}

// required uint64 types = 4;
inline bool LaneInfo::has_types() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneInfo::set_has_types() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneInfo::clear_has_types() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneInfo::clear_types() {
  types_ = GOOGLE_ULONGLONG(0);
  clear_has_types();
}
inline ::google::protobuf::uint64 LaneInfo::types() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneInfo.types)
  return types_;
}
inline void LaneInfo::set_types(::google::protobuf::uint64 value) {
  set_has_types();
  types_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneInfo.types)
}

// required uint32 centerline = 5;
inline bool LaneInfo::has_centerline() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneInfo::set_has_centerline() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneInfo::clear_has_centerline() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaneInfo::clear_centerline() {
  centerline_ = 0u;
  clear_has_centerline();
}
inline ::google::protobuf::uint32 LaneInfo::centerline() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneInfo.centerline)
  return centerline_;
}
inline void LaneInfo::set_centerline(::google::protobuf::uint32 value) {
  set_has_centerline();
  centerline_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneInfo.centerline)
}

// required uint32 leftBoundary = 6;
inline bool LaneInfo::has_leftboundary() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaneInfo::set_has_leftboundary() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaneInfo::clear_has_leftboundary() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaneInfo::clear_leftboundary() {
  leftboundary_ = 0u;
  clear_has_leftboundary();
}
inline ::google::protobuf::uint32 LaneInfo::leftboundary() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneInfo.leftBoundary)
  return leftboundary_;
}
inline void LaneInfo::set_leftboundary(::google::protobuf::uint32 value) {
  set_has_leftboundary();
  leftboundary_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneInfo.leftBoundary)
}

// required uint32 rightBoundary = 7;
inline bool LaneInfo::has_rightboundary() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LaneInfo::set_has_rightboundary() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LaneInfo::clear_has_rightboundary() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LaneInfo::clear_rightboundary() {
  rightboundary_ = 0u;
  clear_has_rightboundary();
}
inline ::google::protobuf::uint32 LaneInfo::rightboundary() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneInfo.rightBoundary)
  return rightboundary_;
}
inline void LaneInfo::set_rightboundary(::google::protobuf::uint32 value) {
  set_has_rightboundary();
  rightboundary_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneInfo.rightBoundary)
}

// -------------------------------------------------------------------

// LaneModelValue

// required uint32 totalNumberOfLanes = 1;
inline bool LaneModelValue::has_totalnumberoflanes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneModelValue::set_has_totalnumberoflanes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneModelValue::clear_has_totalnumberoflanes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneModelValue::clear_totalnumberoflanes() {
  totalnumberoflanes_ = 0u;
  clear_has_totalnumberoflanes();
}
inline ::google::protobuf::uint32 LaneModelValue::totalnumberoflanes() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneModelValue.totalNumberOfLanes)
  return totalnumberoflanes_;
}
inline void LaneModelValue::set_totalnumberoflanes(::google::protobuf::uint32 value) {
  set_has_totalnumberoflanes();
  totalnumberoflanes_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneModelValue.totalNumberOfLanes)
}

// repeated .holo.map.adasisv3.LaneInfo laneInfos = 2;
inline int LaneModelValue::laneinfos_size() const {
  return laneinfos_.size();
}
inline void LaneModelValue::clear_laneinfos() {
  laneinfos_.Clear();
}
inline ::holo::map::adasisv3::LaneInfo* LaneModelValue::mutable_laneinfos(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.LaneModelValue.laneInfos)
  return laneinfos_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneInfo >*
LaneModelValue::mutable_laneinfos() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.LaneModelValue.laneInfos)
  return &laneinfos_;
}
inline const ::holo::map::adasisv3::LaneInfo& LaneModelValue::laneinfos(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneModelValue.laneInfos)
  return laneinfos_.Get(index);
}
inline ::holo::map::adasisv3::LaneInfo* LaneModelValue::add_laneinfos() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.LaneModelValue.laneInfos)
  return laneinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneInfo >&
LaneModelValue::laneinfos() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.LaneModelValue.laneInfos)
  return laneinfos_;
}

// -------------------------------------------------------------------

// LaneConnectivityPair

// required uint32 initialLaneNumber = 1;
inline bool LaneConnectivityPair::has_initiallanenumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneConnectivityPair::set_has_initiallanenumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneConnectivityPair::clear_has_initiallanenumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneConnectivityPair::clear_initiallanenumber() {
  initiallanenumber_ = 0u;
  clear_has_initiallanenumber();
}
inline ::google::protobuf::uint32 LaneConnectivityPair::initiallanenumber() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneConnectivityPair.initialLaneNumber)
  return initiallanenumber_;
}
inline void LaneConnectivityPair::set_initiallanenumber(::google::protobuf::uint32 value) {
  set_has_initiallanenumber();
  initiallanenumber_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneConnectivityPair.initialLaneNumber)
}

// required uint32 initialPath = 2;
inline bool LaneConnectivityPair::has_initialpath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneConnectivityPair::set_has_initialpath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneConnectivityPair::clear_has_initialpath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneConnectivityPair::clear_initialpath() {
  initialpath_ = 0u;
  clear_has_initialpath();
}
inline ::google::protobuf::uint32 LaneConnectivityPair::initialpath() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneConnectivityPair.initialPath)
  return initialpath_;
}
inline void LaneConnectivityPair::set_initialpath(::google::protobuf::uint32 value) {
  set_has_initialpath();
  initialpath_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneConnectivityPair.initialPath)
}

// required uint32 newLaneNumber = 3;
inline bool LaneConnectivityPair::has_newlanenumber() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneConnectivityPair::set_has_newlanenumber() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneConnectivityPair::clear_has_newlanenumber() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneConnectivityPair::clear_newlanenumber() {
  newlanenumber_ = 0u;
  clear_has_newlanenumber();
}
inline ::google::protobuf::uint32 LaneConnectivityPair::newlanenumber() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneConnectivityPair.newLaneNumber)
  return newlanenumber_;
}
inline void LaneConnectivityPair::set_newlanenumber(::google::protobuf::uint32 value) {
  set_has_newlanenumber();
  newlanenumber_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneConnectivityPair.newLaneNumber)
}

// required uint32 newPath = 4;
inline bool LaneConnectivityPair::has_newpath() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneConnectivityPair::set_has_newpath() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneConnectivityPair::clear_has_newpath() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneConnectivityPair::clear_newpath() {
  newpath_ = 0u;
  clear_has_newpath();
}
inline ::google::protobuf::uint32 LaneConnectivityPair::newpath() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneConnectivityPair.newPath)
  return newpath_;
}
inline void LaneConnectivityPair::set_newpath(::google::protobuf::uint32 value) {
  set_has_newpath();
  newpath_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LaneConnectivityPair.newPath)
}

// -------------------------------------------------------------------

// LaneConnectivityValue

// repeated .holo.map.adasisv3.LaneConnectivityPair connectivityPairs = 1;
inline int LaneConnectivityValue::connectivitypairs_size() const {
  return connectivitypairs_.size();
}
inline void LaneConnectivityValue::clear_connectivitypairs() {
  connectivitypairs_.Clear();
}
inline ::holo::map::adasisv3::LaneConnectivityPair* LaneConnectivityValue::mutable_connectivitypairs(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.LaneConnectivityValue.connectivityPairs)
  return connectivitypairs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneConnectivityPair >*
LaneConnectivityValue::mutable_connectivitypairs() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.LaneConnectivityValue.connectivityPairs)
  return &connectivitypairs_;
}
inline const ::holo::map::adasisv3::LaneConnectivityPair& LaneConnectivityValue::connectivitypairs(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LaneConnectivityValue.connectivityPairs)
  return connectivitypairs_.Get(index);
}
inline ::holo::map::adasisv3::LaneConnectivityPair* LaneConnectivityValue::add_connectivitypairs() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.LaneConnectivityValue.connectivityPairs)
  return connectivitypairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LaneConnectivityPair >&
LaneConnectivityValue::connectivitypairs() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.LaneConnectivityValue.connectivityPairs)
  return connectivitypairs_;
}

// -------------------------------------------------------------------

// LinearObject

// required uint32 id = 1;
inline bool LinearObject::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinearObject::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinearObject::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinearObject::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 LinearObject::id() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LinearObject.id)
  return id_;
}
inline void LinearObject::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LinearObject.id)
}

// required .holo.map.adasisv3.LinearObjectConfidence confidence = 2;
inline bool LinearObject::has_confidence() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinearObject::set_has_confidence() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinearObject::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinearObject::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline ::holo::map::adasisv3::LinearObjectConfidence LinearObject::confidence() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LinearObject.confidence)
  return static_cast< ::holo::map::adasisv3::LinearObjectConfidence >(confidence_);
}
inline void LinearObject::set_confidence(::holo::map::adasisv3::LinearObjectConfidence value) {
  assert(::holo::map::adasisv3::LinearObjectConfidence_IsValid(value));
  set_has_confidence();
  confidence_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LinearObject.confidence)
}

// required .holo.map.adasisv3.LinearObjectType type = 3;
inline bool LinearObject::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinearObject::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinearObject::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinearObject::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::holo::map::adasisv3::LinearObjectType LinearObject::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LinearObject.type)
  return static_cast< ::holo::map::adasisv3::LinearObjectType >(type_);
}
inline void LinearObject::set_type(::holo::map::adasisv3::LinearObjectType value) {
  assert(::holo::map::adasisv3::LinearObjectType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LinearObject.type)
}

// required .holo.map.adasisv3.LineMarking marking = 4;
inline bool LinearObject::has_marking() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LinearObject::set_has_marking() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LinearObject::clear_has_marking() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LinearObject::clear_marking() {
  marking_ = 0;
  clear_has_marking();
}
inline ::holo::map::adasisv3::LineMarking LinearObject::marking() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LinearObject.marking)
  return static_cast< ::holo::map::adasisv3::LineMarking >(marking_);
}
inline void LinearObject::set_marking(::holo::map::adasisv3::LineMarking value) {
  assert(::holo::map::adasisv3::LineMarking_IsValid(value));
  set_has_marking();
  marking_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LinearObject.marking)
}

// required .holo.map.adasisv3.LineMarkingColour colour = 5;
inline bool LinearObject::has_colour() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LinearObject::set_has_colour() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LinearObject::clear_has_colour() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LinearObject::clear_colour() {
  colour_ = 0;
  clear_has_colour();
}
inline ::holo::map::adasisv3::LineMarkingColour LinearObject::colour() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LinearObject.colour)
  return static_cast< ::holo::map::adasisv3::LineMarkingColour >(colour_);
}
inline void LinearObject::set_colour(::holo::map::adasisv3::LineMarkingColour value) {
  assert(::holo::map::adasisv3::LineMarkingColour_IsValid(value));
  set_has_colour();
  colour_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LinearObject.colour)
}

// required bool ldm = 6;
inline bool LinearObject::has_ldm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LinearObject::set_has_ldm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LinearObject::clear_has_ldm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LinearObject::clear_ldm() {
  ldm_ = false;
  clear_has_ldm();
}
inline bool LinearObject::ldm() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LinearObject.ldm)
  return ldm_;
}
inline void LinearObject::set_ldm(bool value) {
  set_has_ldm();
  ldm_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LinearObject.ldm)
}

// -------------------------------------------------------------------

// LinearObjectDefinitionValue

// repeated .holo.map.adasisv3.LinearObject linearObjects = 1;
inline int LinearObjectDefinitionValue::linearobjects_size() const {
  return linearobjects_.size();
}
inline void LinearObjectDefinitionValue::clear_linearobjects() {
  linearobjects_.Clear();
}
inline ::holo::map::adasisv3::LinearObject* LinearObjectDefinitionValue::mutable_linearobjects(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.LinearObjectDefinitionValue.linearObjects)
  return linearobjects_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LinearObject >*
LinearObjectDefinitionValue::mutable_linearobjects() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.LinearObjectDefinitionValue.linearObjects)
  return &linearobjects_;
}
inline const ::holo::map::adasisv3::LinearObject& LinearObjectDefinitionValue::linearobjects(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LinearObjectDefinitionValue.linearObjects)
  return linearobjects_.Get(index);
}
inline ::holo::map::adasisv3::LinearObject* LinearObjectDefinitionValue::add_linearobjects() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.LinearObjectDefinitionValue.linearObjects)
  return linearobjects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LinearObject >&
LinearObjectDefinitionValue::linearobjects() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.LinearObjectDefinitionValue.linearObjects)
  return linearobjects_;
}

// -------------------------------------------------------------------

// Curve

// required .holo.map.adasisv3.CurveType type = 1;
inline bool Curve::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Curve::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Curve::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Curve::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::holo::map::adasisv3::CurveType Curve::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Curve.type)
  return static_cast< ::holo::map::adasisv3::CurveType >(type_);
}
inline void Curve::set_type(::holo::map::adasisv3::CurveType value) {
  assert(::holo::map::adasisv3::CurveType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Curve.type)
}

// repeated .holo.map.adasisv3.WGS84Point points = 2;
inline int Curve::points_size() const {
  return points_.size();
}
inline void Curve::clear_points() {
  points_.Clear();
}
inline ::holo::map::adasisv3::WGS84Point* Curve::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.Curve.points)
  return points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >*
Curve::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.Curve.points)
  return &points_;
}
inline const ::holo::map::adasisv3::WGS84Point& Curve::points(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Curve.points)
  return points_.Get(index);
}
inline ::holo::map::adasisv3::WGS84Point* Curve::add_points() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.Curve.points)
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >&
Curve::points() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.Curve.points)
  return points_;
}

// -------------------------------------------------------------------

// LineGeometryValueAttribute

// required float curvature = 1;
inline bool LineGeometryValueAttribute::has_curvature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineGeometryValueAttribute::set_has_curvature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineGeometryValueAttribute::clear_has_curvature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineGeometryValueAttribute::clear_curvature() {
  curvature_ = 0;
  clear_has_curvature();
}
inline float LineGeometryValueAttribute::curvature() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometryValueAttribute.curvature)
  return curvature_;
}
inline void LineGeometryValueAttribute::set_curvature(float value) {
  set_has_curvature();
  curvature_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LineGeometryValueAttribute.curvature)
}

// required float slope = 2;
inline bool LineGeometryValueAttribute::has_slope() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineGeometryValueAttribute::set_has_slope() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineGeometryValueAttribute::clear_has_slope() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineGeometryValueAttribute::clear_slope() {
  slope_ = 0;
  clear_has_slope();
}
inline float LineGeometryValueAttribute::slope() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometryValueAttribute.slope)
  return slope_;
}
inline void LineGeometryValueAttribute::set_slope(float value) {
  set_has_slope();
  slope_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LineGeometryValueAttribute.slope)
}

// required float banking = 3;
inline bool LineGeometryValueAttribute::has_banking() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LineGeometryValueAttribute::set_has_banking() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LineGeometryValueAttribute::clear_has_banking() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LineGeometryValueAttribute::clear_banking() {
  banking_ = 0;
  clear_has_banking();
}
inline float LineGeometryValueAttribute::banking() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometryValueAttribute.banking)
  return banking_;
}
inline void LineGeometryValueAttribute::set_banking(float value) {
  set_has_banking();
  banking_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LineGeometryValueAttribute.banking)
}

// required float headingAngle = 4;
inline bool LineGeometryValueAttribute::has_headingangle() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LineGeometryValueAttribute::set_has_headingangle() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LineGeometryValueAttribute::clear_has_headingangle() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LineGeometryValueAttribute::clear_headingangle() {
  headingangle_ = 0;
  clear_has_headingangle();
}
inline float LineGeometryValueAttribute::headingangle() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometryValueAttribute.headingAngle)
  return headingangle_;
}
inline void LineGeometryValueAttribute::set_headingangle(float value) {
  set_has_headingangle();
  headingangle_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LineGeometryValueAttribute.headingAngle)
}

// -------------------------------------------------------------------

// LineGeometryValue

// required .holo.map.adasisv3.WGS84Point wgs84point = 1;
inline bool LineGeometryValue::has_wgs84point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineGeometryValue::set_has_wgs84point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineGeometryValue::clear_has_wgs84point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineGeometryValue::clear_wgs84point() {
  if (wgs84point_ != NULL) wgs84point_->Clear();
  clear_has_wgs84point();
}
inline const ::holo::map::adasisv3::WGS84Point& LineGeometryValue::_internal_wgs84point() const {
  return *wgs84point_;
}
inline const ::holo::map::adasisv3::WGS84Point& LineGeometryValue::wgs84point() const {
  const ::holo::map::adasisv3::WGS84Point* p = wgs84point_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometryValue.wgs84point)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::WGS84Point*>(
      &::holo::map::adasisv3::_WGS84Point_default_instance_);
}
inline ::holo::map::adasisv3::WGS84Point* LineGeometryValue::release_wgs84point() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.LineGeometryValue.wgs84point)
  clear_has_wgs84point();
  ::holo::map::adasisv3::WGS84Point* temp = wgs84point_;
  wgs84point_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::WGS84Point* LineGeometryValue::mutable_wgs84point() {
  set_has_wgs84point();
  if (wgs84point_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::WGS84Point>(GetArenaNoVirtual());
    wgs84point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.LineGeometryValue.wgs84point)
  return wgs84point_;
}
inline void LineGeometryValue::set_allocated_wgs84point(::holo::map::adasisv3::WGS84Point* wgs84point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wgs84point_;
  }
  if (wgs84point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wgs84point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wgs84point, submessage_arena);
    }
    set_has_wgs84point();
  } else {
    clear_has_wgs84point();
  }
  wgs84point_ = wgs84point;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.LineGeometryValue.wgs84point)
}

// required .holo.map.adasisv3.LineGeometryValueAttribute attribute = 2;
inline bool LineGeometryValue::has_attribute() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineGeometryValue::set_has_attribute() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineGeometryValue::clear_has_attribute() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineGeometryValue::clear_attribute() {
  if (attribute_ != NULL) attribute_->Clear();
  clear_has_attribute();
}
inline const ::holo::map::adasisv3::LineGeometryValueAttribute& LineGeometryValue::_internal_attribute() const {
  return *attribute_;
}
inline const ::holo::map::adasisv3::LineGeometryValueAttribute& LineGeometryValue::attribute() const {
  const ::holo::map::adasisv3::LineGeometryValueAttribute* p = attribute_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometryValue.attribute)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::LineGeometryValueAttribute*>(
      &::holo::map::adasisv3::_LineGeometryValueAttribute_default_instance_);
}
inline ::holo::map::adasisv3::LineGeometryValueAttribute* LineGeometryValue::release_attribute() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.LineGeometryValue.attribute)
  clear_has_attribute();
  ::holo::map::adasisv3::LineGeometryValueAttribute* temp = attribute_;
  attribute_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::LineGeometryValueAttribute* LineGeometryValue::mutable_attribute() {
  set_has_attribute();
  if (attribute_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::LineGeometryValueAttribute>(GetArenaNoVirtual());
    attribute_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.LineGeometryValue.attribute)
  return attribute_;
}
inline void LineGeometryValue::set_allocated_attribute(::holo::map::adasisv3::LineGeometryValueAttribute* attribute) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete attribute_;
  }
  if (attribute) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      attribute = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, attribute, submessage_arena);
    }
    set_has_attribute();
  } else {
    clear_has_attribute();
  }
  attribute_ = attribute;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.LineGeometryValue.attribute)
}

// -------------------------------------------------------------------

// LineGeometry

// required uint32 idLine = 1;
inline bool LineGeometry::has_idline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LineGeometry::set_has_idline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LineGeometry::clear_has_idline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LineGeometry::clear_idline() {
  idline_ = 0u;
  clear_has_idline();
}
inline ::google::protobuf::uint32 LineGeometry::idline() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometry.idLine)
  return idline_;
}
inline void LineGeometry::set_idline(::google::protobuf::uint32 value) {
  set_has_idline();
  idline_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LineGeometry.idLine)
}

// required .holo.map.adasisv3.CurveType curveType = 2;
inline bool LineGeometry::has_curvetype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LineGeometry::set_has_curvetype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LineGeometry::clear_has_curvetype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LineGeometry::clear_curvetype() {
  curvetype_ = 0;
  clear_has_curvetype();
}
inline ::holo::map::adasisv3::CurveType LineGeometry::curvetype() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometry.curveType)
  return static_cast< ::holo::map::adasisv3::CurveType >(curvetype_);
}
inline void LineGeometry::set_curvetype(::holo::map::adasisv3::CurveType value) {
  assert(::holo::map::adasisv3::CurveType_IsValid(value));
  set_has_curvetype();
  curvetype_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LineGeometry.curveType)
}

// repeated .holo.map.adasisv3.WGS84Point curve = 3;
inline int LineGeometry::curve_size() const {
  return curve_.size();
}
inline void LineGeometry::clear_curve() {
  curve_.Clear();
}
inline ::holo::map::adasisv3::WGS84Point* LineGeometry::mutable_curve(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.LineGeometry.curve)
  return curve_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >*
LineGeometry::mutable_curve() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.LineGeometry.curve)
  return &curve_;
}
inline const ::holo::map::adasisv3::WGS84Point& LineGeometry::curve(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometry.curve)
  return curve_.Get(index);
}
inline ::holo::map::adasisv3::WGS84Point* LineGeometry::add_curve() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.LineGeometry.curve)
  return curve_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >&
LineGeometry::curve() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.LineGeometry.curve)
  return curve_;
}

// repeated .holo.map.adasisv3.LineGeometryValue value = 4;
inline int LineGeometry::value_size() const {
  return value_.size();
}
inline void LineGeometry::clear_value() {
  value_.Clear();
}
inline ::holo::map::adasisv3::LineGeometryValue* LineGeometry::mutable_value(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.LineGeometry.value)
  return value_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometryValue >*
LineGeometry::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.LineGeometry.value)
  return &value_;
}
inline const ::holo::map::adasisv3::LineGeometryValue& LineGeometry::value(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LineGeometry.value)
  return value_.Get(index);
}
inline ::holo::map::adasisv3::LineGeometryValue* LineGeometry::add_value() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.LineGeometry.value)
  return value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometryValue >&
LineGeometry::value() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.LineGeometry.value)
  return value_;
}

// -------------------------------------------------------------------

// LanesGeometryProfileValue

// repeated .holo.map.adasisv3.LineGeometry geometries = 1;
inline int LanesGeometryProfileValue::geometries_size() const {
  return geometries_.size();
}
inline void LanesGeometryProfileValue::clear_geometries() {
  geometries_.Clear();
}
inline ::holo::map::adasisv3::LineGeometry* LanesGeometryProfileValue::mutable_geometries(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.LanesGeometryProfileValue.geometries)
  return geometries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometry >*
LanesGeometryProfileValue::mutable_geometries() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.LanesGeometryProfileValue.geometries)
  return &geometries_;
}
inline const ::holo::map::adasisv3::LineGeometry& LanesGeometryProfileValue::geometries(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LanesGeometryProfileValue.geometries)
  return geometries_.Get(index);
}
inline ::holo::map::adasisv3::LineGeometry* LanesGeometryProfileValue::add_geometries() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.LanesGeometryProfileValue.geometries)
  return geometries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::LineGeometry >&
LanesGeometryProfileValue::geometries() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.LanesGeometryProfileValue.geometries)
  return geometries_;
}

// -------------------------------------------------------------------

// RoadGeometryProfileValue

// required .holo.map.adasisv3.Curve roadCenterline = 1;
inline bool RoadGeometryProfileValue::has_roadcenterline() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadGeometryProfileValue::set_has_roadcenterline() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadGeometryProfileValue::clear_has_roadcenterline() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadGeometryProfileValue::clear_roadcenterline() {
  if (roadcenterline_ != NULL) roadcenterline_->Clear();
  clear_has_roadcenterline();
}
inline const ::holo::map::adasisv3::Curve& RoadGeometryProfileValue::_internal_roadcenterline() const {
  return *roadcenterline_;
}
inline const ::holo::map::adasisv3::Curve& RoadGeometryProfileValue::roadcenterline() const {
  const ::holo::map::adasisv3::Curve* p = roadcenterline_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RoadGeometryProfileValue.roadCenterline)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::Curve*>(
      &::holo::map::adasisv3::_Curve_default_instance_);
}
inline ::holo::map::adasisv3::Curve* RoadGeometryProfileValue::release_roadcenterline() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.RoadGeometryProfileValue.roadCenterline)
  clear_has_roadcenterline();
  ::holo::map::adasisv3::Curve* temp = roadcenterline_;
  roadcenterline_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::Curve* RoadGeometryProfileValue::mutable_roadcenterline() {
  set_has_roadcenterline();
  if (roadcenterline_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::Curve>(GetArenaNoVirtual());
    roadcenterline_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.RoadGeometryProfileValue.roadCenterline)
  return roadcenterline_;
}
inline void RoadGeometryProfileValue::set_allocated_roadcenterline(::holo::map::adasisv3::Curve* roadcenterline) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete roadcenterline_;
  }
  if (roadcenterline) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      roadcenterline = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, roadcenterline, submessage_arena);
    }
    set_has_roadcenterline();
  } else {
    clear_has_roadcenterline();
  }
  roadcenterline_ = roadcenterline;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.RoadGeometryProfileValue.roadCenterline)
}

// -------------------------------------------------------------------

// TrafficLightProfileValue

// required .holo.map.adasisv3.TrafficLightLongitudinalPosition longitudinalPosition = 1;
inline bool TrafficLightProfileValue::has_longitudinalposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficLightProfileValue::set_has_longitudinalposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficLightProfileValue::clear_has_longitudinalposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficLightProfileValue::clear_longitudinalposition() {
  longitudinalposition_ = 0;
  clear_has_longitudinalposition();
}
inline ::holo::map::adasisv3::TrafficLightLongitudinalPosition TrafficLightProfileValue::longitudinalposition() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficLightProfileValue.longitudinalPosition)
  return static_cast< ::holo::map::adasisv3::TrafficLightLongitudinalPosition >(longitudinalposition_);
}
inline void TrafficLightProfileValue::set_longitudinalposition(::holo::map::adasisv3::TrafficLightLongitudinalPosition value) {
  assert(::holo::map::adasisv3::TrafficLightLongitudinalPosition_IsValid(value));
  set_has_longitudinalposition();
  longitudinalposition_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficLightProfileValue.longitudinalPosition)
}

// required .holo.map.adasisv3.LateralPosition lateralPosition = 2;
inline bool TrafficLightProfileValue::has_lateralposition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficLightProfileValue::set_has_lateralposition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficLightProfileValue::clear_has_lateralposition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficLightProfileValue::clear_lateralposition() {
  lateralposition_ = 0;
  clear_has_lateralposition();
}
inline ::holo::map::adasisv3::LateralPosition TrafficLightProfileValue::lateralposition() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficLightProfileValue.lateralPosition)
  return static_cast< ::holo::map::adasisv3::LateralPosition >(lateralposition_);
}
inline void TrafficLightProfileValue::set_lateralposition(::holo::map::adasisv3::LateralPosition value) {
  assert(::holo::map::adasisv3::LateralPosition_IsValid(value));
  set_has_lateralposition();
  lateralposition_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficLightProfileValue.lateralPosition)
}

// required double cycleTime = 3;
inline bool TrafficLightProfileValue::has_cycletime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficLightProfileValue::set_has_cycletime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficLightProfileValue::clear_has_cycletime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficLightProfileValue::clear_cycletime() {
  cycletime_ = 0;
  clear_has_cycletime();
}
inline double TrafficLightProfileValue::cycletime() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficLightProfileValue.cycleTime)
  return cycletime_;
}
inline void TrafficLightProfileValue::set_cycletime(double value) {
  set_has_cycletime();
  cycletime_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficLightProfileValue.cycleTime)
}

// required .holo.map.adasisv3.TrafficLightState currentState = 4;
inline bool TrafficLightProfileValue::has_currentstate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficLightProfileValue::set_has_currentstate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficLightProfileValue::clear_has_currentstate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficLightProfileValue::clear_currentstate() {
  currentstate_ = 0;
  clear_has_currentstate();
}
inline ::holo::map::adasisv3::TrafficLightState TrafficLightProfileValue::currentstate() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficLightProfileValue.currentState)
  return static_cast< ::holo::map::adasisv3::TrafficLightState >(currentstate_);
}
inline void TrafficLightProfileValue::set_currentstate(::holo::map::adasisv3::TrafficLightState value) {
  assert(::holo::map::adasisv3::TrafficLightState_IsValid(value));
  set_has_currentstate();
  currentstate_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficLightProfileValue.currentState)
}

// required .holo.map.adasisv3.YesNoUnknown turnOnRedAllowed = 5;
inline bool TrafficLightProfileValue::has_turnonredallowed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrafficLightProfileValue::set_has_turnonredallowed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrafficLightProfileValue::clear_has_turnonredallowed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrafficLightProfileValue::clear_turnonredallowed() {
  turnonredallowed_ = 0;
  clear_has_turnonredallowed();
}
inline ::holo::map::adasisv3::YesNoUnknown TrafficLightProfileValue::turnonredallowed() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficLightProfileValue.turnOnRedAllowed)
  return static_cast< ::holo::map::adasisv3::YesNoUnknown >(turnonredallowed_);
}
inline void TrafficLightProfileValue::set_turnonredallowed(::holo::map::adasisv3::YesNoUnknown value) {
  assert(::holo::map::adasisv3::YesNoUnknown_IsValid(value));
  set_has_turnonredallowed();
  turnonredallowed_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficLightProfileValue.turnOnRedAllowed)
}

// required .holo.map.adasisv3.WGS84Point position = 6;
inline bool TrafficLightProfileValue::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficLightProfileValue::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficLightProfileValue::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficLightProfileValue::clear_position() {
  if (position_ != NULL) position_->Clear();
  clear_has_position();
}
inline const ::holo::map::adasisv3::WGS84Point& TrafficLightProfileValue::_internal_position() const {
  return *position_;
}
inline const ::holo::map::adasisv3::WGS84Point& TrafficLightProfileValue::position() const {
  const ::holo::map::adasisv3::WGS84Point* p = position_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficLightProfileValue.position)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::WGS84Point*>(
      &::holo::map::adasisv3::_WGS84Point_default_instance_);
}
inline ::holo::map::adasisv3::WGS84Point* TrafficLightProfileValue::release_position() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.TrafficLightProfileValue.position)
  clear_has_position();
  ::holo::map::adasisv3::WGS84Point* temp = position_;
  position_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::WGS84Point* TrafficLightProfileValue::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::WGS84Point>(GetArenaNoVirtual());
    position_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.TrafficLightProfileValue.position)
  return position_;
}
inline void TrafficLightProfileValue::set_allocated_position(::holo::map::adasisv3::WGS84Point* position) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete position_;
  }
  if (position) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      position = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    set_has_position();
  } else {
    clear_has_position();
  }
  position_ = position;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.TrafficLightProfileValue.position)
}

// required .holo.map.adasisv3.WGS84Point boundingBox = 7;
inline bool TrafficLightProfileValue::has_boundingbox() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficLightProfileValue::set_has_boundingbox() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficLightProfileValue::clear_has_boundingbox() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficLightProfileValue::clear_boundingbox() {
  if (boundingbox_ != NULL) boundingbox_->Clear();
  clear_has_boundingbox();
}
inline const ::holo::map::adasisv3::WGS84Point& TrafficLightProfileValue::_internal_boundingbox() const {
  return *boundingbox_;
}
inline const ::holo::map::adasisv3::WGS84Point& TrafficLightProfileValue::boundingbox() const {
  const ::holo::map::adasisv3::WGS84Point* p = boundingbox_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficLightProfileValue.boundingBox)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::WGS84Point*>(
      &::holo::map::adasisv3::_WGS84Point_default_instance_);
}
inline ::holo::map::adasisv3::WGS84Point* TrafficLightProfileValue::release_boundingbox() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.TrafficLightProfileValue.boundingBox)
  clear_has_boundingbox();
  ::holo::map::adasisv3::WGS84Point* temp = boundingbox_;
  boundingbox_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::WGS84Point* TrafficLightProfileValue::mutable_boundingbox() {
  set_has_boundingbox();
  if (boundingbox_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::WGS84Point>(GetArenaNoVirtual());
    boundingbox_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.TrafficLightProfileValue.boundingBox)
  return boundingbox_;
}
inline void TrafficLightProfileValue::set_allocated_boundingbox(::holo::map::adasisv3::WGS84Point* boundingbox) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete boundingbox_;
  }
  if (boundingbox) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      boundingbox = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, boundingbox, submessage_arena);
    }
    set_has_boundingbox();
  } else {
    clear_has_boundingbox();
  }
  boundingbox_ = boundingbox;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.TrafficLightProfileValue.boundingBox)
}

// -------------------------------------------------------------------

// EffectiveSpeedLimit

// required .holo.map.adasisv3.Speed value = 1;
inline bool EffectiveSpeedLimit::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EffectiveSpeedLimit::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EffectiveSpeedLimit::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EffectiveSpeedLimit::clear_value() {
  if (value_ != NULL) value_->Clear();
  clear_has_value();
}
inline const ::holo::map::adasisv3::Speed& EffectiveSpeedLimit::_internal_value() const {
  return *value_;
}
inline const ::holo::map::adasisv3::Speed& EffectiveSpeedLimit::value() const {
  const ::holo::map::adasisv3::Speed* p = value_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.EffectiveSpeedLimit.value)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::Speed*>(
      &::holo::map::adasisv3::_Speed_default_instance_);
}
inline ::holo::map::adasisv3::Speed* EffectiveSpeedLimit::release_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.EffectiveSpeedLimit.value)
  clear_has_value();
  ::holo::map::adasisv3::Speed* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::Speed* EffectiveSpeedLimit::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::Speed>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.EffectiveSpeedLimit.value)
  return value_;
}
inline void EffectiveSpeedLimit::set_allocated_value(::holo::map::adasisv3::Speed* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.EffectiveSpeedLimit.value)
}

// required .holo.map.adasisv3.EffectiveSpeedLimitType type = 2;
inline bool EffectiveSpeedLimit::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EffectiveSpeedLimit::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EffectiveSpeedLimit::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EffectiveSpeedLimit::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::holo::map::adasisv3::EffectiveSpeedLimitType EffectiveSpeedLimit::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.EffectiveSpeedLimit.type)
  return static_cast< ::holo::map::adasisv3::EffectiveSpeedLimitType >(type_);
}
inline void EffectiveSpeedLimit::set_type(::holo::map::adasisv3::EffectiveSpeedLimitType value) {
  assert(::holo::map::adasisv3::EffectiveSpeedLimitType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.EffectiveSpeedLimit.type)
}

// -------------------------------------------------------------------

// LocationObject

// required .holo.map.adasisv3.LocationObjectType type = 1;
inline bool LocationObject::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocationObject::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocationObject::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocationObject::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::holo::map::adasisv3::LocationObjectType LocationObject::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LocationObject.type)
  return static_cast< ::holo::map::adasisv3::LocationObjectType >(type_);
}
inline void LocationObject::set_type(::holo::map::adasisv3::LocationObjectType value) {
  assert(::holo::map::adasisv3::LocationObjectType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LocationObject.type)
}

// required int32 lateralOffset = 2;
inline bool LocationObject::has_lateraloffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocationObject::set_has_lateraloffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocationObject::clear_has_lateraloffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocationObject::clear_lateraloffset() {
  lateraloffset_ = 0;
  clear_has_lateraloffset();
}
inline ::google::protobuf::int32 LocationObject::lateraloffset() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LocationObject.lateralOffset)
  return lateraloffset_;
}
inline void LocationObject::set_lateraloffset(::google::protobuf::int32 value) {
  set_has_lateraloffset();
  lateraloffset_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.LocationObject.lateralOffset)
}

// required .holo.map.adasisv3.WGS84Point absolutePosition = 3;
inline bool LocationObject::has_absoluteposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocationObject::set_has_absoluteposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocationObject::clear_has_absoluteposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocationObject::clear_absoluteposition() {
  if (absoluteposition_ != NULL) absoluteposition_->Clear();
  clear_has_absoluteposition();
}
inline const ::holo::map::adasisv3::WGS84Point& LocationObject::_internal_absoluteposition() const {
  return *absoluteposition_;
}
inline const ::holo::map::adasisv3::WGS84Point& LocationObject::absoluteposition() const {
  const ::holo::map::adasisv3::WGS84Point* p = absoluteposition_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.LocationObject.absolutePosition)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::WGS84Point*>(
      &::holo::map::adasisv3::_WGS84Point_default_instance_);
}
inline ::holo::map::adasisv3::WGS84Point* LocationObject::release_absoluteposition() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.LocationObject.absolutePosition)
  clear_has_absoluteposition();
  ::holo::map::adasisv3::WGS84Point* temp = absoluteposition_;
  absoluteposition_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::WGS84Point* LocationObject::mutable_absoluteposition() {
  set_has_absoluteposition();
  if (absoluteposition_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::WGS84Point>(GetArenaNoVirtual());
    absoluteposition_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.LocationObject.absolutePosition)
  return absoluteposition_;
}
inline void LocationObject::set_allocated_absoluteposition(::holo::map::adasisv3::WGS84Point* absoluteposition) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete absoluteposition_;
  }
  if (absoluteposition) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      absoluteposition = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, absoluteposition, submessage_arena);
    }
    set_has_absoluteposition();
  } else {
    clear_has_absoluteposition();
  }
  absoluteposition_ = absoluteposition;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.LocationObject.absolutePosition)
}

// -------------------------------------------------------------------

// RegionCodeValue

// repeated uint32 value = 1;
inline int RegionCodeValue::value_size() const {
  return value_.size();
}
inline void RegionCodeValue::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 RegionCodeValue::value(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RegionCodeValue.value)
  return value_.Get(index);
}
inline void RegionCodeValue::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.RegionCodeValue.value)
}
inline void RegionCodeValue::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.RegionCodeValue.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RegionCodeValue::value() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.RegionCodeValue.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RegionCodeValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.RegionCodeValue.value)
  return &value_;
}

// -------------------------------------------------------------------

// ConditionNumeric

// required uint32 value = 1;
inline bool ConditionNumeric::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionNumeric::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionNumeric::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionNumeric::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 ConditionNumeric::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionNumeric.value)
  return value_;
}
inline void ConditionNumeric::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ConditionNumeric.value)
}

// -------------------------------------------------------------------

// ConditionVehicleType

// required uint32 vehicleTypeMask = 1;
inline bool ConditionVehicleType::has_vehicletypemask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionVehicleType::set_has_vehicletypemask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionVehicleType::clear_has_vehicletypemask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionVehicleType::clear_vehicletypemask() {
  vehicletypemask_ = 0u;
  clear_has_vehicletypemask();
}
inline ::google::protobuf::uint32 ConditionVehicleType::vehicletypemask() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionVehicleType.vehicleTypeMask)
  return vehicletypemask_;
}
inline void ConditionVehicleType::set_vehicletypemask(::google::protobuf::uint32 value) {
  set_has_vehicletypemask();
  vehicletypemask_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ConditionVehicleType.vehicleTypeMask)
}

// -------------------------------------------------------------------

// ConditionLoad

// required .holo.map.adasisv3.Load value = 1;
inline bool ConditionLoad::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionLoad::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionLoad::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionLoad::clear_value() {
  value_ = 1;
  clear_has_value();
}
inline ::holo::map::adasisv3::Load ConditionLoad::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionLoad.value)
  return static_cast< ::holo::map::adasisv3::Load >(value_);
}
inline void ConditionLoad::set_value(::holo::map::adasisv3::Load value) {
  assert(::holo::map::adasisv3::Load_IsValid(value));
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ConditionLoad.value)
}

// -------------------------------------------------------------------

// ConditionTimeOfDay

// required uint32 startMinutes = 1;
inline bool ConditionTimeOfDay::has_startminutes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionTimeOfDay::set_has_startminutes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionTimeOfDay::clear_has_startminutes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionTimeOfDay::clear_startminutes() {
  startminutes_ = 0u;
  clear_has_startminutes();
}
inline ::google::protobuf::uint32 ConditionTimeOfDay::startminutes() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionTimeOfDay.startMinutes)
  return startminutes_;
}
inline void ConditionTimeOfDay::set_startminutes(::google::protobuf::uint32 value) {
  set_has_startminutes();
  startminutes_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ConditionTimeOfDay.startMinutes)
}

// required uint32 endMinutes = 2;
inline bool ConditionTimeOfDay::has_endminutes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConditionTimeOfDay::set_has_endminutes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConditionTimeOfDay::clear_has_endminutes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConditionTimeOfDay::clear_endminutes() {
  endminutes_ = 0u;
  clear_has_endminutes();
}
inline ::google::protobuf::uint32 ConditionTimeOfDay::endminutes() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionTimeOfDay.endMinutes)
  return endminutes_;
}
inline void ConditionTimeOfDay::set_endminutes(::google::protobuf::uint32 value) {
  set_has_endminutes();
  endminutes_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ConditionTimeOfDay.endMinutes)
}

// -------------------------------------------------------------------

// ConditionWeather

// required .holo.map.adasisv3.Weather weather = 1;
inline bool ConditionWeather::has_weather() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionWeather::set_has_weather() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionWeather::clear_has_weather() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionWeather::clear_weather() {
  weather_ = 0;
  clear_has_weather();
}
inline ::holo::map::adasisv3::Weather ConditionWeather::weather() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionWeather.weather)
  return static_cast< ::holo::map::adasisv3::Weather >(weather_);
}
inline void ConditionWeather::set_weather(::holo::map::adasisv3::Weather value) {
  assert(::holo::map::adasisv3::Weather_IsValid(value));
  set_has_weather();
  weather_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ConditionWeather.weather)
}

// -------------------------------------------------------------------

// ConditionFuzzyTime

// required .holo.map.adasisv3.FuzzyTime fuzzyTime = 1;
inline bool ConditionFuzzyTime::has_fuzzytime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionFuzzyTime::set_has_fuzzytime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionFuzzyTime::clear_has_fuzzytime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionFuzzyTime::clear_fuzzytime() {
  fuzzytime_ = 1;
  clear_has_fuzzytime();
}
inline ::holo::map::adasisv3::FuzzyTime ConditionFuzzyTime::fuzzytime() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionFuzzyTime.fuzzyTime)
  return static_cast< ::holo::map::adasisv3::FuzzyTime >(fuzzytime_);
}
inline void ConditionFuzzyTime::set_fuzzytime(::holo::map::adasisv3::FuzzyTime value) {
  assert(::holo::map::adasisv3::FuzzyTime_IsValid(value));
  set_has_fuzzytime();
  fuzzytime_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ConditionFuzzyTime.fuzzyTime)
}

// -------------------------------------------------------------------

// ConditionTurnDirection

// required .holo.map.adasisv3.LaneArrowMarking direction = 1;
inline bool ConditionTurnDirection::has_direction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionTurnDirection::set_has_direction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionTurnDirection::clear_has_direction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionTurnDirection::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::holo::map::adasisv3::LaneArrowMarking ConditionTurnDirection::direction() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionTurnDirection.direction)
  return static_cast< ::holo::map::adasisv3::LaneArrowMarking >(direction_);
}
inline void ConditionTurnDirection::set_direction(::holo::map::adasisv3::LaneArrowMarking value) {
  assert(::holo::map::adasisv3::LaneArrowMarking_IsValid(value));
  set_has_direction();
  direction_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ConditionTurnDirection.direction)
}

// -------------------------------------------------------------------

// Condition

// required .holo.map.adasisv3.ConditionType type = 1;
inline bool Condition::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Condition::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Condition::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Condition::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::holo::map::adasisv3::ConditionType Condition::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Condition.type)
  return static_cast< ::holo::map::adasisv3::ConditionType >(type_);
}
inline void Condition::set_type(::holo::map::adasisv3::ConditionType value) {
  assert(::holo::map::adasisv3::ConditionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Condition.type)
}

// required .holo.map.adasisv3.YesNoUnknown appliesToEgoVehicle = 2;
inline bool Condition::has_appliestoegovehicle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Condition::set_has_appliestoegovehicle() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Condition::clear_has_appliestoegovehicle() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Condition::clear_appliestoegovehicle() {
  appliestoegovehicle_ = 0;
  clear_has_appliestoegovehicle();
}
inline ::holo::map::adasisv3::YesNoUnknown Condition::appliestoegovehicle() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Condition.appliesToEgoVehicle)
  return static_cast< ::holo::map::adasisv3::YesNoUnknown >(appliestoegovehicle_);
}
inline void Condition::set_appliestoegovehicle(::holo::map::adasisv3::YesNoUnknown value) {
  assert(::holo::map::adasisv3::YesNoUnknown_IsValid(value));
  set_has_appliestoegovehicle();
  appliestoegovehicle_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.Condition.appliesToEgoVehicle)
}

// optional .holo.map.adasisv3.ConditionNumeric condition_numeric = 3;
inline bool Condition::has_condition_numeric() const {
  return condition_case() == kConditionNumeric;
}
inline void Condition::set_has_condition_numeric() {
  _oneof_case_[0] = kConditionNumeric;
}
inline void Condition::clear_condition_numeric() {
  if (has_condition_numeric()) {
    delete condition_.condition_numeric_;
    clear_has_condition();
  }
}
inline const ::holo::map::adasisv3::ConditionNumeric& Condition::_internal_condition_numeric() const {
  return *condition_.condition_numeric_;
}
inline ::holo::map::adasisv3::ConditionNumeric* Condition::release_condition_numeric() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.Condition.condition_numeric)
  if (has_condition_numeric()) {
    clear_has_condition();
      ::holo::map::adasisv3::ConditionNumeric* temp = condition_.condition_numeric_;
    condition_.condition_numeric_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ConditionNumeric& Condition::condition_numeric() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Condition.condition_numeric)
  return has_condition_numeric()
      ? *condition_.condition_numeric_
      : *reinterpret_cast< ::holo::map::adasisv3::ConditionNumeric*>(&::holo::map::adasisv3::_ConditionNumeric_default_instance_);
}
inline ::holo::map::adasisv3::ConditionNumeric* Condition::mutable_condition_numeric() {
  if (!has_condition_numeric()) {
    clear_condition();
    set_has_condition_numeric();
    condition_.condition_numeric_ = CreateMaybeMessage< ::holo::map::adasisv3::ConditionNumeric >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.Condition.condition_numeric)
  return condition_.condition_numeric_;
}

// optional .holo.map.adasisv3.ConditionVehicleType condition_vehicleType = 4;
inline bool Condition::has_condition_vehicletype() const {
  return condition_case() == kConditionVehicleType;
}
inline void Condition::set_has_condition_vehicletype() {
  _oneof_case_[0] = kConditionVehicleType;
}
inline void Condition::clear_condition_vehicletype() {
  if (has_condition_vehicletype()) {
    delete condition_.condition_vehicletype_;
    clear_has_condition();
  }
}
inline const ::holo::map::adasisv3::ConditionVehicleType& Condition::_internal_condition_vehicletype() const {
  return *condition_.condition_vehicletype_;
}
inline ::holo::map::adasisv3::ConditionVehicleType* Condition::release_condition_vehicletype() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.Condition.condition_vehicleType)
  if (has_condition_vehicletype()) {
    clear_has_condition();
      ::holo::map::adasisv3::ConditionVehicleType* temp = condition_.condition_vehicletype_;
    condition_.condition_vehicletype_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ConditionVehicleType& Condition::condition_vehicletype() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Condition.condition_vehicleType)
  return has_condition_vehicletype()
      ? *condition_.condition_vehicletype_
      : *reinterpret_cast< ::holo::map::adasisv3::ConditionVehicleType*>(&::holo::map::adasisv3::_ConditionVehicleType_default_instance_);
}
inline ::holo::map::adasisv3::ConditionVehicleType* Condition::mutable_condition_vehicletype() {
  if (!has_condition_vehicletype()) {
    clear_condition();
    set_has_condition_vehicletype();
    condition_.condition_vehicletype_ = CreateMaybeMessage< ::holo::map::adasisv3::ConditionVehicleType >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.Condition.condition_vehicleType)
  return condition_.condition_vehicletype_;
}

// optional .holo.map.adasisv3.ConditionLoad condition_load = 5;
inline bool Condition::has_condition_load() const {
  return condition_case() == kConditionLoad;
}
inline void Condition::set_has_condition_load() {
  _oneof_case_[0] = kConditionLoad;
}
inline void Condition::clear_condition_load() {
  if (has_condition_load()) {
    delete condition_.condition_load_;
    clear_has_condition();
  }
}
inline const ::holo::map::adasisv3::ConditionLoad& Condition::_internal_condition_load() const {
  return *condition_.condition_load_;
}
inline ::holo::map::adasisv3::ConditionLoad* Condition::release_condition_load() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.Condition.condition_load)
  if (has_condition_load()) {
    clear_has_condition();
      ::holo::map::adasisv3::ConditionLoad* temp = condition_.condition_load_;
    condition_.condition_load_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ConditionLoad& Condition::condition_load() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Condition.condition_load)
  return has_condition_load()
      ? *condition_.condition_load_
      : *reinterpret_cast< ::holo::map::adasisv3::ConditionLoad*>(&::holo::map::adasisv3::_ConditionLoad_default_instance_);
}
inline ::holo::map::adasisv3::ConditionLoad* Condition::mutable_condition_load() {
  if (!has_condition_load()) {
    clear_condition();
    set_has_condition_load();
    condition_.condition_load_ = CreateMaybeMessage< ::holo::map::adasisv3::ConditionLoad >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.Condition.condition_load)
  return condition_.condition_load_;
}

// optional .holo.map.adasisv3.ConditionTimeOfDay condition_timeOfDay = 6;
inline bool Condition::has_condition_timeofday() const {
  return condition_case() == kConditionTimeOfDay;
}
inline void Condition::set_has_condition_timeofday() {
  _oneof_case_[0] = kConditionTimeOfDay;
}
inline void Condition::clear_condition_timeofday() {
  if (has_condition_timeofday()) {
    delete condition_.condition_timeofday_;
    clear_has_condition();
  }
}
inline const ::holo::map::adasisv3::ConditionTimeOfDay& Condition::_internal_condition_timeofday() const {
  return *condition_.condition_timeofday_;
}
inline ::holo::map::adasisv3::ConditionTimeOfDay* Condition::release_condition_timeofday() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.Condition.condition_timeOfDay)
  if (has_condition_timeofday()) {
    clear_has_condition();
      ::holo::map::adasisv3::ConditionTimeOfDay* temp = condition_.condition_timeofday_;
    condition_.condition_timeofday_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ConditionTimeOfDay& Condition::condition_timeofday() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Condition.condition_timeOfDay)
  return has_condition_timeofday()
      ? *condition_.condition_timeofday_
      : *reinterpret_cast< ::holo::map::adasisv3::ConditionTimeOfDay*>(&::holo::map::adasisv3::_ConditionTimeOfDay_default_instance_);
}
inline ::holo::map::adasisv3::ConditionTimeOfDay* Condition::mutable_condition_timeofday() {
  if (!has_condition_timeofday()) {
    clear_condition();
    set_has_condition_timeofday();
    condition_.condition_timeofday_ = CreateMaybeMessage< ::holo::map::adasisv3::ConditionTimeOfDay >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.Condition.condition_timeOfDay)
  return condition_.condition_timeofday_;
}

// optional .holo.map.adasisv3.ConditionWeather condition_weather = 7;
inline bool Condition::has_condition_weather() const {
  return condition_case() == kConditionWeather;
}
inline void Condition::set_has_condition_weather() {
  _oneof_case_[0] = kConditionWeather;
}
inline void Condition::clear_condition_weather() {
  if (has_condition_weather()) {
    delete condition_.condition_weather_;
    clear_has_condition();
  }
}
inline const ::holo::map::adasisv3::ConditionWeather& Condition::_internal_condition_weather() const {
  return *condition_.condition_weather_;
}
inline ::holo::map::adasisv3::ConditionWeather* Condition::release_condition_weather() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.Condition.condition_weather)
  if (has_condition_weather()) {
    clear_has_condition();
      ::holo::map::adasisv3::ConditionWeather* temp = condition_.condition_weather_;
    condition_.condition_weather_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ConditionWeather& Condition::condition_weather() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Condition.condition_weather)
  return has_condition_weather()
      ? *condition_.condition_weather_
      : *reinterpret_cast< ::holo::map::adasisv3::ConditionWeather*>(&::holo::map::adasisv3::_ConditionWeather_default_instance_);
}
inline ::holo::map::adasisv3::ConditionWeather* Condition::mutable_condition_weather() {
  if (!has_condition_weather()) {
    clear_condition();
    set_has_condition_weather();
    condition_.condition_weather_ = CreateMaybeMessage< ::holo::map::adasisv3::ConditionWeather >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.Condition.condition_weather)
  return condition_.condition_weather_;
}

// optional .holo.map.adasisv3.ConditionFuzzyTime condition_fuzzyTime = 8;
inline bool Condition::has_condition_fuzzytime() const {
  return condition_case() == kConditionFuzzyTime;
}
inline void Condition::set_has_condition_fuzzytime() {
  _oneof_case_[0] = kConditionFuzzyTime;
}
inline void Condition::clear_condition_fuzzytime() {
  if (has_condition_fuzzytime()) {
    delete condition_.condition_fuzzytime_;
    clear_has_condition();
  }
}
inline const ::holo::map::adasisv3::ConditionFuzzyTime& Condition::_internal_condition_fuzzytime() const {
  return *condition_.condition_fuzzytime_;
}
inline ::holo::map::adasisv3::ConditionFuzzyTime* Condition::release_condition_fuzzytime() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.Condition.condition_fuzzyTime)
  if (has_condition_fuzzytime()) {
    clear_has_condition();
      ::holo::map::adasisv3::ConditionFuzzyTime* temp = condition_.condition_fuzzytime_;
    condition_.condition_fuzzytime_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ConditionFuzzyTime& Condition::condition_fuzzytime() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Condition.condition_fuzzyTime)
  return has_condition_fuzzytime()
      ? *condition_.condition_fuzzytime_
      : *reinterpret_cast< ::holo::map::adasisv3::ConditionFuzzyTime*>(&::holo::map::adasisv3::_ConditionFuzzyTime_default_instance_);
}
inline ::holo::map::adasisv3::ConditionFuzzyTime* Condition::mutable_condition_fuzzytime() {
  if (!has_condition_fuzzytime()) {
    clear_condition();
    set_has_condition_fuzzytime();
    condition_.condition_fuzzytime_ = CreateMaybeMessage< ::holo::map::adasisv3::ConditionFuzzyTime >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.Condition.condition_fuzzyTime)
  return condition_.condition_fuzzytime_;
}

// optional .holo.map.adasisv3.ConditionTurnDirection condition_turnDirection = 9;
inline bool Condition::has_condition_turndirection() const {
  return condition_case() == kConditionTurnDirection;
}
inline void Condition::set_has_condition_turndirection() {
  _oneof_case_[0] = kConditionTurnDirection;
}
inline void Condition::clear_condition_turndirection() {
  if (has_condition_turndirection()) {
    delete condition_.condition_turndirection_;
    clear_has_condition();
  }
}
inline const ::holo::map::adasisv3::ConditionTurnDirection& Condition::_internal_condition_turndirection() const {
  return *condition_.condition_turndirection_;
}
inline ::holo::map::adasisv3::ConditionTurnDirection* Condition::release_condition_turndirection() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.Condition.condition_turnDirection)
  if (has_condition_turndirection()) {
    clear_has_condition();
      ::holo::map::adasisv3::ConditionTurnDirection* temp = condition_.condition_turndirection_;
    condition_.condition_turndirection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::holo::map::adasisv3::ConditionTurnDirection& Condition::condition_turndirection() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.Condition.condition_turnDirection)
  return has_condition_turndirection()
      ? *condition_.condition_turndirection_
      : *reinterpret_cast< ::holo::map::adasisv3::ConditionTurnDirection*>(&::holo::map::adasisv3::_ConditionTurnDirection_default_instance_);
}
inline ::holo::map::adasisv3::ConditionTurnDirection* Condition::mutable_condition_turndirection() {
  if (!has_condition_turndirection()) {
    clear_condition();
    set_has_condition_turndirection();
    condition_.condition_turndirection_ = CreateMaybeMessage< ::holo::map::adasisv3::ConditionTurnDirection >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.Condition.condition_turnDirection)
  return condition_.condition_turndirection_;
}

inline bool Condition::has_condition() const {
  return condition_case() != CONDITION_NOT_SET;
}
inline void Condition::clear_has_condition() {
  _oneof_case_[0] = CONDITION_NOT_SET;
}
inline Condition::ConditionCase Condition::condition_case() const {
  return Condition::ConditionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ExtendedSpeedLimitValue

// required .holo.map.adasisv3.Speed value = 1;
inline bool ExtendedSpeedLimitValue::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtendedSpeedLimitValue::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtendedSpeedLimitValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtendedSpeedLimitValue::clear_value() {
  if (value_ != NULL) value_->Clear();
  clear_has_value();
}
inline const ::holo::map::adasisv3::Speed& ExtendedSpeedLimitValue::_internal_value() const {
  return *value_;
}
inline const ::holo::map::adasisv3::Speed& ExtendedSpeedLimitValue::value() const {
  const ::holo::map::adasisv3::Speed* p = value_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ExtendedSpeedLimitValue.value)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::Speed*>(
      &::holo::map::adasisv3::_Speed_default_instance_);
}
inline ::holo::map::adasisv3::Speed* ExtendedSpeedLimitValue::release_value() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.ExtendedSpeedLimitValue.value)
  clear_has_value();
  ::holo::map::adasisv3::Speed* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::Speed* ExtendedSpeedLimitValue::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::Speed>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ExtendedSpeedLimitValue.value)
  return value_;
}
inline void ExtendedSpeedLimitValue::set_allocated_value(::holo::map::adasisv3::Speed* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete value_;
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    set_has_value();
  } else {
    clear_has_value();
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.ExtendedSpeedLimitValue.value)
}

// required .holo.map.adasisv3.SpeedLimitSource source = 2;
inline bool ExtendedSpeedLimitValue::has_source() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtendedSpeedLimitValue::set_has_source() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtendedSpeedLimitValue::clear_has_source() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtendedSpeedLimitValue::clear_source() {
  source_ = 1;
  clear_has_source();
}
inline ::holo::map::adasisv3::SpeedLimitSource ExtendedSpeedLimitValue::source() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ExtendedSpeedLimitValue.source)
  return static_cast< ::holo::map::adasisv3::SpeedLimitSource >(source_);
}
inline void ExtendedSpeedLimitValue::set_source(::holo::map::adasisv3::SpeedLimitSource value) {
  assert(::holo::map::adasisv3::SpeedLimitSource_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ExtendedSpeedLimitValue.source)
}

// repeated .holo.map.adasisv3.Condition conditions = 3;
inline int ExtendedSpeedLimitValue::conditions_size() const {
  return conditions_.size();
}
inline void ExtendedSpeedLimitValue::clear_conditions() {
  conditions_.Clear();
}
inline ::holo::map::adasisv3::Condition* ExtendedSpeedLimitValue::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ExtendedSpeedLimitValue.conditions)
  return conditions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >*
ExtendedSpeedLimitValue::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.ExtendedSpeedLimitValue.conditions)
  return &conditions_;
}
inline const ::holo::map::adasisv3::Condition& ExtendedSpeedLimitValue::conditions(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ExtendedSpeedLimitValue.conditions)
  return conditions_.Get(index);
}
inline ::holo::map::adasisv3::Condition* ExtendedSpeedLimitValue::add_conditions() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.ExtendedSpeedLimitValue.conditions)
  return conditions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >&
ExtendedSpeedLimitValue::conditions() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.ExtendedSpeedLimitValue.conditions)
  return conditions_;
}

// -------------------------------------------------------------------

// TrafficSignValue

// required .holo.map.adasisv3.TrafficSignSignType type = 1;
inline bool TrafficSignValue::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TrafficSignValue::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TrafficSignValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TrafficSignValue::clear_type() {
  type_ = 6;
  clear_has_type();
}
inline ::holo::map::adasisv3::TrafficSignSignType TrafficSignValue::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.type)
  return static_cast< ::holo::map::adasisv3::TrafficSignSignType >(type_);
}
inline void TrafficSignValue::set_type(::holo::map::adasisv3::TrafficSignSignType value) {
  assert(::holo::map::adasisv3::TrafficSignSignType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficSignValue.type)
}

// required uint32 value = 2;
inline bool TrafficSignValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficSignValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficSignValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficSignValue::clear_value() {
  value_ = 0u;
  clear_has_value();
}
inline ::google::protobuf::uint32 TrafficSignValue::value() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.value)
  return value_;
}
inline void TrafficSignValue::set_value(::google::protobuf::uint32 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficSignValue.value)
}

// required uint32 location = 3;
inline bool TrafficSignValue::has_location() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TrafficSignValue::set_has_location() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TrafficSignValue::clear_has_location() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TrafficSignValue::clear_location() {
  location_ = 0u;
  clear_has_location();
}
inline ::google::protobuf::uint32 TrafficSignValue::location() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.location)
  return location_;
}
inline void TrafficSignValue::set_location(::google::protobuf::uint32 value) {
  set_has_location();
  location_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficSignValue.location)
}

// required int32 shift = 4;
inline bool TrafficSignValue::has_shift() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TrafficSignValue::set_has_shift() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TrafficSignValue::clear_has_shift() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TrafficSignValue::clear_shift() {
  shift_ = 0;
  clear_has_shift();
}
inline ::google::protobuf::int32 TrafficSignValue::shift() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.shift)
  return shift_;
}
inline void TrafficSignValue::set_shift(::google::protobuf::int32 value) {
  set_has_shift();
  shift_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficSignValue.shift)
}

// required int32 transverseDistance = 5;
inline bool TrafficSignValue::has_transversedistance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TrafficSignValue::set_has_transversedistance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TrafficSignValue::clear_has_transversedistance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TrafficSignValue::clear_transversedistance() {
  transversedistance_ = 0;
  clear_has_transversedistance();
}
inline ::google::protobuf::int32 TrafficSignValue::transversedistance() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.transverseDistance)
  return transversedistance_;
}
inline void TrafficSignValue::set_transversedistance(::google::protobuf::int32 value) {
  set_has_transversedistance();
  transversedistance_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficSignValue.transverseDistance)
}

// required uint32 distance = 6;
inline bool TrafficSignValue::has_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TrafficSignValue::set_has_distance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TrafficSignValue::clear_has_distance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TrafficSignValue::clear_distance() {
  distance_ = 0u;
  clear_has_distance();
}
inline ::google::protobuf::uint32 TrafficSignValue::distance() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.distance)
  return distance_;
}
inline void TrafficSignValue::set_distance(::google::protobuf::uint32 value) {
  set_has_distance();
  distance_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficSignValue.distance)
}

// required uint32 length = 7;
inline bool TrafficSignValue::has_length() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TrafficSignValue::set_has_length() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TrafficSignValue::clear_has_length() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TrafficSignValue::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 TrafficSignValue::length() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.length)
  return length_;
}
inline void TrafficSignValue::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficSignValue.length)
}

// required .holo.map.adasisv3.YesNoUnknown vms = 8;
inline bool TrafficSignValue::has_vms() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TrafficSignValue::set_has_vms() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TrafficSignValue::clear_has_vms() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TrafficSignValue::clear_vms() {
  vms_ = 0;
  clear_has_vms();
}
inline ::holo::map::adasisv3::YesNoUnknown TrafficSignValue::vms() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.vms)
  return static_cast< ::holo::map::adasisv3::YesNoUnknown >(vms_);
}
inline void TrafficSignValue::set_vms(::holo::map::adasisv3::YesNoUnknown value) {
  assert(::holo::map::adasisv3::YesNoUnknown_IsValid(value));
  set_has_vms();
  vms_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficSignValue.vms)
}

// required .holo.map.adasisv3.SignShape shape = 9;
inline bool TrafficSignValue::has_shape() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TrafficSignValue::set_has_shape() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TrafficSignValue::clear_has_shape() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TrafficSignValue::clear_shape() {
  shape_ = 0;
  clear_has_shape();
}
inline ::holo::map::adasisv3::SignShape TrafficSignValue::shape() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.shape)
  return static_cast< ::holo::map::adasisv3::SignShape >(shape_);
}
inline void TrafficSignValue::set_shape(::holo::map::adasisv3::SignShape value) {
  assert(::holo::map::adasisv3::SignShape_IsValid(value));
  set_has_shape();
  shape_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficSignValue.shape)
}

// required .holo.map.adasisv3.WGS84Point wgs84point = 10;
inline bool TrafficSignValue::has_wgs84point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficSignValue::set_has_wgs84point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficSignValue::clear_has_wgs84point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficSignValue::clear_wgs84point() {
  if (wgs84point_ != NULL) wgs84point_->Clear();
  clear_has_wgs84point();
}
inline const ::holo::map::adasisv3::WGS84Point& TrafficSignValue::_internal_wgs84point() const {
  return *wgs84point_;
}
inline const ::holo::map::adasisv3::WGS84Point& TrafficSignValue::wgs84point() const {
  const ::holo::map::adasisv3::WGS84Point* p = wgs84point_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.wgs84point)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::WGS84Point*>(
      &::holo::map::adasisv3::_WGS84Point_default_instance_);
}
inline ::holo::map::adasisv3::WGS84Point* TrafficSignValue::release_wgs84point() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.TrafficSignValue.wgs84point)
  clear_has_wgs84point();
  ::holo::map::adasisv3::WGS84Point* temp = wgs84point_;
  wgs84point_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::WGS84Point* TrafficSignValue::mutable_wgs84point() {
  set_has_wgs84point();
  if (wgs84point_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::WGS84Point>(GetArenaNoVirtual());
    wgs84point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.TrafficSignValue.wgs84point)
  return wgs84point_;
}
inline void TrafficSignValue::set_allocated_wgs84point(::holo::map::adasisv3::WGS84Point* wgs84point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wgs84point_;
  }
  if (wgs84point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wgs84point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wgs84point, submessage_arena);
    }
    set_has_wgs84point();
  } else {
    clear_has_wgs84point();
  }
  wgs84point_ = wgs84point;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.TrafficSignValue.wgs84point)
}

// repeated .holo.map.adasisv3.Condition panels = 11;
inline int TrafficSignValue::panels_size() const {
  return panels_.size();
}
inline void TrafficSignValue::clear_panels() {
  panels_.Clear();
}
inline ::holo::map::adasisv3::Condition* TrafficSignValue::mutable_panels(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.TrafficSignValue.panels)
  return panels_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >*
TrafficSignValue::mutable_panels() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.TrafficSignValue.panels)
  return &panels_;
}
inline const ::holo::map::adasisv3::Condition& TrafficSignValue::panels(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficSignValue.panels)
  return panels_.Get(index);
}
inline ::holo::map::adasisv3::Condition* TrafficSignValue::add_panels() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.TrafficSignValue.panels)
  return panels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >&
TrafficSignValue::panels() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.TrafficSignValue.panels)
  return panels_;
}

// -------------------------------------------------------------------

// ConditionalRestrictionProfileValue

// required bool allowed = 1;
inline bool ConditionalRestrictionProfileValue::has_allowed() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConditionalRestrictionProfileValue::set_has_allowed() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConditionalRestrictionProfileValue::clear_has_allowed() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConditionalRestrictionProfileValue::clear_allowed() {
  allowed_ = false;
  clear_has_allowed();
}
inline bool ConditionalRestrictionProfileValue::allowed() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionalRestrictionProfileValue.allowed)
  return allowed_;
}
inline void ConditionalRestrictionProfileValue::set_allowed(bool value) {
  set_has_allowed();
  allowed_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.ConditionalRestrictionProfileValue.allowed)
}

// repeated .holo.map.adasisv3.Condition conditions = 2;
inline int ConditionalRestrictionProfileValue::conditions_size() const {
  return conditions_.size();
}
inline void ConditionalRestrictionProfileValue::clear_conditions() {
  conditions_.Clear();
}
inline ::holo::map::adasisv3::Condition* ConditionalRestrictionProfileValue::mutable_conditions(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.ConditionalRestrictionProfileValue.conditions)
  return conditions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >*
ConditionalRestrictionProfileValue::mutable_conditions() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.ConditionalRestrictionProfileValue.conditions)
  return &conditions_;
}
inline const ::holo::map::adasisv3::Condition& ConditionalRestrictionProfileValue::conditions(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.ConditionalRestrictionProfileValue.conditions)
  return conditions_.Get(index);
}
inline ::holo::map::adasisv3::Condition* ConditionalRestrictionProfileValue::add_conditions() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.ConditionalRestrictionProfileValue.conditions)
  return conditions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::Condition >&
ConditionalRestrictionProfileValue::conditions() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.ConditionalRestrictionProfileValue.conditions)
  return conditions_;
}

// -------------------------------------------------------------------

// RoadSurfaceProfileValue

// required .holo.map.adasisv3.RoadSurfaceSignType signType = 1;
inline bool RoadSurfaceProfileValue::has_signtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoadSurfaceProfileValue::set_has_signtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoadSurfaceProfileValue::clear_has_signtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoadSurfaceProfileValue::clear_signtype() {
  signtype_ = 0;
  clear_has_signtype();
}
inline ::holo::map::adasisv3::RoadSurfaceSignType RoadSurfaceProfileValue::signtype() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RoadSurfaceProfileValue.signType)
  return static_cast< ::holo::map::adasisv3::RoadSurfaceSignType >(signtype_);
}
inline void RoadSurfaceProfileValue::set_signtype(::holo::map::adasisv3::RoadSurfaceSignType value) {
  assert(::holo::map::adasisv3::RoadSurfaceSignType_IsValid(value));
  set_has_signtype();
  signtype_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.RoadSurfaceProfileValue.signType)
}

// required .holo.map.adasisv3.WGS84Point wgs84point = 2;
inline bool RoadSurfaceProfileValue::has_wgs84point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoadSurfaceProfileValue::set_has_wgs84point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoadSurfaceProfileValue::clear_has_wgs84point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoadSurfaceProfileValue::clear_wgs84point() {
  if (wgs84point_ != NULL) wgs84point_->Clear();
  clear_has_wgs84point();
}
inline const ::holo::map::adasisv3::WGS84Point& RoadSurfaceProfileValue::_internal_wgs84point() const {
  return *wgs84point_;
}
inline const ::holo::map::adasisv3::WGS84Point& RoadSurfaceProfileValue::wgs84point() const {
  const ::holo::map::adasisv3::WGS84Point* p = wgs84point_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RoadSurfaceProfileValue.wgs84point)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::WGS84Point*>(
      &::holo::map::adasisv3::_WGS84Point_default_instance_);
}
inline ::holo::map::adasisv3::WGS84Point* RoadSurfaceProfileValue::release_wgs84point() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.RoadSurfaceProfileValue.wgs84point)
  clear_has_wgs84point();
  ::holo::map::adasisv3::WGS84Point* temp = wgs84point_;
  wgs84point_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::WGS84Point* RoadSurfaceProfileValue::mutable_wgs84point() {
  set_has_wgs84point();
  if (wgs84point_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::WGS84Point>(GetArenaNoVirtual());
    wgs84point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.RoadSurfaceProfileValue.wgs84point)
  return wgs84point_;
}
inline void RoadSurfaceProfileValue::set_allocated_wgs84point(::holo::map::adasisv3::WGS84Point* wgs84point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wgs84point_;
  }
  if (wgs84point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wgs84point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wgs84point, submessage_arena);
    }
    set_has_wgs84point();
  } else {
    clear_has_wgs84point();
  }
  wgs84point_ = wgs84point;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.RoadSurfaceProfileValue.wgs84point)
}

// repeated uint32 value = 3;
inline int RoadSurfaceProfileValue::value_size() const {
  return value_.size();
}
inline void RoadSurfaceProfileValue::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::uint32 RoadSurfaceProfileValue::value(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.RoadSurfaceProfileValue.value)
  return value_.Get(index);
}
inline void RoadSurfaceProfileValue::set_value(int index, ::google::protobuf::uint32 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.RoadSurfaceProfileValue.value)
}
inline void RoadSurfaceProfileValue::add_value(::google::protobuf::uint32 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.RoadSurfaceProfileValue.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
RoadSurfaceProfileValue::value() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.RoadSurfaceProfileValue.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
RoadSurfaceProfileValue::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.RoadSurfaceProfileValue.value)
  return &value_;
}

// -------------------------------------------------------------------

// PoleProfileValue

// required .holo.map.adasisv3.PoleSignType signType = 1;
inline bool PoleProfileValue::has_signtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PoleProfileValue::set_has_signtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PoleProfileValue::clear_has_signtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PoleProfileValue::clear_signtype() {
  signtype_ = 0;
  clear_has_signtype();
}
inline ::holo::map::adasisv3::PoleSignType PoleProfileValue::signtype() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PoleProfileValue.signType)
  return static_cast< ::holo::map::adasisv3::PoleSignType >(signtype_);
}
inline void PoleProfileValue::set_signtype(::holo::map::adasisv3::PoleSignType value) {
  assert(::holo::map::adasisv3::PoleSignType_IsValid(value));
  set_has_signtype();
  signtype_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.PoleProfileValue.signType)
}

// required int32 relativeHeight = 2;
inline bool PoleProfileValue::has_relativeheight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PoleProfileValue::set_has_relativeheight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PoleProfileValue::clear_has_relativeheight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PoleProfileValue::clear_relativeheight() {
  relativeheight_ = 0;
  clear_has_relativeheight();
}
inline ::google::protobuf::int32 PoleProfileValue::relativeheight() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PoleProfileValue.relativeHeight)
  return relativeheight_;
}
inline void PoleProfileValue::set_relativeheight(::google::protobuf::int32 value) {
  set_has_relativeheight();
  relativeheight_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.PoleProfileValue.relativeHeight)
}

// required .holo.map.adasisv3.WGS84Point wgs84point = 3;
inline bool PoleProfileValue::has_wgs84point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoleProfileValue::set_has_wgs84point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoleProfileValue::clear_has_wgs84point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoleProfileValue::clear_wgs84point() {
  if (wgs84point_ != NULL) wgs84point_->Clear();
  clear_has_wgs84point();
}
inline const ::holo::map::adasisv3::WGS84Point& PoleProfileValue::_internal_wgs84point() const {
  return *wgs84point_;
}
inline const ::holo::map::adasisv3::WGS84Point& PoleProfileValue::wgs84point() const {
  const ::holo::map::adasisv3::WGS84Point* p = wgs84point_;
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.PoleProfileValue.wgs84point)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::adasisv3::WGS84Point*>(
      &::holo::map::adasisv3::_WGS84Point_default_instance_);
}
inline ::holo::map::adasisv3::WGS84Point* PoleProfileValue::release_wgs84point() {
  // @@protoc_insertion_point(field_release:holo.map.adasisv3.PoleProfileValue.wgs84point)
  clear_has_wgs84point();
  ::holo::map::adasisv3::WGS84Point* temp = wgs84point_;
  wgs84point_ = NULL;
  return temp;
}
inline ::holo::map::adasisv3::WGS84Point* PoleProfileValue::mutable_wgs84point() {
  set_has_wgs84point();
  if (wgs84point_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::adasisv3::WGS84Point>(GetArenaNoVirtual());
    wgs84point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.PoleProfileValue.wgs84point)
  return wgs84point_;
}
inline void PoleProfileValue::set_allocated_wgs84point(::holo::map::adasisv3::WGS84Point* wgs84point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete wgs84point_;
  }
  if (wgs84point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      wgs84point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, wgs84point, submessage_arena);
    }
    set_has_wgs84point();
  } else {
    clear_has_wgs84point();
  }
  wgs84point_ = wgs84point;
  // @@protoc_insertion_point(field_set_allocated:holo.map.adasisv3.PoleProfileValue.wgs84point)
}

// -------------------------------------------------------------------

// TrafficFlowProfileValue

// required .holo.map.adasisv3.TrafficFlowStatus flowStatus = 1;
inline bool TrafficFlowProfileValue::has_flowstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficFlowProfileValue::set_has_flowstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficFlowProfileValue::clear_has_flowstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficFlowProfileValue::clear_flowstatus() {
  flowstatus_ = 0;
  clear_has_flowstatus();
}
inline ::holo::map::adasisv3::TrafficFlowStatus TrafficFlowProfileValue::flowstatus() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficFlowProfileValue.flowStatus)
  return static_cast< ::holo::map::adasisv3::TrafficFlowStatus >(flowstatus_);
}
inline void TrafficFlowProfileValue::set_flowstatus(::holo::map::adasisv3::TrafficFlowStatus value) {
  assert(::holo::map::adasisv3::TrafficFlowStatus_IsValid(value));
  set_has_flowstatus();
  flowstatus_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficFlowProfileValue.flowStatus)
}

// required uint32 reliability = 2;
inline bool TrafficFlowProfileValue::has_reliability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficFlowProfileValue::set_has_reliability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficFlowProfileValue::clear_has_reliability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficFlowProfileValue::clear_reliability() {
  reliability_ = 0u;
  clear_has_reliability();
}
inline ::google::protobuf::uint32 TrafficFlowProfileValue::reliability() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficFlowProfileValue.reliability)
  return reliability_;
}
inline void TrafficFlowProfileValue::set_reliability(::google::protobuf::uint32 value) {
  set_has_reliability();
  reliability_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficFlowProfileValue.reliability)
}

// -------------------------------------------------------------------

// TrafficEventProfileValue

// required .holo.map.adasisv3.TrafficEventType eventType = 1;
inline bool TrafficEventProfileValue::has_eventtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TrafficEventProfileValue::set_has_eventtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TrafficEventProfileValue::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TrafficEventProfileValue::clear_eventtype() {
  eventtype_ = 0;
  clear_has_eventtype();
}
inline ::holo::map::adasisv3::TrafficEventType TrafficEventProfileValue::eventtype() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficEventProfileValue.eventType)
  return static_cast< ::holo::map::adasisv3::TrafficEventType >(eventtype_);
}
inline void TrafficEventProfileValue::set_eventtype(::holo::map::adasisv3::TrafficEventType value) {
  assert(::holo::map::adasisv3::TrafficEventType_IsValid(value));
  set_has_eventtype();
  eventtype_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficEventProfileValue.eventType)
}

// required uint32 reliability = 2;
inline bool TrafficEventProfileValue::has_reliability() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TrafficEventProfileValue::set_has_reliability() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TrafficEventProfileValue::clear_has_reliability() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TrafficEventProfileValue::clear_reliability() {
  reliability_ = 0u;
  clear_has_reliability();
}
inline ::google::protobuf::uint32 TrafficEventProfileValue::reliability() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.TrafficEventProfileValue.reliability)
  return reliability_;
}
inline void TrafficEventProfileValue::set_reliability(::google::protobuf::uint32 value) {
  set_has_reliability();
  reliability_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.TrafficEventProfileValue.reliability)
}

// -------------------------------------------------------------------

// StaticODDProfileValue

// required uint32 type = 1;
inline bool StaticODDProfileValue::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StaticODDProfileValue::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StaticODDProfileValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StaticODDProfileValue::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 StaticODDProfileValue::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.StaticODDProfileValue.type)
  return type_;
}
inline void StaticODDProfileValue::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.StaticODDProfileValue.type)
}

// required uint32 action = 2;
inline bool StaticODDProfileValue::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StaticODDProfileValue::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StaticODDProfileValue::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StaticODDProfileValue::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 StaticODDProfileValue::action() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.StaticODDProfileValue.action)
  return action_;
}
inline void StaticODDProfileValue::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.StaticODDProfileValue.action)
}

// required uint64 reason = 3;
inline bool StaticODDProfileValue::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StaticODDProfileValue::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StaticODDProfileValue::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StaticODDProfileValue::clear_reason() {
  reason_ = GOOGLE_ULONGLONG(0);
  clear_has_reason();
}
inline ::google::protobuf::uint64 StaticODDProfileValue::reason() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.StaticODDProfileValue.reason)
  return reason_;
}
inline void StaticODDProfileValue::set_reason(::google::protobuf::uint64 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.StaticODDProfileValue.reason)
}

// -------------------------------------------------------------------

// StaticNotODDProfileValue

// required uint32 type = 1;
inline bool StaticNotODDProfileValue::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StaticNotODDProfileValue::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StaticNotODDProfileValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StaticNotODDProfileValue::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 StaticNotODDProfileValue::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.StaticNotODDProfileValue.type)
  return type_;
}
inline void StaticNotODDProfileValue::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.StaticNotODDProfileValue.type)
}

// required uint32 action = 2;
inline bool StaticNotODDProfileValue::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StaticNotODDProfileValue::set_has_action() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StaticNotODDProfileValue::clear_has_action() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StaticNotODDProfileValue::clear_action() {
  action_ = 0u;
  clear_has_action();
}
inline ::google::protobuf::uint32 StaticNotODDProfileValue::action() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.StaticNotODDProfileValue.action)
  return action_;
}
inline void StaticNotODDProfileValue::set_action(::google::protobuf::uint32 value) {
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.StaticNotODDProfileValue.action)
}

// required uint64 reason = 3;
inline bool StaticNotODDProfileValue::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StaticNotODDProfileValue::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StaticNotODDProfileValue::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StaticNotODDProfileValue::clear_reason() {
  reason_ = GOOGLE_ULONGLONG(0);
  clear_has_reason();
}
inline ::google::protobuf::uint64 StaticNotODDProfileValue::reason() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.StaticNotODDProfileValue.reason)
  return reason_;
}
inline void StaticNotODDProfileValue::set_reason(::google::protobuf::uint64 value) {
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.StaticNotODDProfileValue.reason)
}

// -------------------------------------------------------------------

// DecelerationZoneProfileValue

// required .holo.map.adasisv3.DecelerationZoneType type = 1;
inline bool DecelerationZoneProfileValue::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecelerationZoneProfileValue::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DecelerationZoneProfileValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DecelerationZoneProfileValue::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::holo::map::adasisv3::DecelerationZoneType DecelerationZoneProfileValue::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.DecelerationZoneProfileValue.type)
  return static_cast< ::holo::map::adasisv3::DecelerationZoneType >(type_);
}
inline void DecelerationZoneProfileValue::set_type(::holo::map::adasisv3::DecelerationZoneType value) {
  assert(::holo::map::adasisv3::DecelerationZoneType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.DecelerationZoneProfileValue.type)
}

// repeated .holo.map.adasisv3.WGS84Point boundingBox = 2;
inline int DecelerationZoneProfileValue::boundingbox_size() const {
  return boundingbox_.size();
}
inline void DecelerationZoneProfileValue::clear_boundingbox() {
  boundingbox_.Clear();
}
inline ::holo::map::adasisv3::WGS84Point* DecelerationZoneProfileValue::mutable_boundingbox(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.DecelerationZoneProfileValue.boundingBox)
  return boundingbox_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >*
DecelerationZoneProfileValue::mutable_boundingbox() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.DecelerationZoneProfileValue.boundingBox)
  return &boundingbox_;
}
inline const ::holo::map::adasisv3::WGS84Point& DecelerationZoneProfileValue::boundingbox(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.DecelerationZoneProfileValue.boundingBox)
  return boundingbox_.Get(index);
}
inline ::holo::map::adasisv3::WGS84Point* DecelerationZoneProfileValue::add_boundingbox() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.DecelerationZoneProfileValue.boundingBox)
  return boundingbox_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >&
DecelerationZoneProfileValue::boundingbox() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.DecelerationZoneProfileValue.boundingBox)
  return boundingbox_;
}

// -------------------------------------------------------------------

// OverHeadProfileValue

// repeated .holo.map.adasisv3.OverHeadValue OverHeadValue_value = 1;
inline int OverHeadProfileValue::overheadvalue_value_size() const {
  return overheadvalue_value_.size();
}
inline void OverHeadProfileValue::clear_overheadvalue_value() {
  overheadvalue_value_.Clear();
}
inline ::holo::map::adasisv3::OverHeadValue* OverHeadProfileValue::mutable_overheadvalue_value(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.OverHeadProfileValue.OverHeadValue_value)
  return overheadvalue_value_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OverHeadValue >*
OverHeadProfileValue::mutable_overheadvalue_value() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.OverHeadProfileValue.OverHeadValue_value)
  return &overheadvalue_value_;
}
inline const ::holo::map::adasisv3::OverHeadValue& OverHeadProfileValue::overheadvalue_value(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.OverHeadProfileValue.OverHeadValue_value)
  return overheadvalue_value_.Get(index);
}
inline ::holo::map::adasisv3::OverHeadValue* OverHeadProfileValue::add_overheadvalue_value() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.OverHeadProfileValue.OverHeadValue_value)
  return overheadvalue_value_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::OverHeadValue >&
OverHeadProfileValue::overheadvalue_value() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.OverHeadProfileValue.OverHeadValue_value)
  return overheadvalue_value_;
}

// -------------------------------------------------------------------

// OverHeadValue

// required .holo.map.adasisv3.OverHeadType type = 1;
inline bool OverHeadValue::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OverHeadValue::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OverHeadValue::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OverHeadValue::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::holo::map::adasisv3::OverHeadType OverHeadValue::type() const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.OverHeadValue.type)
  return static_cast< ::holo::map::adasisv3::OverHeadType >(type_);
}
inline void OverHeadValue::set_type(::holo::map::adasisv3::OverHeadType value) {
  assert(::holo::map::adasisv3::OverHeadType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.adasisv3.OverHeadValue.type)
}

// repeated .holo.map.adasisv3.WGS84Point wgs84point = 2;
inline int OverHeadValue::wgs84point_size() const {
  return wgs84point_.size();
}
inline void OverHeadValue::clear_wgs84point() {
  wgs84point_.Clear();
}
inline ::holo::map::adasisv3::WGS84Point* OverHeadValue::mutable_wgs84point(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.adasisv3.OverHeadValue.wgs84point)
  return wgs84point_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >*
OverHeadValue::mutable_wgs84point() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.adasisv3.OverHeadValue.wgs84point)
  return &wgs84point_;
}
inline const ::holo::map::adasisv3::WGS84Point& OverHeadValue::wgs84point(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.adasisv3.OverHeadValue.wgs84point)
  return wgs84point_.Get(index);
}
inline ::holo::map::adasisv3::WGS84Point* OverHeadValue::add_wgs84point() {
  // @@protoc_insertion_point(field_add:holo.map.adasisv3.OverHeadValue.wgs84point)
  return wgs84point_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::adasisv3::WGS84Point >&
OverHeadValue::wgs84point() const {
  // @@protoc_insertion_point(field_list:holo.map.adasisv3.OverHeadValue.wgs84point)
  return wgs84point_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace adasisv3
}  // namespace map
}  // namespace holo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::holo::map::adasisv3::AdasisV3ProtobufProtocolMajorVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::AdasisV3ProtobufProtocolMajorVersion>() {
  return ::holo::map::adasisv3::AdasisV3ProtobufProtocolMajorVersion_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::AdasisV3ProtobufProtocolMinorVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::AdasisV3ProtobufProtocolMinorVersion>() {
  return ::holo::map::adasisv3::AdasisV3ProtobufProtocolMinorVersion_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::Availability> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::Availability>() {
  return ::holo::map::adasisv3::Availability_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::UnitOfSystem> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::UnitOfSystem>() {
  return ::holo::map::adasisv3::UnitOfSystem_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::ChangeMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::ChangeMode>() {
  return ::holo::map::adasisv3::ChangeMode_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::ConditionType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::ConditionType>() {
  return ::holo::map::adasisv3::ConditionType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::CurveType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::CurveType>() {
  return ::holo::map::adasisv3::CurveType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::DrivingSide> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::DrivingSide>() {
  return ::holo::map::adasisv3::DrivingSide_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::EffectiveSpeedLimitType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::EffectiveSpeedLimitType>() {
  return ::holo::map::adasisv3::EffectiveSpeedLimitType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::FormOfWay> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::FormOfWay>() {
  return ::holo::map::adasisv3::FormOfWay_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::FuzzyTime> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::FuzzyTime>() {
  return ::holo::map::adasisv3::FuzzyTime_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::GuidanceMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::GuidanceMode>() {
  return ::holo::map::adasisv3::GuidanceMode_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::LaneArrowMarking> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::LaneArrowMarking>() {
  return ::holo::map::adasisv3::LaneArrowMarking_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::LaneTransition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::LaneTransition>() {
  return ::holo::map::adasisv3::LaneTransition_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::LateralPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::LateralPosition>() {
  return ::holo::map::adasisv3::LateralPosition_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::LineMarking> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::LineMarking>() {
  return ::holo::map::adasisv3::LineMarking_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::LineMarkingColour> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::LineMarkingColour>() {
  return ::holo::map::adasisv3::LineMarkingColour_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::LinearObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::LinearObjectType>() {
  return ::holo::map::adasisv3::LinearObjectType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::Load> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::Load>() {
  return ::holo::map::adasisv3::Load_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::LocationObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::LocationObjectType>() {
  return ::holo::map::adasisv3::LocationObjectType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::MapProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::MapProvider>() {
  return ::holo::map::adasisv3::MapProvider_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::MapStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::MapStatus>() {
  return ::holo::map::adasisv3::MapStatus_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::MessageType>() {
  return ::holo::map::adasisv3::MessageType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::ProfileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::ProfileType>() {
  return ::holo::map::adasisv3::ProfileType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::Quality> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::Quality>() {
  return ::holo::map::adasisv3::Quality_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::RelativeDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::RelativeDirection>() {
  return ::holo::map::adasisv3::RelativeDirection_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::RightOfWay> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::RightOfWay>() {
  return ::holo::map::adasisv3::RightOfWay_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::RoadAccessFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::RoadAccessFlags>() {
  return ::holo::map::adasisv3::RoadAccessFlags_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::RoadCondition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::RoadCondition>() {
  return ::holo::map::adasisv3::RoadCondition_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::SpecialSituationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::SpecialSituationType>() {
  return ::holo::map::adasisv3::SpecialSituationType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::SpeedLimitSource> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::SpeedLimitSource>() {
  return ::holo::map::adasisv3::SpeedLimitSource_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::SurfaceCondition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::SurfaceCondition>() {
  return ::holo::map::adasisv3::SurfaceCondition_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::TrafficLightLongitudinalPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::TrafficLightLongitudinalPosition>() {
  return ::holo::map::adasisv3::TrafficLightLongitudinalPosition_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::TrafficLightState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::TrafficLightState>() {
  return ::holo::map::adasisv3::TrafficLightState_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::UnitOfSpeed> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::UnitOfSpeed>() {
  return ::holo::map::adasisv3::UnitOfSpeed_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::Weather> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::Weather>() {
  return ::holo::map::adasisv3::Weather_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::WeatherRedefine> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::WeatherRedefine>() {
  return ::holo::map::adasisv3::WeatherRedefine_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::YesNoUnknown> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::YesNoUnknown>() {
  return ::holo::map::adasisv3::YesNoUnknown_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::RoadStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::RoadStatus>() {
  return ::holo::map::adasisv3::RoadStatus_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::TrafficSignSignType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::TrafficSignSignType>() {
  return ::holo::map::adasisv3::TrafficSignSignType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::OverHeadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::OverHeadType>() {
  return ::holo::map::adasisv3::OverHeadType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::RoadSurfaceSignType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::RoadSurfaceSignType>() {
  return ::holo::map::adasisv3::RoadSurfaceSignType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::PoleSignType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::PoleSignType>() {
  return ::holo::map::adasisv3::PoleSignType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::SignShape> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::SignShape>() {
  return ::holo::map::adasisv3::SignShape_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::TrafficFlowStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::TrafficFlowStatus>() {
  return ::holo::map::adasisv3::TrafficFlowStatus_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::TrafficEventType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::TrafficEventType>() {
  return ::holo::map::adasisv3::TrafficEventType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::DecelerationZoneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::DecelerationZoneType>() {
  return ::holo::map::adasisv3::DecelerationZoneType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::LinearObjectConfidence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::LinearObjectConfidence>() {
  return ::holo::map::adasisv3::LinearObjectConfidence_descriptor();
}
template <> struct is_proto_enum< ::holo::map::adasisv3::ReasonType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::adasisv3::ReasonType>() {
  return ::holo::map::adasisv3::ReasonType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fadasis_2fholo_5fadasis_5fv3_5f1_5f0_2eproto
