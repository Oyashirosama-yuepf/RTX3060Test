// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: holo/map/proto/base/lane.proto

#ifndef PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fbase_2flane_2eproto
#define PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fbase_2flane_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "holo/map/proto/common/coordinate.pb.h"
#include "holo/map/proto/common/geo_box.pb.h"
#include "holo/map/proto/common/geo_line.pb.h"
#include "holo/map/proto/common/geo_point.pb.h"
#include "holo/map/proto/common/id_interval_float64.pb.h"
#include "holo/map/proto/common/condition.pb.h"
#include "holo/map/proto/base/lane_width_info.pb.h"
#include "holo/map/proto/base/speed_limit_info.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_holo_2fmap_2fproto_2fbase_2flane_2eproto 

namespace protobuf_holo_2fmap_2fproto_2fbase_2flane_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[3];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_holo_2fmap_2fproto_2fbase_2flane_2eproto
namespace holo {
namespace map {
namespace proto {
namespace base {
class Lane;
class LaneDefaultTypeInternal;
extern LaneDefaultTypeInternal _Lane_default_instance_;
class Lane_ExtraGeometryPointsEntry_DoNotUse;
class Lane_ExtraGeometryPointsEntry_DoNotUseDefaultTypeInternal;
extern Lane_ExtraGeometryPointsEntry_DoNotUseDefaultTypeInternal _Lane_ExtraGeometryPointsEntry_DoNotUse_default_instance_;
class Lane_ExtraRegionEntry_DoNotUse;
class Lane_ExtraRegionEntry_DoNotUseDefaultTypeInternal;
extern Lane_ExtraRegionEntry_DoNotUseDefaultTypeInternal _Lane_ExtraRegionEntry_DoNotUse_default_instance_;
}  // namespace base
}  // namespace proto
}  // namespace map
}  // namespace holo
namespace google {
namespace protobuf {
template<> ::holo::map::proto::base::Lane* Arena::CreateMaybeMessage<::holo::map::proto::base::Lane>(Arena*);
template<> ::holo::map::proto::base::Lane_ExtraGeometryPointsEntry_DoNotUse* Arena::CreateMaybeMessage<::holo::map::proto::base::Lane_ExtraGeometryPointsEntry_DoNotUse>(Arena*);
template<> ::holo::map::proto::base::Lane_ExtraRegionEntry_DoNotUse* Arena::CreateMaybeMessage<::holo::map::proto::base::Lane_ExtraRegionEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace holo {
namespace map {
namespace proto {
namespace base {

enum Lane_LaneDir {
  Lane_LaneDir_LANE_DIR_UNDEFINED = 0,
  Lane_LaneDir_LANE_DIR_POSITIVE_DIRECTION = 1,
  Lane_LaneDir_LANE_DIR_NEGATIVE_DIRECTION = 2,
  Lane_LaneDir_LANE_DIR_BI_DIRECTION = 3
};
bool Lane_LaneDir_IsValid(int value);
const Lane_LaneDir Lane_LaneDir_LaneDir_MIN = Lane_LaneDir_LANE_DIR_UNDEFINED;
const Lane_LaneDir Lane_LaneDir_LaneDir_MAX = Lane_LaneDir_LANE_DIR_BI_DIRECTION;
const int Lane_LaneDir_LaneDir_ARRAYSIZE = Lane_LaneDir_LaneDir_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_LaneDir_descriptor();
inline const ::std::string& Lane_LaneDir_Name(Lane_LaneDir value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_LaneDir_descriptor(), value);
}
inline bool Lane_LaneDir_Parse(
    const ::std::string& name, Lane_LaneDir* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_LaneDir>(
    Lane_LaneDir_descriptor(), name, value);
}
enum Lane_LaneType {
  Lane_LaneType_LANE_TYPE_UNDEFINED = 0,
  Lane_LaneType_LANE_TYPE_REGULAR = 1,
  Lane_LaneType_LANE_TYPE_EXPRESS = 2,
  Lane_LaneType_LANE_TYPE_CARPOOL = 3,
  Lane_LaneType_LANE_TYPE_TRAM = 5,
  Lane_LaneType_LANE_TYPE_TRUCK_PARKING = 6,
  Lane_LaneType_LANE_TYPE_SLOW = 7,
  Lane_LaneType_LANE_TYPE_HARD_SHOULDER = 9,
  Lane_LaneType_LANE_TYPE_REGULATED_ACCESS = 11,
  Lane_LaneType_LANE_TYPE_ACCELERATE = 12,
  Lane_LaneType_LANE_TYPE_DECELERATE = 13,
  Lane_LaneType_LANE_TYPE_DEDICATED_BUS = 19,
  Lane_LaneType_LANE_TYPE_BICYCLE = 20,
  Lane_LaneType_LANE_TYPE_PARKING_LANE = 26,
  Lane_LaneType_LANE_TYPE_EMERGENCY = 27,
  Lane_LaneType_LANE_TYPE_EMERGENCY_PARKING_STRIP = 28,
  Lane_LaneType_LANE_TYPE_ENTRY = 29,
  Lane_LaneType_LANE_TYPE_EXIT = 30,
  Lane_LaneType_LANE_TYPE_RAMP_ALL = 31,
  Lane_LaneType_LANE_TYPE_RAMP_ABOARD = 32,
  Lane_LaneType_LANE_TYPE_RAMP_ASHORE = 33,
  Lane_LaneType_LANE_TYPE_RAMP_JCT = 34,
  Lane_LaneType_LANE_TYPE_TOLL_BOOTH = 41,
  Lane_LaneType_LANE_TYPE_TOLL_GATE = 42,
  Lane_LaneType_LANE_TYPE_TOLL_GATE_ETC = 43,
  Lane_LaneType_LANE_TYPE_CLIMBING = 44,
  Lane_LaneType_LANE_TYPE_ESCAPE = 45,
  Lane_LaneType_LANE_TYPE_NON_DRIVE_WAY = 46,
  Lane_LaneType_LANE_TYPE_DEDICATED_CUSTOM = 47,
  Lane_LaneType_LANE_TYPE_REVERSIBLE = 48,
  Lane_LaneType_LANE_TYPE_VARIABLE = 49,
  Lane_LaneType_LANE_TYPE_DRIVABLE_SHOULDER = 50,
  Lane_LaneType_LANE_TYPE_DIS_DRIVABLE_SHOULDER = 51,
  Lane_LaneType_LANE_TYPE_REGULAR_DIVERSION = 52,
  Lane_LaneType_LANE_TYPE_RESERVED_1 = 250,
  Lane_LaneType_LANE_TYPE_RESERVED_2 = 251,
  Lane_LaneType_LANE_TYPE_RESERVED_3 = 252,
  Lane_LaneType_LANE_TYPE_RESERVED_4 = 253,
  Lane_LaneType_LANE_TYPE_RESERVED_5 = 254,
  Lane_LaneType_LANE_TYPE_OTHER = 255
};
bool Lane_LaneType_IsValid(int value);
const Lane_LaneType Lane_LaneType_LaneType_MIN = Lane_LaneType_LANE_TYPE_UNDEFINED;
const Lane_LaneType Lane_LaneType_LaneType_MAX = Lane_LaneType_LANE_TYPE_OTHER;
const int Lane_LaneType_LaneType_ARRAYSIZE = Lane_LaneType_LaneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_LaneType_descriptor();
inline const ::std::string& Lane_LaneType_Name(Lane_LaneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_LaneType_descriptor(), value);
}
inline bool Lane_LaneType_Parse(
    const ::std::string& name, Lane_LaneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_LaneType>(
    Lane_LaneType_descriptor(), name, value);
}
enum Lane_TurnType {
  Lane_TurnType_TURN_TYPE_UNDEFINED = 0,
  Lane_TurnType_TURN_TYPE_STRAIGHT = 1,
  Lane_TurnType_TURN_TYPE_TURN_LEFT = 2,
  Lane_TurnType_TURN_TYPE_TURN_RIGHT = 3,
  Lane_TurnType_TURN_TYPE_TURN_LEFT_AROUND = 4,
  Lane_TurnType_TURN_TYPE_TURN_RIGHT_AROUND = 5,
  Lane_TurnType_TURN_TYPE_TURN_LEFT_AREA = 6,
  Lane_TurnType_TURN_TYPE_TURN_RIGHT_AREA = 7,
  Lane_TurnType_TURN_TYPE_RESERVE_1 = 250,
  Lane_TurnType_TURN_TYPE_RESERVE_2 = 251,
  Lane_TurnType_TURN_TYPE_RESERVE_3 = 252,
  Lane_TurnType_TURN_TYPE_RESERVE_4 = 253,
  Lane_TurnType_TURN_TYPE_RESERVE_5 = 254,
  Lane_TurnType_TURN_TYPE_OTHERS = 255
};
bool Lane_TurnType_IsValid(int value);
const Lane_TurnType Lane_TurnType_TurnType_MIN = Lane_TurnType_TURN_TYPE_UNDEFINED;
const Lane_TurnType Lane_TurnType_TurnType_MAX = Lane_TurnType_TURN_TYPE_OTHERS;
const int Lane_TurnType_TurnType_ARRAYSIZE = Lane_TurnType_TurnType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_TurnType_descriptor();
inline const ::std::string& Lane_TurnType_Name(Lane_TurnType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_TurnType_descriptor(), value);
}
inline bool Lane_TurnType_Parse(
    const ::std::string& name, Lane_TurnType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_TurnType>(
    Lane_TurnType_descriptor(), name, value);
}
enum Lane_TranType {
  Lane_TranType_TRAN_TYPE_UNDEFINED = 0,
  Lane_TranType_TRAN_TYPE_LANE_OPENING = 1,
  Lane_TranType_TRAN_TYPE_LANE_ENDING = 2,
  Lane_TranType_TRAN_TYPE_LOGICAL_TRANSITION_LANE = 3,
  Lane_TranType_TRAN_TYPE_EXIT_AND_ENTRY_LANE = 4,
  Lane_TranType_TRAN_TYPE_EXIT_OR_ENTRY_LANE = 5,
  Lane_TranType_TRAN_TYPE_TRAIN_TRACK = 6,
  Lane_TranType_TRAN_TYPE_PUBLIC_TRANSPORT_STOP = 7,
  Lane_TranType_TRAN_TYPE_WAITING_AREA = 8,
  Lane_TranType_TRAN_TYPE_ENTRY_LANE = 9,
  Lane_TranType_TRAN_TYPE_EXIT_LANE = 10,
  Lane_TranType_TRAN_TYPE_NORMAL_LANE = 11,
  Lane_TranType_TRAN_TYPE_LANE_OPENING_AND_ENDING = 12,
  Lane_TranType_TRAN_TYPE_LANE_ENDING_AND_OPENING = 13,
  Lane_TranType_TRAN_TYPE_WIDE_STEP = 14,
  Lane_TranType_TRAN_TYPE_NARROW_STEP = 15,
  Lane_TranType_TRAN_TYPE_SPLITING = 16,
  Lane_TranType_TRAN_TYPE_MERGING = 17,
  Lane_TranType_TRAN_TYPE_NEWBORN = 18,
  Lane_TranType_TRAN_TYPE_BREAKUP = 19,
  Lane_TranType_TRAN_TYPE_NOT_APPLICABLE = 200,
  Lane_TranType_TRAN_TYPE_RESERVED_1 = 250,
  Lane_TranType_TRAN_TYPE_RESERVED_2 = 251,
  Lane_TranType_TRAN_TYPE_RESERVED_3 = 252,
  Lane_TranType_TRAN_TYPE_RESERVED_4 = 253,
  Lane_TranType_TRAN_TYPE_RESERVED_5 = 254,
  Lane_TranType_TRAN_TYPE_OTHERS = 255
};
bool Lane_TranType_IsValid(int value);
const Lane_TranType Lane_TranType_TranType_MIN = Lane_TranType_TRAN_TYPE_UNDEFINED;
const Lane_TranType Lane_TranType_TranType_MAX = Lane_TranType_TRAN_TYPE_OTHERS;
const int Lane_TranType_TranType_ARRAYSIZE = Lane_TranType_TranType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Lane_TranType_descriptor();
inline const ::std::string& Lane_TranType_Name(Lane_TranType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Lane_TranType_descriptor(), value);
}
inline bool Lane_TranType_Parse(
    const ::std::string& name, Lane_TranType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Lane_TranType>(
    Lane_TranType_descriptor(), name, value);
}
// ===================================================================

class Lane_ExtraRegionEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Lane_ExtraRegionEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Lane_ExtraRegionEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Lane_ExtraRegionEntry_DoNotUse();
  Lane_ExtraRegionEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Lane_ExtraRegionEntry_DoNotUse& other);
  static const Lane_ExtraRegionEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Lane_ExtraRegionEntry_DoNotUse*>(&_Lane_ExtraRegionEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Lane_ExtraGeometryPointsEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<Lane_ExtraGeometryPointsEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoLine,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<Lane_ExtraGeometryPointsEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoLine,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  Lane_ExtraGeometryPointsEntry_DoNotUse();
  Lane_ExtraGeometryPointsEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const Lane_ExtraGeometryPointsEntry_DoNotUse& other);
  static const Lane_ExtraGeometryPointsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Lane_ExtraGeometryPointsEntry_DoNotUse*>(&_Lane_ExtraGeometryPointsEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class Lane : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.proto.base.Lane) */ {
 public:
  Lane();
  virtual ~Lane();

  Lane(const Lane& from);

  inline Lane& operator=(const Lane& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Lane(Lane&& from) noexcept
    : Lane() {
    *this = ::std::move(from);
  }

  inline Lane& operator=(Lane&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lane& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Lane* internal_default_instance() {
    return reinterpret_cast<const Lane*>(
               &_Lane_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Lane* other);
  friend void swap(Lane& a, Lane& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Lane* New() const final {
    return CreateMaybeMessage<Lane>(NULL);
  }

  Lane* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Lane>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Lane& from);
  void MergeFrom(const Lane& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Lane* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef Lane_LaneDir LaneDir;
  static const LaneDir LANE_DIR_UNDEFINED =
    Lane_LaneDir_LANE_DIR_UNDEFINED;
  static const LaneDir LANE_DIR_POSITIVE_DIRECTION =
    Lane_LaneDir_LANE_DIR_POSITIVE_DIRECTION;
  static const LaneDir LANE_DIR_NEGATIVE_DIRECTION =
    Lane_LaneDir_LANE_DIR_NEGATIVE_DIRECTION;
  static const LaneDir LANE_DIR_BI_DIRECTION =
    Lane_LaneDir_LANE_DIR_BI_DIRECTION;
  static inline bool LaneDir_IsValid(int value) {
    return Lane_LaneDir_IsValid(value);
  }
  static const LaneDir LaneDir_MIN =
    Lane_LaneDir_LaneDir_MIN;
  static const LaneDir LaneDir_MAX =
    Lane_LaneDir_LaneDir_MAX;
  static const int LaneDir_ARRAYSIZE =
    Lane_LaneDir_LaneDir_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneDir_descriptor() {
    return Lane_LaneDir_descriptor();
  }
  static inline const ::std::string& LaneDir_Name(LaneDir value) {
    return Lane_LaneDir_Name(value);
  }
  static inline bool LaneDir_Parse(const ::std::string& name,
      LaneDir* value) {
    return Lane_LaneDir_Parse(name, value);
  }

  typedef Lane_LaneType LaneType;
  static const LaneType LANE_TYPE_UNDEFINED =
    Lane_LaneType_LANE_TYPE_UNDEFINED;
  static const LaneType LANE_TYPE_REGULAR =
    Lane_LaneType_LANE_TYPE_REGULAR;
  static const LaneType LANE_TYPE_EXPRESS =
    Lane_LaneType_LANE_TYPE_EXPRESS;
  static const LaneType LANE_TYPE_CARPOOL =
    Lane_LaneType_LANE_TYPE_CARPOOL;
  static const LaneType LANE_TYPE_TRAM =
    Lane_LaneType_LANE_TYPE_TRAM;
  static const LaneType LANE_TYPE_TRUCK_PARKING =
    Lane_LaneType_LANE_TYPE_TRUCK_PARKING;
  static const LaneType LANE_TYPE_SLOW =
    Lane_LaneType_LANE_TYPE_SLOW;
  static const LaneType LANE_TYPE_HARD_SHOULDER =
    Lane_LaneType_LANE_TYPE_HARD_SHOULDER;
  static const LaneType LANE_TYPE_REGULATED_ACCESS =
    Lane_LaneType_LANE_TYPE_REGULATED_ACCESS;
  static const LaneType LANE_TYPE_ACCELERATE =
    Lane_LaneType_LANE_TYPE_ACCELERATE;
  static const LaneType LANE_TYPE_DECELERATE =
    Lane_LaneType_LANE_TYPE_DECELERATE;
  static const LaneType LANE_TYPE_DEDICATED_BUS =
    Lane_LaneType_LANE_TYPE_DEDICATED_BUS;
  static const LaneType LANE_TYPE_BICYCLE =
    Lane_LaneType_LANE_TYPE_BICYCLE;
  static const LaneType LANE_TYPE_PARKING_LANE =
    Lane_LaneType_LANE_TYPE_PARKING_LANE;
  static const LaneType LANE_TYPE_EMERGENCY =
    Lane_LaneType_LANE_TYPE_EMERGENCY;
  static const LaneType LANE_TYPE_EMERGENCY_PARKING_STRIP =
    Lane_LaneType_LANE_TYPE_EMERGENCY_PARKING_STRIP;
  static const LaneType LANE_TYPE_ENTRY =
    Lane_LaneType_LANE_TYPE_ENTRY;
  static const LaneType LANE_TYPE_EXIT =
    Lane_LaneType_LANE_TYPE_EXIT;
  static const LaneType LANE_TYPE_RAMP_ALL =
    Lane_LaneType_LANE_TYPE_RAMP_ALL;
  static const LaneType LANE_TYPE_RAMP_ABOARD =
    Lane_LaneType_LANE_TYPE_RAMP_ABOARD;
  static const LaneType LANE_TYPE_RAMP_ASHORE =
    Lane_LaneType_LANE_TYPE_RAMP_ASHORE;
  static const LaneType LANE_TYPE_RAMP_JCT =
    Lane_LaneType_LANE_TYPE_RAMP_JCT;
  static const LaneType LANE_TYPE_TOLL_BOOTH =
    Lane_LaneType_LANE_TYPE_TOLL_BOOTH;
  static const LaneType LANE_TYPE_TOLL_GATE =
    Lane_LaneType_LANE_TYPE_TOLL_GATE;
  static const LaneType LANE_TYPE_TOLL_GATE_ETC =
    Lane_LaneType_LANE_TYPE_TOLL_GATE_ETC;
  static const LaneType LANE_TYPE_CLIMBING =
    Lane_LaneType_LANE_TYPE_CLIMBING;
  static const LaneType LANE_TYPE_ESCAPE =
    Lane_LaneType_LANE_TYPE_ESCAPE;
  static const LaneType LANE_TYPE_NON_DRIVE_WAY =
    Lane_LaneType_LANE_TYPE_NON_DRIVE_WAY;
  static const LaneType LANE_TYPE_DEDICATED_CUSTOM =
    Lane_LaneType_LANE_TYPE_DEDICATED_CUSTOM;
  static const LaneType LANE_TYPE_REVERSIBLE =
    Lane_LaneType_LANE_TYPE_REVERSIBLE;
  static const LaneType LANE_TYPE_VARIABLE =
    Lane_LaneType_LANE_TYPE_VARIABLE;
  static const LaneType LANE_TYPE_DRIVABLE_SHOULDER =
    Lane_LaneType_LANE_TYPE_DRIVABLE_SHOULDER;
  static const LaneType LANE_TYPE_DIS_DRIVABLE_SHOULDER =
    Lane_LaneType_LANE_TYPE_DIS_DRIVABLE_SHOULDER;
  static const LaneType LANE_TYPE_REGULAR_DIVERSION =
    Lane_LaneType_LANE_TYPE_REGULAR_DIVERSION;
  static const LaneType LANE_TYPE_RESERVED_1 =
    Lane_LaneType_LANE_TYPE_RESERVED_1;
  static const LaneType LANE_TYPE_RESERVED_2 =
    Lane_LaneType_LANE_TYPE_RESERVED_2;
  static const LaneType LANE_TYPE_RESERVED_3 =
    Lane_LaneType_LANE_TYPE_RESERVED_3;
  static const LaneType LANE_TYPE_RESERVED_4 =
    Lane_LaneType_LANE_TYPE_RESERVED_4;
  static const LaneType LANE_TYPE_RESERVED_5 =
    Lane_LaneType_LANE_TYPE_RESERVED_5;
  static const LaneType LANE_TYPE_OTHER =
    Lane_LaneType_LANE_TYPE_OTHER;
  static inline bool LaneType_IsValid(int value) {
    return Lane_LaneType_IsValid(value);
  }
  static const LaneType LaneType_MIN =
    Lane_LaneType_LaneType_MIN;
  static const LaneType LaneType_MAX =
    Lane_LaneType_LaneType_MAX;
  static const int LaneType_ARRAYSIZE =
    Lane_LaneType_LaneType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LaneType_descriptor() {
    return Lane_LaneType_descriptor();
  }
  static inline const ::std::string& LaneType_Name(LaneType value) {
    return Lane_LaneType_Name(value);
  }
  static inline bool LaneType_Parse(const ::std::string& name,
      LaneType* value) {
    return Lane_LaneType_Parse(name, value);
  }

  typedef Lane_TurnType TurnType;
  static const TurnType TURN_TYPE_UNDEFINED =
    Lane_TurnType_TURN_TYPE_UNDEFINED;
  static const TurnType TURN_TYPE_STRAIGHT =
    Lane_TurnType_TURN_TYPE_STRAIGHT;
  static const TurnType TURN_TYPE_TURN_LEFT =
    Lane_TurnType_TURN_TYPE_TURN_LEFT;
  static const TurnType TURN_TYPE_TURN_RIGHT =
    Lane_TurnType_TURN_TYPE_TURN_RIGHT;
  static const TurnType TURN_TYPE_TURN_LEFT_AROUND =
    Lane_TurnType_TURN_TYPE_TURN_LEFT_AROUND;
  static const TurnType TURN_TYPE_TURN_RIGHT_AROUND =
    Lane_TurnType_TURN_TYPE_TURN_RIGHT_AROUND;
  static const TurnType TURN_TYPE_TURN_LEFT_AREA =
    Lane_TurnType_TURN_TYPE_TURN_LEFT_AREA;
  static const TurnType TURN_TYPE_TURN_RIGHT_AREA =
    Lane_TurnType_TURN_TYPE_TURN_RIGHT_AREA;
  static const TurnType TURN_TYPE_RESERVE_1 =
    Lane_TurnType_TURN_TYPE_RESERVE_1;
  static const TurnType TURN_TYPE_RESERVE_2 =
    Lane_TurnType_TURN_TYPE_RESERVE_2;
  static const TurnType TURN_TYPE_RESERVE_3 =
    Lane_TurnType_TURN_TYPE_RESERVE_3;
  static const TurnType TURN_TYPE_RESERVE_4 =
    Lane_TurnType_TURN_TYPE_RESERVE_4;
  static const TurnType TURN_TYPE_RESERVE_5 =
    Lane_TurnType_TURN_TYPE_RESERVE_5;
  static const TurnType TURN_TYPE_OTHERS =
    Lane_TurnType_TURN_TYPE_OTHERS;
  static inline bool TurnType_IsValid(int value) {
    return Lane_TurnType_IsValid(value);
  }
  static const TurnType TurnType_MIN =
    Lane_TurnType_TurnType_MIN;
  static const TurnType TurnType_MAX =
    Lane_TurnType_TurnType_MAX;
  static const int TurnType_ARRAYSIZE =
    Lane_TurnType_TurnType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TurnType_descriptor() {
    return Lane_TurnType_descriptor();
  }
  static inline const ::std::string& TurnType_Name(TurnType value) {
    return Lane_TurnType_Name(value);
  }
  static inline bool TurnType_Parse(const ::std::string& name,
      TurnType* value) {
    return Lane_TurnType_Parse(name, value);
  }

  typedef Lane_TranType TranType;
  static const TranType TRAN_TYPE_UNDEFINED =
    Lane_TranType_TRAN_TYPE_UNDEFINED;
  static const TranType TRAN_TYPE_LANE_OPENING =
    Lane_TranType_TRAN_TYPE_LANE_OPENING;
  static const TranType TRAN_TYPE_LANE_ENDING =
    Lane_TranType_TRAN_TYPE_LANE_ENDING;
  static const TranType TRAN_TYPE_LOGICAL_TRANSITION_LANE =
    Lane_TranType_TRAN_TYPE_LOGICAL_TRANSITION_LANE;
  static const TranType TRAN_TYPE_EXIT_AND_ENTRY_LANE =
    Lane_TranType_TRAN_TYPE_EXIT_AND_ENTRY_LANE;
  static const TranType TRAN_TYPE_EXIT_OR_ENTRY_LANE =
    Lane_TranType_TRAN_TYPE_EXIT_OR_ENTRY_LANE;
  static const TranType TRAN_TYPE_TRAIN_TRACK =
    Lane_TranType_TRAN_TYPE_TRAIN_TRACK;
  static const TranType TRAN_TYPE_PUBLIC_TRANSPORT_STOP =
    Lane_TranType_TRAN_TYPE_PUBLIC_TRANSPORT_STOP;
  static const TranType TRAN_TYPE_WAITING_AREA =
    Lane_TranType_TRAN_TYPE_WAITING_AREA;
  static const TranType TRAN_TYPE_ENTRY_LANE =
    Lane_TranType_TRAN_TYPE_ENTRY_LANE;
  static const TranType TRAN_TYPE_EXIT_LANE =
    Lane_TranType_TRAN_TYPE_EXIT_LANE;
  static const TranType TRAN_TYPE_NORMAL_LANE =
    Lane_TranType_TRAN_TYPE_NORMAL_LANE;
  static const TranType TRAN_TYPE_LANE_OPENING_AND_ENDING =
    Lane_TranType_TRAN_TYPE_LANE_OPENING_AND_ENDING;
  static const TranType TRAN_TYPE_LANE_ENDING_AND_OPENING =
    Lane_TranType_TRAN_TYPE_LANE_ENDING_AND_OPENING;
  static const TranType TRAN_TYPE_WIDE_STEP =
    Lane_TranType_TRAN_TYPE_WIDE_STEP;
  static const TranType TRAN_TYPE_NARROW_STEP =
    Lane_TranType_TRAN_TYPE_NARROW_STEP;
  static const TranType TRAN_TYPE_SPLITING =
    Lane_TranType_TRAN_TYPE_SPLITING;
  static const TranType TRAN_TYPE_MERGING =
    Lane_TranType_TRAN_TYPE_MERGING;
  static const TranType TRAN_TYPE_NEWBORN =
    Lane_TranType_TRAN_TYPE_NEWBORN;
  static const TranType TRAN_TYPE_BREAKUP =
    Lane_TranType_TRAN_TYPE_BREAKUP;
  static const TranType TRAN_TYPE_NOT_APPLICABLE =
    Lane_TranType_TRAN_TYPE_NOT_APPLICABLE;
  static const TranType TRAN_TYPE_RESERVED_1 =
    Lane_TranType_TRAN_TYPE_RESERVED_1;
  static const TranType TRAN_TYPE_RESERVED_2 =
    Lane_TranType_TRAN_TYPE_RESERVED_2;
  static const TranType TRAN_TYPE_RESERVED_3 =
    Lane_TranType_TRAN_TYPE_RESERVED_3;
  static const TranType TRAN_TYPE_RESERVED_4 =
    Lane_TranType_TRAN_TYPE_RESERVED_4;
  static const TranType TRAN_TYPE_RESERVED_5 =
    Lane_TranType_TRAN_TYPE_RESERVED_5;
  static const TranType TRAN_TYPE_OTHERS =
    Lane_TranType_TRAN_TYPE_OTHERS;
  static inline bool TranType_IsValid(int value) {
    return Lane_TranType_IsValid(value);
  }
  static const TranType TranType_MIN =
    Lane_TranType_TranType_MIN;
  static const TranType TranType_MAX =
    Lane_TranType_TranType_MAX;
  static const int TranType_ARRAYSIZE =
    Lane_TranType_TranType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TranType_descriptor() {
    return Lane_TranType_descriptor();
  }
  static inline const ::std::string& TranType_Name(TranType value) {
    return Lane_TranType_Name(value);
  }
  static inline bool TranType_Parse(const ::std::string& name,
      TranType* value) {
    return Lane_TranType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .holo.map.proto.common.Condition condition = 14;
  int condition_size() const;
  void clear_condition();
  static const int kConditionFieldNumber = 14;
  ::holo::map::proto::common::Condition* mutable_condition(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::Condition >*
      mutable_condition();
  const ::holo::map::proto::common::Condition& condition(int index) const;
  ::holo::map::proto::common::Condition* add_condition();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::Condition >&
      condition() const;

  // repeated uint64 pre_lane_ids = 19 [packed = true];
  int pre_lane_ids_size() const;
  void clear_pre_lane_ids();
  static const int kPreLaneIdsFieldNumber = 19;
  ::google::protobuf::uint64 pre_lane_ids(int index) const;
  void set_pre_lane_ids(int index, ::google::protobuf::uint64 value);
  void add_pre_lane_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      pre_lane_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_pre_lane_ids();

  // repeated uint64 succ_lane_ids = 20 [packed = true];
  int succ_lane_ids_size() const;
  void clear_succ_lane_ids();
  static const int kSuccLaneIdsFieldNumber = 20;
  ::google::protobuf::uint64 succ_lane_ids(int index) const;
  void set_succ_lane_ids(int index, ::google::protobuf::uint64 value);
  void add_succ_lane_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      succ_lane_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_succ_lane_ids();

  // repeated uint64 parking_space_ids = 21 [packed = true];
  int parking_space_ids_size() const;
  void clear_parking_space_ids();
  static const int kParkingSpaceIdsFieldNumber = 21;
  ::google::protobuf::uint64 parking_space_ids(int index) const;
  void set_parking_space_ids(int index, ::google::protobuf::uint64 value);
  void add_parking_space_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      parking_space_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_parking_space_ids();

  // repeated .holo.map.proto.base.LaneWidthInfo lane_percent_width = 25;
  int lane_percent_width_size() const;
  void clear_lane_percent_width();
  static const int kLanePercentWidthFieldNumber = 25;
  ::holo::map::proto::base::LaneWidthInfo* mutable_lane_percent_width(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::LaneWidthInfo >*
      mutable_lane_percent_width();
  const ::holo::map::proto::base::LaneWidthInfo& lane_percent_width(int index) const;
  ::holo::map::proto::base::LaneWidthInfo* add_lane_percent_width();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::LaneWidthInfo >&
      lane_percent_width() const;

  // repeated uint64 tile_ids = 26 [packed = true];
  int tile_ids_size() const;
  void clear_tile_ids();
  static const int kTileIdsFieldNumber = 26;
  ::google::protobuf::uint64 tile_ids(int index) const;
  void set_tile_ids(int index, ::google::protobuf::uint64 value);
  void add_tile_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      tile_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_tile_ids();

  // repeated .holo.map.proto.base.SpeedLimitInfo lane_speed_limit = 30;
  int lane_speed_limit_size() const;
  void clear_lane_speed_limit();
  static const int kLaneSpeedLimitFieldNumber = 30;
  ::holo::map::proto::base::SpeedLimitInfo* mutable_lane_speed_limit(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::SpeedLimitInfo >*
      mutable_lane_speed_limit();
  const ::holo::map::proto::base::SpeedLimitInfo& lane_speed_limit(int index) const;
  ::holo::map::proto::base::SpeedLimitInfo* add_lane_speed_limit();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::SpeedLimitInfo >&
      lane_speed_limit() const;

  // repeated uint64 opposite_lane_ids = 33 [packed = true];
  int opposite_lane_ids_size() const;
  void clear_opposite_lane_ids();
  static const int kOppositeLaneIdsFieldNumber = 33;
  ::google::protobuf::uint64 opposite_lane_ids(int index) const;
  void set_opposite_lane_ids(int index, ::google::protobuf::uint64 value);
  void add_opposite_lane_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      opposite_lane_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_opposite_lane_ids();

  // repeated .holo.map.proto.common.IdIntervalFloat64 associated_safe_islands = 49;
  int associated_safe_islands_size() const;
  void clear_associated_safe_islands();
  static const int kAssociatedSafeIslandsFieldNumber = 49;
  ::holo::map::proto::common::IdIntervalFloat64* mutable_associated_safe_islands(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
      mutable_associated_safe_islands();
  const ::holo::map::proto::common::IdIntervalFloat64& associated_safe_islands(int index) const;
  ::holo::map::proto::common::IdIntervalFloat64* add_associated_safe_islands();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
      associated_safe_islands() const;

  // repeated .holo.map.proto.common.IdIntervalFloat64 associated_stop_lines = 50;
  int associated_stop_lines_size() const;
  void clear_associated_stop_lines();
  static const int kAssociatedStopLinesFieldNumber = 50;
  ::holo::map::proto::common::IdIntervalFloat64* mutable_associated_stop_lines(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
      mutable_associated_stop_lines();
  const ::holo::map::proto::common::IdIntervalFloat64& associated_stop_lines(int index) const;
  ::holo::map::proto::common::IdIntervalFloat64* add_associated_stop_lines();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
      associated_stop_lines() const;

  // repeated .holo.map.proto.common.IdIntervalFloat64 associated_traffic_lights = 51;
  int associated_traffic_lights_size() const;
  void clear_associated_traffic_lights();
  static const int kAssociatedTrafficLightsFieldNumber = 51;
  ::holo::map::proto::common::IdIntervalFloat64* mutable_associated_traffic_lights(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
      mutable_associated_traffic_lights();
  const ::holo::map::proto::common::IdIntervalFloat64& associated_traffic_lights(int index) const;
  ::holo::map::proto::common::IdIntervalFloat64* add_associated_traffic_lights();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
      associated_traffic_lights() const;

  // repeated .holo.map.proto.common.IdIntervalFloat64 associated_painted_markings = 52;
  int associated_painted_markings_size() const;
  void clear_associated_painted_markings();
  static const int kAssociatedPaintedMarkingsFieldNumber = 52;
  ::holo::map::proto::common::IdIntervalFloat64* mutable_associated_painted_markings(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
      mutable_associated_painted_markings();
  const ::holo::map::proto::common::IdIntervalFloat64& associated_painted_markings(int index) const;
  ::holo::map::proto::common::IdIntervalFloat64* add_associated_painted_markings();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
      associated_painted_markings() const;

  // repeated .holo.map.proto.common.IdIntervalFloat64 associated_pedestrian_crossings = 53;
  int associated_pedestrian_crossings_size() const;
  void clear_associated_pedestrian_crossings();
  static const int kAssociatedPedestrianCrossingsFieldNumber = 53;
  ::holo::map::proto::common::IdIntervalFloat64* mutable_associated_pedestrian_crossings(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
      mutable_associated_pedestrian_crossings();
  const ::holo::map::proto::common::IdIntervalFloat64& associated_pedestrian_crossings(int index) const;
  ::holo::map::proto::common::IdIntervalFloat64* add_associated_pedestrian_crossings();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
      associated_pedestrian_crossings() const;

  // repeated .holo.map.proto.common.IdIntervalFloat64 associated_traffic_signs = 54;
  int associated_traffic_signs_size() const;
  void clear_associated_traffic_signs();
  static const int kAssociatedTrafficSignsFieldNumber = 54;
  ::holo::map::proto::common::IdIntervalFloat64* mutable_associated_traffic_signs(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
      mutable_associated_traffic_signs();
  const ::holo::map::proto::common::IdIntervalFloat64& associated_traffic_signs(int index) const;
  ::holo::map::proto::common::IdIntervalFloat64* add_associated_traffic_signs();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
      associated_traffic_signs() const;

  // repeated .holo.map.proto.common.IdIntervalFloat64 associated_quasi_poles = 55;
  int associated_quasi_poles_size() const;
  void clear_associated_quasi_poles();
  static const int kAssociatedQuasiPolesFieldNumber = 55;
  ::holo::map::proto::common::IdIntervalFloat64* mutable_associated_quasi_poles(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
      mutable_associated_quasi_poles();
  const ::holo::map::proto::common::IdIntervalFloat64& associated_quasi_poles(int index) const;
  ::holo::map::proto::common::IdIntervalFloat64* add_associated_quasi_poles();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
      associated_quasi_poles() const;

  // map<uint32, .holo.map.proto.common.GeoBox> extra_region = 65;
  int extra_region_size() const;
  void clear_extra_region();
  static const int kExtraRegionFieldNumber = 65;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox >&
      extra_region() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox >*
      mutable_extra_region();

  // repeated .holo.map.proto.common.GeoPoint geometry_points = 66;
  int geometry_points_size() const;
  void clear_geometry_points();
  static const int kGeometryPointsFieldNumber = 66;
  ::holo::map::proto::common::GeoPoint* mutable_geometry_points(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoPoint >*
      mutable_geometry_points();
  const ::holo::map::proto::common::GeoPoint& geometry_points(int index) const;
  ::holo::map::proto::common::GeoPoint* add_geometry_points();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoPoint >&
      geometry_points() const;

  // map<uint32, .holo.map.proto.common.GeoLine> extra_geometry_points = 67;
  int extra_geometry_points_size() const;
  void clear_extra_geometry_points();
  static const int kExtraGeometryPointsFieldNumber = 67;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoLine >&
      extra_geometry_points() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoLine >*
      mutable_extra_geometry_points();

  // optional .holo.map.proto.common.Coordinate coordinate = 60;
  bool has_coordinate() const;
  void clear_coordinate();
  static const int kCoordinateFieldNumber = 60;
  private:
  const ::holo::map::proto::common::Coordinate& _internal_coordinate() const;
  public:
  const ::holo::map::proto::common::Coordinate& coordinate() const;
  ::holo::map::proto::common::Coordinate* release_coordinate();
  ::holo::map::proto::common::Coordinate* mutable_coordinate();
  void set_allocated_coordinate(::holo::map::proto::common::Coordinate* coordinate);

  // optional .holo.map.proto.common.GeoBox region = 64;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 64;
  private:
  const ::holo::map::proto::common::GeoBox& _internal_region() const;
  public:
  const ::holo::map::proto::common::GeoBox& region() const;
  ::holo::map::proto::common::GeoBox* release_region();
  ::holo::map::proto::common::GeoBox* mutable_region();
  void set_allocated_region(::holo::map::proto::common::GeoBox* region);

  // optional uint64 lane_id = 1;
  bool has_lane_id() const;
  void clear_lane_id();
  static const int kLaneIdFieldNumber = 1;
  ::google::protobuf::uint64 lane_id() const;
  void set_lane_id(::google::protobuf::uint64 value);

  // optional uint64 lane_group_id = 2;
  bool has_lane_group_id() const;
  void clear_lane_group_id();
  static const int kLaneGroupIdFieldNumber = 2;
  ::google::protobuf::uint64 lane_group_id() const;
  void set_lane_group_id(::google::protobuf::uint64 value);

  // optional .holo.map.proto.base.Lane.LaneDir lane_dir = 4;
  bool has_lane_dir() const;
  void clear_lane_dir();
  static const int kLaneDirFieldNumber = 4;
  ::holo::map::proto::base::Lane_LaneDir lane_dir() const;
  void set_lane_dir(::holo::map::proto::base::Lane_LaneDir value);

  // optional int32 lane_seq = 5;
  bool has_lane_seq() const;
  void clear_lane_seq();
  static const int kLaneSeqFieldNumber = 5;
  ::google::protobuf::int32 lane_seq() const;
  void set_lane_seq(::google::protobuf::int32 value);

  // optional uint64 left_lane_boundary_id = 6;
  bool has_left_lane_boundary_id() const;
  void clear_left_lane_boundary_id();
  static const int kLeftLaneBoundaryIdFieldNumber = 6;
  ::google::protobuf::uint64 left_lane_boundary_id() const;
  void set_left_lane_boundary_id(::google::protobuf::uint64 value);

  // optional uint64 right_lane_boundary_id = 7;
  bool has_right_lane_boundary_id() const;
  void clear_right_lane_boundary_id();
  static const int kRightLaneBoundaryIdFieldNumber = 7;
  ::google::protobuf::uint64 right_lane_boundary_id() const;
  void set_right_lane_boundary_id(::google::protobuf::uint64 value);

  // optional uint64 intersection_id = 8;
  bool has_intersection_id() const;
  void clear_intersection_id();
  static const int kIntersectionIdFieldNumber = 8;
  ::google::protobuf::uint64 intersection_id() const;
  void set_intersection_id(::google::protobuf::uint64 value);

  // optional uint64 adas_id = 9;
  bool has_adas_id() const;
  void clear_adas_id();
  static const int kAdasIdFieldNumber = 9;
  ::google::protobuf::uint64 adas_id() const;
  void set_adas_id(::google::protobuf::uint64 value);

  // optional .holo.map.proto.base.Lane.LaneType lane_type = 12;
  bool has_lane_type() const;
  void clear_lane_type();
  static const int kLaneTypeFieldNumber = 12;
  ::holo::map::proto::base::Lane_LaneType lane_type() const;
  void set_lane_type(::holo::map::proto::base::Lane_LaneType value);

  // optional .holo.map.proto.base.Lane.TurnType turn_type = 13;
  bool has_turn_type() const;
  void clear_turn_type();
  static const int kTurnTypeFieldNumber = 13;
  ::holo::map::proto::base::Lane_TurnType turn_type() const;
  void set_turn_type(::holo::map::proto::base::Lane_TurnType value);

  // optional uint64 begin_intersection_id = 17;
  bool has_begin_intersection_id() const;
  void clear_begin_intersection_id();
  static const int kBeginIntersectionIdFieldNumber = 17;
  ::google::protobuf::uint64 begin_intersection_id() const;
  void set_begin_intersection_id(::google::protobuf::uint64 value);

  // optional uint64 end_intersection_id = 18;
  bool has_end_intersection_id() const;
  void clear_end_intersection_id();
  static const int kEndIntersectionIdFieldNumber = 18;
  ::google::protobuf::uint64 end_intersection_id() const;
  void set_end_intersection_id(::google::protobuf::uint64 value);

  // optional .holo.map.proto.base.Lane.TranType tran_type = 15;
  bool has_tran_type() const;
  void clear_tran_type();
  static const int kTranTypeFieldNumber = 15;
  ::holo::map::proto::base::Lane_TranType tran_type() const;
  void set_tran_type(::holo::map::proto::base::Lane_TranType value);

  // optional uint32 lane_length_cm = 22;
  bool has_lane_length_cm() const;
  void clear_lane_length_cm();
  static const int kLaneLengthCmFieldNumber = 22;
  ::google::protobuf::uint32 lane_length_cm() const;
  void set_lane_length_cm(::google::protobuf::uint32 value);

  // optional uint64 road_id = 27;
  bool has_road_id() const;
  void clear_road_id();
  static const int kRoadIdFieldNumber = 27;
  ::google::protobuf::uint64 road_id() const;
  void set_road_id(::google::protobuf::uint64 value);

  // optional bool has_geometry = 16;
  bool has_has_geometry() const;
  void clear_has_geometry();
  static const int kHasGeometryFieldNumber = 16;
  bool has_geometry() const;
  void set_has_geometry(bool value);

  // optional bool is_intersection_lane = 28;
  bool has_is_intersection_lane() const;
  void clear_is_intersection_lane();
  static const int kIsIntersectionLaneFieldNumber = 28;
  bool is_intersection_lane() const;
  void set_is_intersection_lane(bool value);

  // optional bool is_restrict = 29;
  bool has_is_restrict() const;
  void clear_is_restrict();
  static const int kIsRestrictFieldNumber = 29;
  bool is_restrict() const;
  void set_is_restrict(bool value);

  // optional bool south_flag = 63;
  bool has_south_flag() const;
  void clear_south_flag();
  static const int kSouthFlagFieldNumber = 63;
  bool south_flag() const;
  void set_south_flag(bool value);

  // optional uint32 zone_id = 61;
  bool has_zone_id() const;
  void clear_zone_id();
  static const int kZoneIdFieldNumber = 61;
  ::google::protobuf::uint32 zone_id() const;
  void set_zone_id(::google::protobuf::uint32 value);

  // optional uint32 extra_zone_id = 62;
  bool has_extra_zone_id() const;
  void clear_extra_zone_id();
  static const int kExtraZoneIdFieldNumber = 62;
  ::google::protobuf::uint32 extra_zone_id() const;
  void set_extra_zone_id(::google::protobuf::uint32 value);

  // optional uint64 object_parking_lot_id = 56;
  bool has_object_parking_lot_id() const;
  void clear_object_parking_lot_id();
  static const int kObjectParkingLotIdFieldNumber = 56;
  ::google::protobuf::uint64 object_parking_lot_id() const;
  void set_object_parking_lot_id(::google::protobuf::uint64 value);

  // optional uint64 object_parking_floor_id = 57;
  bool has_object_parking_floor_id() const;
  void clear_object_parking_floor_id();
  static const int kObjectParkingFloorIdFieldNumber = 57;
  ::google::protobuf::uint64 object_parking_floor_id() const;
  void set_object_parking_floor_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:holo.map.proto.base.Lane)
 private:
  void set_has_lane_id();
  void clear_has_lane_id();
  void set_has_lane_group_id();
  void clear_has_lane_group_id();
  void set_has_lane_dir();
  void clear_has_lane_dir();
  void set_has_lane_seq();
  void clear_has_lane_seq();
  void set_has_left_lane_boundary_id();
  void clear_has_left_lane_boundary_id();
  void set_has_right_lane_boundary_id();
  void clear_has_right_lane_boundary_id();
  void set_has_intersection_id();
  void clear_has_intersection_id();
  void set_has_adas_id();
  void clear_has_adas_id();
  void set_has_lane_type();
  void clear_has_lane_type();
  void set_has_turn_type();
  void clear_has_turn_type();
  void set_has_tran_type();
  void clear_has_tran_type();
  void set_has_has_geometry();
  void clear_has_has_geometry();
  void set_has_begin_intersection_id();
  void clear_has_begin_intersection_id();
  void set_has_end_intersection_id();
  void clear_has_end_intersection_id();
  void set_has_lane_length_cm();
  void clear_has_lane_length_cm();
  void set_has_road_id();
  void clear_has_road_id();
  void set_has_is_intersection_lane();
  void clear_has_is_intersection_lane();
  void set_has_is_restrict();
  void clear_has_is_restrict();
  void set_has_object_parking_lot_id();
  void clear_has_object_parking_lot_id();
  void set_has_object_parking_floor_id();
  void clear_has_object_parking_floor_id();
  void set_has_coordinate();
  void clear_has_coordinate();
  void set_has_zone_id();
  void clear_has_zone_id();
  void set_has_extra_zone_id();
  void clear_has_extra_zone_id();
  void set_has_south_flag();
  void clear_has_south_flag();
  void set_has_region();
  void clear_has_region();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::Condition > condition_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > pre_lane_ids_;
  mutable int _pre_lane_ids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > succ_lane_ids_;
  mutable int _succ_lane_ids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > parking_space_ids_;
  mutable int _parking_space_ids_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::LaneWidthInfo > lane_percent_width_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > tile_ids_;
  mutable int _tile_ids_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::SpeedLimitInfo > lane_speed_limit_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > opposite_lane_ids_;
  mutable int _opposite_lane_ids_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 > associated_safe_islands_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 > associated_stop_lines_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 > associated_traffic_lights_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 > associated_painted_markings_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 > associated_pedestrian_crossings_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 > associated_traffic_signs_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 > associated_quasi_poles_;
  ::google::protobuf::internal::MapField<
      Lane_ExtraRegionEntry_DoNotUse,
      ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > extra_region_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoPoint > geometry_points_;
  ::google::protobuf::internal::MapField<
      Lane_ExtraGeometryPointsEntry_DoNotUse,
      ::google::protobuf::uint32, ::holo::map::proto::common::GeoLine,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > extra_geometry_points_;
  ::holo::map::proto::common::Coordinate* coordinate_;
  ::holo::map::proto::common::GeoBox* region_;
  ::google::protobuf::uint64 lane_id_;
  ::google::protobuf::uint64 lane_group_id_;
  int lane_dir_;
  ::google::protobuf::int32 lane_seq_;
  ::google::protobuf::uint64 left_lane_boundary_id_;
  ::google::protobuf::uint64 right_lane_boundary_id_;
  ::google::protobuf::uint64 intersection_id_;
  ::google::protobuf::uint64 adas_id_;
  int lane_type_;
  int turn_type_;
  ::google::protobuf::uint64 begin_intersection_id_;
  ::google::protobuf::uint64 end_intersection_id_;
  int tran_type_;
  ::google::protobuf::uint32 lane_length_cm_;
  ::google::protobuf::uint64 road_id_;
  bool has_geometry_;
  bool is_intersection_lane_;
  bool is_restrict_;
  bool south_flag_;
  ::google::protobuf::uint32 zone_id_;
  ::google::protobuf::uint32 extra_zone_id_;
  ::google::protobuf::uint64 object_parking_lot_id_;
  ::google::protobuf::uint64 object_parking_floor_id_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fbase_2flane_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Lane

// optional uint64 lane_id = 1;
inline bool Lane::has_lane_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Lane::set_has_lane_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Lane::clear_has_lane_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Lane::clear_lane_id() {
  lane_id_ = GOOGLE_ULONGLONG(0);
  clear_has_lane_id();
}
inline ::google::protobuf::uint64 Lane::lane_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.lane_id)
  return lane_id_;
}
inline void Lane::set_lane_id(::google::protobuf::uint64 value) {
  set_has_lane_id();
  lane_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.lane_id)
}

// optional uint64 lane_group_id = 2;
inline bool Lane::has_lane_group_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Lane::set_has_lane_group_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Lane::clear_has_lane_group_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Lane::clear_lane_group_id() {
  lane_group_id_ = GOOGLE_ULONGLONG(0);
  clear_has_lane_group_id();
}
inline ::google::protobuf::uint64 Lane::lane_group_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.lane_group_id)
  return lane_group_id_;
}
inline void Lane::set_lane_group_id(::google::protobuf::uint64 value) {
  set_has_lane_group_id();
  lane_group_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.lane_group_id)
}

// optional .holo.map.proto.base.Lane.LaneDir lane_dir = 4;
inline bool Lane::has_lane_dir() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Lane::set_has_lane_dir() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Lane::clear_has_lane_dir() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Lane::clear_lane_dir() {
  lane_dir_ = 0;
  clear_has_lane_dir();
}
inline ::holo::map::proto::base::Lane_LaneDir Lane::lane_dir() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.lane_dir)
  return static_cast< ::holo::map::proto::base::Lane_LaneDir >(lane_dir_);
}
inline void Lane::set_lane_dir(::holo::map::proto::base::Lane_LaneDir value) {
  assert(::holo::map::proto::base::Lane_LaneDir_IsValid(value));
  set_has_lane_dir();
  lane_dir_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.lane_dir)
}

// optional int32 lane_seq = 5;
inline bool Lane::has_lane_seq() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Lane::set_has_lane_seq() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Lane::clear_has_lane_seq() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Lane::clear_lane_seq() {
  lane_seq_ = 0;
  clear_has_lane_seq();
}
inline ::google::protobuf::int32 Lane::lane_seq() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.lane_seq)
  return lane_seq_;
}
inline void Lane::set_lane_seq(::google::protobuf::int32 value) {
  set_has_lane_seq();
  lane_seq_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.lane_seq)
}

// optional uint64 left_lane_boundary_id = 6;
inline bool Lane::has_left_lane_boundary_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Lane::set_has_left_lane_boundary_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Lane::clear_has_left_lane_boundary_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Lane::clear_left_lane_boundary_id() {
  left_lane_boundary_id_ = GOOGLE_ULONGLONG(0);
  clear_has_left_lane_boundary_id();
}
inline ::google::protobuf::uint64 Lane::left_lane_boundary_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.left_lane_boundary_id)
  return left_lane_boundary_id_;
}
inline void Lane::set_left_lane_boundary_id(::google::protobuf::uint64 value) {
  set_has_left_lane_boundary_id();
  left_lane_boundary_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.left_lane_boundary_id)
}

// optional uint64 right_lane_boundary_id = 7;
inline bool Lane::has_right_lane_boundary_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Lane::set_has_right_lane_boundary_id() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Lane::clear_has_right_lane_boundary_id() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Lane::clear_right_lane_boundary_id() {
  right_lane_boundary_id_ = GOOGLE_ULONGLONG(0);
  clear_has_right_lane_boundary_id();
}
inline ::google::protobuf::uint64 Lane::right_lane_boundary_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.right_lane_boundary_id)
  return right_lane_boundary_id_;
}
inline void Lane::set_right_lane_boundary_id(::google::protobuf::uint64 value) {
  set_has_right_lane_boundary_id();
  right_lane_boundary_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.right_lane_boundary_id)
}

// optional uint64 intersection_id = 8;
inline bool Lane::has_intersection_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Lane::set_has_intersection_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Lane::clear_has_intersection_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Lane::clear_intersection_id() {
  intersection_id_ = GOOGLE_ULONGLONG(0);
  clear_has_intersection_id();
}
inline ::google::protobuf::uint64 Lane::intersection_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.intersection_id)
  return intersection_id_;
}
inline void Lane::set_intersection_id(::google::protobuf::uint64 value) {
  set_has_intersection_id();
  intersection_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.intersection_id)
}

// optional uint64 adas_id = 9;
inline bool Lane::has_adas_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Lane::set_has_adas_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Lane::clear_has_adas_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Lane::clear_adas_id() {
  adas_id_ = GOOGLE_ULONGLONG(0);
  clear_has_adas_id();
}
inline ::google::protobuf::uint64 Lane::adas_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.adas_id)
  return adas_id_;
}
inline void Lane::set_adas_id(::google::protobuf::uint64 value) {
  set_has_adas_id();
  adas_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.adas_id)
}

// optional .holo.map.proto.base.Lane.LaneType lane_type = 12;
inline bool Lane::has_lane_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Lane::set_has_lane_type() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Lane::clear_has_lane_type() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Lane::clear_lane_type() {
  lane_type_ = 0;
  clear_has_lane_type();
}
inline ::holo::map::proto::base::Lane_LaneType Lane::lane_type() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.lane_type)
  return static_cast< ::holo::map::proto::base::Lane_LaneType >(lane_type_);
}
inline void Lane::set_lane_type(::holo::map::proto::base::Lane_LaneType value) {
  assert(::holo::map::proto::base::Lane_LaneType_IsValid(value));
  set_has_lane_type();
  lane_type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.lane_type)
}

// optional .holo.map.proto.base.Lane.TurnType turn_type = 13;
inline bool Lane::has_turn_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Lane::set_has_turn_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Lane::clear_has_turn_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Lane::clear_turn_type() {
  turn_type_ = 0;
  clear_has_turn_type();
}
inline ::holo::map::proto::base::Lane_TurnType Lane::turn_type() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.turn_type)
  return static_cast< ::holo::map::proto::base::Lane_TurnType >(turn_type_);
}
inline void Lane::set_turn_type(::holo::map::proto::base::Lane_TurnType value) {
  assert(::holo::map::proto::base::Lane_TurnType_IsValid(value));
  set_has_turn_type();
  turn_type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.turn_type)
}

// repeated .holo.map.proto.common.Condition condition = 14;
inline int Lane::condition_size() const {
  return condition_.size();
}
inline ::holo::map::proto::common::Condition* Lane::mutable_condition(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.condition)
  return condition_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::Condition >*
Lane::mutable_condition() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.condition)
  return &condition_;
}
inline const ::holo::map::proto::common::Condition& Lane::condition(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.condition)
  return condition_.Get(index);
}
inline ::holo::map::proto::common::Condition* Lane::add_condition() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.condition)
  return condition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::Condition >&
Lane::condition() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.condition)
  return condition_;
}

// optional .holo.map.proto.base.Lane.TranType tran_type = 15;
inline bool Lane::has_tran_type() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void Lane::set_has_tran_type() {
  _has_bits_[0] |= 0x00004000u;
}
inline void Lane::clear_has_tran_type() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void Lane::clear_tran_type() {
  tran_type_ = 0;
  clear_has_tran_type();
}
inline ::holo::map::proto::base::Lane_TranType Lane::tran_type() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.tran_type)
  return static_cast< ::holo::map::proto::base::Lane_TranType >(tran_type_);
}
inline void Lane::set_tran_type(::holo::map::proto::base::Lane_TranType value) {
  assert(::holo::map::proto::base::Lane_TranType_IsValid(value));
  set_has_tran_type();
  tran_type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.tran_type)
}

// optional bool has_geometry = 16;
inline bool Lane::has_has_geometry() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void Lane::set_has_has_geometry() {
  _has_bits_[0] |= 0x00020000u;
}
inline void Lane::clear_has_has_geometry() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void Lane::clear_has_geometry() {
  has_geometry_ = false;
  clear_has_has_geometry();
}
inline bool Lane::has_geometry() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.has_geometry)
  return has_geometry_;
}
inline void Lane::set_has_geometry(bool value) {
  set_has_has_geometry();
  has_geometry_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.has_geometry)
}

// optional uint64 begin_intersection_id = 17;
inline bool Lane::has_begin_intersection_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Lane::set_has_begin_intersection_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Lane::clear_has_begin_intersection_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Lane::clear_begin_intersection_id() {
  begin_intersection_id_ = GOOGLE_ULONGLONG(0);
  clear_has_begin_intersection_id();
}
inline ::google::protobuf::uint64 Lane::begin_intersection_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.begin_intersection_id)
  return begin_intersection_id_;
}
inline void Lane::set_begin_intersection_id(::google::protobuf::uint64 value) {
  set_has_begin_intersection_id();
  begin_intersection_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.begin_intersection_id)
}

// optional uint64 end_intersection_id = 18;
inline bool Lane::has_end_intersection_id() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Lane::set_has_end_intersection_id() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Lane::clear_has_end_intersection_id() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Lane::clear_end_intersection_id() {
  end_intersection_id_ = GOOGLE_ULONGLONG(0);
  clear_has_end_intersection_id();
}
inline ::google::protobuf::uint64 Lane::end_intersection_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.end_intersection_id)
  return end_intersection_id_;
}
inline void Lane::set_end_intersection_id(::google::protobuf::uint64 value) {
  set_has_end_intersection_id();
  end_intersection_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.end_intersection_id)
}

// repeated uint64 pre_lane_ids = 19 [packed = true];
inline int Lane::pre_lane_ids_size() const {
  return pre_lane_ids_.size();
}
inline void Lane::clear_pre_lane_ids() {
  pre_lane_ids_.Clear();
}
inline ::google::protobuf::uint64 Lane::pre_lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.pre_lane_ids)
  return pre_lane_ids_.Get(index);
}
inline void Lane::set_pre_lane_ids(int index, ::google::protobuf::uint64 value) {
  pre_lane_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.pre_lane_ids)
}
inline void Lane::add_pre_lane_ids(::google::protobuf::uint64 value) {
  pre_lane_ids_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.pre_lane_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Lane::pre_lane_ids() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.pre_lane_ids)
  return pre_lane_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Lane::mutable_pre_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.pre_lane_ids)
  return &pre_lane_ids_;
}

// repeated uint64 succ_lane_ids = 20 [packed = true];
inline int Lane::succ_lane_ids_size() const {
  return succ_lane_ids_.size();
}
inline void Lane::clear_succ_lane_ids() {
  succ_lane_ids_.Clear();
}
inline ::google::protobuf::uint64 Lane::succ_lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.succ_lane_ids)
  return succ_lane_ids_.Get(index);
}
inline void Lane::set_succ_lane_ids(int index, ::google::protobuf::uint64 value) {
  succ_lane_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.succ_lane_ids)
}
inline void Lane::add_succ_lane_ids(::google::protobuf::uint64 value) {
  succ_lane_ids_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.succ_lane_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Lane::succ_lane_ids() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.succ_lane_ids)
  return succ_lane_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Lane::mutable_succ_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.succ_lane_ids)
  return &succ_lane_ids_;
}

// repeated uint64 parking_space_ids = 21 [packed = true];
inline int Lane::parking_space_ids_size() const {
  return parking_space_ids_.size();
}
inline void Lane::clear_parking_space_ids() {
  parking_space_ids_.Clear();
}
inline ::google::protobuf::uint64 Lane::parking_space_ids(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.parking_space_ids)
  return parking_space_ids_.Get(index);
}
inline void Lane::set_parking_space_ids(int index, ::google::protobuf::uint64 value) {
  parking_space_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.parking_space_ids)
}
inline void Lane::add_parking_space_ids(::google::protobuf::uint64 value) {
  parking_space_ids_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.parking_space_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Lane::parking_space_ids() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.parking_space_ids)
  return parking_space_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Lane::mutable_parking_space_ids() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.parking_space_ids)
  return &parking_space_ids_;
}

// optional uint32 lane_length_cm = 22;
inline bool Lane::has_lane_length_cm() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void Lane::set_has_lane_length_cm() {
  _has_bits_[0] |= 0x00008000u;
}
inline void Lane::clear_has_lane_length_cm() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void Lane::clear_lane_length_cm() {
  lane_length_cm_ = 0u;
  clear_has_lane_length_cm();
}
inline ::google::protobuf::uint32 Lane::lane_length_cm() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.lane_length_cm)
  return lane_length_cm_;
}
inline void Lane::set_lane_length_cm(::google::protobuf::uint32 value) {
  set_has_lane_length_cm();
  lane_length_cm_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.lane_length_cm)
}

// repeated .holo.map.proto.base.LaneWidthInfo lane_percent_width = 25;
inline int Lane::lane_percent_width_size() const {
  return lane_percent_width_.size();
}
inline ::holo::map::proto::base::LaneWidthInfo* Lane::mutable_lane_percent_width(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.lane_percent_width)
  return lane_percent_width_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::LaneWidthInfo >*
Lane::mutable_lane_percent_width() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.lane_percent_width)
  return &lane_percent_width_;
}
inline const ::holo::map::proto::base::LaneWidthInfo& Lane::lane_percent_width(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.lane_percent_width)
  return lane_percent_width_.Get(index);
}
inline ::holo::map::proto::base::LaneWidthInfo* Lane::add_lane_percent_width() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.lane_percent_width)
  return lane_percent_width_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::LaneWidthInfo >&
Lane::lane_percent_width() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.lane_percent_width)
  return lane_percent_width_;
}

// repeated uint64 tile_ids = 26 [packed = true];
inline int Lane::tile_ids_size() const {
  return tile_ids_.size();
}
inline void Lane::clear_tile_ids() {
  tile_ids_.Clear();
}
inline ::google::protobuf::uint64 Lane::tile_ids(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.tile_ids)
  return tile_ids_.Get(index);
}
inline void Lane::set_tile_ids(int index, ::google::protobuf::uint64 value) {
  tile_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.tile_ids)
}
inline void Lane::add_tile_ids(::google::protobuf::uint64 value) {
  tile_ids_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.tile_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Lane::tile_ids() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.tile_ids)
  return tile_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Lane::mutable_tile_ids() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.tile_ids)
  return &tile_ids_;
}

// optional uint64 road_id = 27;
inline bool Lane::has_road_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void Lane::set_has_road_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void Lane::clear_has_road_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void Lane::clear_road_id() {
  road_id_ = GOOGLE_ULONGLONG(0);
  clear_has_road_id();
}
inline ::google::protobuf::uint64 Lane::road_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.road_id)
  return road_id_;
}
inline void Lane::set_road_id(::google::protobuf::uint64 value) {
  set_has_road_id();
  road_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.road_id)
}

// optional bool is_intersection_lane = 28;
inline bool Lane::has_is_intersection_lane() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void Lane::set_has_is_intersection_lane() {
  _has_bits_[0] |= 0x00040000u;
}
inline void Lane::clear_has_is_intersection_lane() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void Lane::clear_is_intersection_lane() {
  is_intersection_lane_ = false;
  clear_has_is_intersection_lane();
}
inline bool Lane::is_intersection_lane() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.is_intersection_lane)
  return is_intersection_lane_;
}
inline void Lane::set_is_intersection_lane(bool value) {
  set_has_is_intersection_lane();
  is_intersection_lane_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.is_intersection_lane)
}

// optional bool is_restrict = 29;
inline bool Lane::has_is_restrict() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void Lane::set_has_is_restrict() {
  _has_bits_[0] |= 0x00080000u;
}
inline void Lane::clear_has_is_restrict() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void Lane::clear_is_restrict() {
  is_restrict_ = false;
  clear_has_is_restrict();
}
inline bool Lane::is_restrict() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.is_restrict)
  return is_restrict_;
}
inline void Lane::set_is_restrict(bool value) {
  set_has_is_restrict();
  is_restrict_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.is_restrict)
}

// repeated .holo.map.proto.base.SpeedLimitInfo lane_speed_limit = 30;
inline int Lane::lane_speed_limit_size() const {
  return lane_speed_limit_.size();
}
inline ::holo::map::proto::base::SpeedLimitInfo* Lane::mutable_lane_speed_limit(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.lane_speed_limit)
  return lane_speed_limit_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::SpeedLimitInfo >*
Lane::mutable_lane_speed_limit() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.lane_speed_limit)
  return &lane_speed_limit_;
}
inline const ::holo::map::proto::base::SpeedLimitInfo& Lane::lane_speed_limit(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.lane_speed_limit)
  return lane_speed_limit_.Get(index);
}
inline ::holo::map::proto::base::SpeedLimitInfo* Lane::add_lane_speed_limit() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.lane_speed_limit)
  return lane_speed_limit_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::base::SpeedLimitInfo >&
Lane::lane_speed_limit() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.lane_speed_limit)
  return lane_speed_limit_;
}

// repeated uint64 opposite_lane_ids = 33 [packed = true];
inline int Lane::opposite_lane_ids_size() const {
  return opposite_lane_ids_.size();
}
inline void Lane::clear_opposite_lane_ids() {
  opposite_lane_ids_.Clear();
}
inline ::google::protobuf::uint64 Lane::opposite_lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.opposite_lane_ids)
  return opposite_lane_ids_.Get(index);
}
inline void Lane::set_opposite_lane_ids(int index, ::google::protobuf::uint64 value) {
  opposite_lane_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.opposite_lane_ids)
}
inline void Lane::add_opposite_lane_ids(::google::protobuf::uint64 value) {
  opposite_lane_ids_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.opposite_lane_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
Lane::opposite_lane_ids() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.opposite_lane_ids)
  return opposite_lane_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
Lane::mutable_opposite_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.opposite_lane_ids)
  return &opposite_lane_ids_;
}

// repeated .holo.map.proto.common.IdIntervalFloat64 associated_safe_islands = 49;
inline int Lane::associated_safe_islands_size() const {
  return associated_safe_islands_.size();
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::mutable_associated_safe_islands(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.associated_safe_islands)
  return associated_safe_islands_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
Lane::mutable_associated_safe_islands() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.associated_safe_islands)
  return &associated_safe_islands_;
}
inline const ::holo::map::proto::common::IdIntervalFloat64& Lane::associated_safe_islands(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.associated_safe_islands)
  return associated_safe_islands_.Get(index);
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::add_associated_safe_islands() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.associated_safe_islands)
  return associated_safe_islands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
Lane::associated_safe_islands() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.associated_safe_islands)
  return associated_safe_islands_;
}

// repeated .holo.map.proto.common.IdIntervalFloat64 associated_stop_lines = 50;
inline int Lane::associated_stop_lines_size() const {
  return associated_stop_lines_.size();
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::mutable_associated_stop_lines(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.associated_stop_lines)
  return associated_stop_lines_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
Lane::mutable_associated_stop_lines() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.associated_stop_lines)
  return &associated_stop_lines_;
}
inline const ::holo::map::proto::common::IdIntervalFloat64& Lane::associated_stop_lines(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.associated_stop_lines)
  return associated_stop_lines_.Get(index);
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::add_associated_stop_lines() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.associated_stop_lines)
  return associated_stop_lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
Lane::associated_stop_lines() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.associated_stop_lines)
  return associated_stop_lines_;
}

// repeated .holo.map.proto.common.IdIntervalFloat64 associated_traffic_lights = 51;
inline int Lane::associated_traffic_lights_size() const {
  return associated_traffic_lights_.size();
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::mutable_associated_traffic_lights(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.associated_traffic_lights)
  return associated_traffic_lights_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
Lane::mutable_associated_traffic_lights() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.associated_traffic_lights)
  return &associated_traffic_lights_;
}
inline const ::holo::map::proto::common::IdIntervalFloat64& Lane::associated_traffic_lights(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.associated_traffic_lights)
  return associated_traffic_lights_.Get(index);
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::add_associated_traffic_lights() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.associated_traffic_lights)
  return associated_traffic_lights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
Lane::associated_traffic_lights() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.associated_traffic_lights)
  return associated_traffic_lights_;
}

// repeated .holo.map.proto.common.IdIntervalFloat64 associated_painted_markings = 52;
inline int Lane::associated_painted_markings_size() const {
  return associated_painted_markings_.size();
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::mutable_associated_painted_markings(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.associated_painted_markings)
  return associated_painted_markings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
Lane::mutable_associated_painted_markings() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.associated_painted_markings)
  return &associated_painted_markings_;
}
inline const ::holo::map::proto::common::IdIntervalFloat64& Lane::associated_painted_markings(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.associated_painted_markings)
  return associated_painted_markings_.Get(index);
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::add_associated_painted_markings() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.associated_painted_markings)
  return associated_painted_markings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
Lane::associated_painted_markings() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.associated_painted_markings)
  return associated_painted_markings_;
}

// repeated .holo.map.proto.common.IdIntervalFloat64 associated_pedestrian_crossings = 53;
inline int Lane::associated_pedestrian_crossings_size() const {
  return associated_pedestrian_crossings_.size();
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::mutable_associated_pedestrian_crossings(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.associated_pedestrian_crossings)
  return associated_pedestrian_crossings_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
Lane::mutable_associated_pedestrian_crossings() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.associated_pedestrian_crossings)
  return &associated_pedestrian_crossings_;
}
inline const ::holo::map::proto::common::IdIntervalFloat64& Lane::associated_pedestrian_crossings(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.associated_pedestrian_crossings)
  return associated_pedestrian_crossings_.Get(index);
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::add_associated_pedestrian_crossings() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.associated_pedestrian_crossings)
  return associated_pedestrian_crossings_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
Lane::associated_pedestrian_crossings() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.associated_pedestrian_crossings)
  return associated_pedestrian_crossings_;
}

// repeated .holo.map.proto.common.IdIntervalFloat64 associated_traffic_signs = 54;
inline int Lane::associated_traffic_signs_size() const {
  return associated_traffic_signs_.size();
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::mutable_associated_traffic_signs(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.associated_traffic_signs)
  return associated_traffic_signs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
Lane::mutable_associated_traffic_signs() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.associated_traffic_signs)
  return &associated_traffic_signs_;
}
inline const ::holo::map::proto::common::IdIntervalFloat64& Lane::associated_traffic_signs(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.associated_traffic_signs)
  return associated_traffic_signs_.Get(index);
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::add_associated_traffic_signs() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.associated_traffic_signs)
  return associated_traffic_signs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
Lane::associated_traffic_signs() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.associated_traffic_signs)
  return associated_traffic_signs_;
}

// repeated .holo.map.proto.common.IdIntervalFloat64 associated_quasi_poles = 55;
inline int Lane::associated_quasi_poles_size() const {
  return associated_quasi_poles_.size();
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::mutable_associated_quasi_poles(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.associated_quasi_poles)
  return associated_quasi_poles_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >*
Lane::mutable_associated_quasi_poles() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.associated_quasi_poles)
  return &associated_quasi_poles_;
}
inline const ::holo::map::proto::common::IdIntervalFloat64& Lane::associated_quasi_poles(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.associated_quasi_poles)
  return associated_quasi_poles_.Get(index);
}
inline ::holo::map::proto::common::IdIntervalFloat64* Lane::add_associated_quasi_poles() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.associated_quasi_poles)
  return associated_quasi_poles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::IdIntervalFloat64 >&
Lane::associated_quasi_poles() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.associated_quasi_poles)
  return associated_quasi_poles_;
}

// optional uint64 object_parking_lot_id = 56;
inline bool Lane::has_object_parking_lot_id() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void Lane::set_has_object_parking_lot_id() {
  _has_bits_[0] |= 0x00800000u;
}
inline void Lane::clear_has_object_parking_lot_id() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void Lane::clear_object_parking_lot_id() {
  object_parking_lot_id_ = GOOGLE_ULONGLONG(0);
  clear_has_object_parking_lot_id();
}
inline ::google::protobuf::uint64 Lane::object_parking_lot_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.object_parking_lot_id)
  return object_parking_lot_id_;
}
inline void Lane::set_object_parking_lot_id(::google::protobuf::uint64 value) {
  set_has_object_parking_lot_id();
  object_parking_lot_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.object_parking_lot_id)
}

// optional uint64 object_parking_floor_id = 57;
inline bool Lane::has_object_parking_floor_id() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void Lane::set_has_object_parking_floor_id() {
  _has_bits_[0] |= 0x01000000u;
}
inline void Lane::clear_has_object_parking_floor_id() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void Lane::clear_object_parking_floor_id() {
  object_parking_floor_id_ = GOOGLE_ULONGLONG(0);
  clear_has_object_parking_floor_id();
}
inline ::google::protobuf::uint64 Lane::object_parking_floor_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.object_parking_floor_id)
  return object_parking_floor_id_;
}
inline void Lane::set_object_parking_floor_id(::google::protobuf::uint64 value) {
  set_has_object_parking_floor_id();
  object_parking_floor_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.object_parking_floor_id)
}

// optional .holo.map.proto.common.Coordinate coordinate = 60;
inline bool Lane::has_coordinate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lane::set_has_coordinate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lane::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::holo::map::proto::common::Coordinate& Lane::_internal_coordinate() const {
  return *coordinate_;
}
inline const ::holo::map::proto::common::Coordinate& Lane::coordinate() const {
  const ::holo::map::proto::common::Coordinate* p = coordinate_;
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.coordinate)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::proto::common::Coordinate*>(
      &::holo::map::proto::common::_Coordinate_default_instance_);
}
inline ::holo::map::proto::common::Coordinate* Lane::release_coordinate() {
  // @@protoc_insertion_point(field_release:holo.map.proto.base.Lane.coordinate)
  clear_has_coordinate();
  ::holo::map::proto::common::Coordinate* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline ::holo::map::proto::common::Coordinate* Lane::mutable_coordinate() {
  set_has_coordinate();
  if (coordinate_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::proto::common::Coordinate>(GetArenaNoVirtual());
    coordinate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.coordinate)
  return coordinate_;
}
inline void Lane::set_allocated_coordinate(::holo::map::proto::common::Coordinate* coordinate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(coordinate_);
  }
  if (coordinate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      coordinate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    set_has_coordinate();
  } else {
    clear_has_coordinate();
  }
  coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:holo.map.proto.base.Lane.coordinate)
}

// optional uint32 zone_id = 61;
inline bool Lane::has_zone_id() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void Lane::set_has_zone_id() {
  _has_bits_[0] |= 0x00200000u;
}
inline void Lane::clear_has_zone_id() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void Lane::clear_zone_id() {
  zone_id_ = 0u;
  clear_has_zone_id();
}
inline ::google::protobuf::uint32 Lane::zone_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.zone_id)
  return zone_id_;
}
inline void Lane::set_zone_id(::google::protobuf::uint32 value) {
  set_has_zone_id();
  zone_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.zone_id)
}

// optional uint32 extra_zone_id = 62;
inline bool Lane::has_extra_zone_id() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void Lane::set_has_extra_zone_id() {
  _has_bits_[0] |= 0x00400000u;
}
inline void Lane::clear_has_extra_zone_id() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void Lane::clear_extra_zone_id() {
  extra_zone_id_ = 0u;
  clear_has_extra_zone_id();
}
inline ::google::protobuf::uint32 Lane::extra_zone_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.extra_zone_id)
  return extra_zone_id_;
}
inline void Lane::set_extra_zone_id(::google::protobuf::uint32 value) {
  set_has_extra_zone_id();
  extra_zone_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.extra_zone_id)
}

// optional bool south_flag = 63;
inline bool Lane::has_south_flag() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void Lane::set_has_south_flag() {
  _has_bits_[0] |= 0x00100000u;
}
inline void Lane::clear_has_south_flag() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void Lane::clear_south_flag() {
  south_flag_ = false;
  clear_has_south_flag();
}
inline bool Lane::south_flag() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.south_flag)
  return south_flag_;
}
inline void Lane::set_south_flag(bool value) {
  set_has_south_flag();
  south_flag_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.Lane.south_flag)
}

// optional .holo.map.proto.common.GeoBox region = 64;
inline bool Lane::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lane::set_has_region() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lane::clear_has_region() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::holo::map::proto::common::GeoBox& Lane::_internal_region() const {
  return *region_;
}
inline const ::holo::map::proto::common::GeoBox& Lane::region() const {
  const ::holo::map::proto::common::GeoBox* p = region_;
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.region)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::proto::common::GeoBox*>(
      &::holo::map::proto::common::_GeoBox_default_instance_);
}
inline ::holo::map::proto::common::GeoBox* Lane::release_region() {
  // @@protoc_insertion_point(field_release:holo.map.proto.base.Lane.region)
  clear_has_region();
  ::holo::map::proto::common::GeoBox* temp = region_;
  region_ = NULL;
  return temp;
}
inline ::holo::map::proto::common::GeoBox* Lane::mutable_region() {
  set_has_region();
  if (region_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::proto::common::GeoBox>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.region)
  return region_;
}
inline void Lane::set_allocated_region(::holo::map::proto::common::GeoBox* region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_);
  }
  if (region) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    set_has_region();
  } else {
    clear_has_region();
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:holo.map.proto.base.Lane.region)
}

// map<uint32, .holo.map.proto.common.GeoBox> extra_region = 65;
inline int Lane::extra_region_size() const {
  return extra_region_.size();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox >&
Lane::extra_region() const {
  // @@protoc_insertion_point(field_map:holo.map.proto.base.Lane.extra_region)
  return extra_region_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox >*
Lane::mutable_extra_region() {
  // @@protoc_insertion_point(field_mutable_map:holo.map.proto.base.Lane.extra_region)
  return extra_region_.MutableMap();
}

// repeated .holo.map.proto.common.GeoPoint geometry_points = 66;
inline int Lane::geometry_points_size() const {
  return geometry_points_.size();
}
inline ::holo::map::proto::common::GeoPoint* Lane::mutable_geometry_points(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.Lane.geometry_points)
  return geometry_points_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoPoint >*
Lane::mutable_geometry_points() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.Lane.geometry_points)
  return &geometry_points_;
}
inline const ::holo::map::proto::common::GeoPoint& Lane::geometry_points(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.Lane.geometry_points)
  return geometry_points_.Get(index);
}
inline ::holo::map::proto::common::GeoPoint* Lane::add_geometry_points() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.Lane.geometry_points)
  return geometry_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoPoint >&
Lane::geometry_points() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.Lane.geometry_points)
  return geometry_points_;
}

// map<uint32, .holo.map.proto.common.GeoLine> extra_geometry_points = 67;
inline int Lane::extra_geometry_points_size() const {
  return extra_geometry_points_.size();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoLine >&
Lane::extra_geometry_points() const {
  // @@protoc_insertion_point(field_map:holo.map.proto.base.Lane.extra_geometry_points)
  return extra_geometry_points_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoLine >*
Lane::mutable_extra_geometry_points() {
  // @@protoc_insertion_point(field_mutable_map:holo.map.proto.base.Lane.extra_geometry_points)
  return extra_geometry_points_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace base
}  // namespace proto
}  // namespace map
}  // namespace holo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::holo::map::proto::base::Lane_LaneDir> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::Lane_LaneDir>() {
  return ::holo::map::proto::base::Lane_LaneDir_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::Lane_LaneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::Lane_LaneType>() {
  return ::holo::map::proto::base::Lane_LaneType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::Lane_TurnType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::Lane_TurnType>() {
  return ::holo::map::proto::base::Lane_TurnType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::Lane_TranType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::Lane_TranType>() {
  return ::holo::map::proto::base::Lane_TranType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fbase_2flane_2eproto
