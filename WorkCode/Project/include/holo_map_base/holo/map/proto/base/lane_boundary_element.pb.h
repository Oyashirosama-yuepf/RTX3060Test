// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: holo/map/proto/base/lane_boundary_element.proto

#ifndef PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fbase_2flane_5fboundary_5felement_2eproto
#define PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fbase_2flane_5fboundary_5felement_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_holo_2fmap_2fproto_2fbase_2flane_5fboundary_5felement_2eproto 

namespace protobuf_holo_2fmap_2fproto_2fbase_2flane_5fboundary_5felement_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[1];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_holo_2fmap_2fproto_2fbase_2flane_5fboundary_5felement_2eproto
namespace holo {
namespace map {
namespace proto {
namespace base {
class LaneBoundaryElement;
class LaneBoundaryElementDefaultTypeInternal;
extern LaneBoundaryElementDefaultTypeInternal _LaneBoundaryElement_default_instance_;
}  // namespace base
}  // namespace proto
}  // namespace map
}  // namespace holo
namespace google {
namespace protobuf {
template<> ::holo::map::proto::base::LaneBoundaryElement* Arena::CreateMaybeMessage<::holo::map::proto::base::LaneBoundaryElement>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace holo {
namespace map {
namespace proto {
namespace base {

enum LaneBoundaryElement_BoundaryType {
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_UNKNOWN = 0,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_LONG_DASHED_LINE = 1,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DOUBLE_SOLID_LINE = 2,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SINGLE_SOLID_LINE = 3,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SOLID_LINE_DASHED_LINE = 4,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DASHED_LINE_SOLID_LINE = 5,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SHORT_DASHED_LINE = 6,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SHADED_AREA_MARKING = 7,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DASHED_BLOCKS = 8,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DOUBLE_DASHED_LINE = 9,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_CROSSING_ALERT = 10,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_CURB = 11,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_WALL_FLAT = 12,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_WALL_TUNNEL = 13,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_BARRIER_JERSEY = 14,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_BARRIER_SOUND = 15,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_BARRIER_CABLE = 16,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_GUARDRAIL = 17,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_FENCE = 18,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_CURB_TRAVERSABLE = 19,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_END_OF_ROAD = 20,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_CLIFF = 21,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DITCH = 22,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_GORE = 23,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_WALKING_AREA = 24,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_OFFSET_SPACE = 25,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_NORMAL_FISH_BONE_LINE = 26,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SINGLE_DASHED_LINE = 27,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_OTHER_BARRIER = 30,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_NO_MARKING = 31,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_1 = 250,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_2 = 251,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_3 = 252,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_4 = 253,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_5 = 254,
  LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_OTHERS = 255
};
bool LaneBoundaryElement_BoundaryType_IsValid(int value);
const LaneBoundaryElement_BoundaryType LaneBoundaryElement_BoundaryType_BoundaryType_MIN = LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_UNKNOWN;
const LaneBoundaryElement_BoundaryType LaneBoundaryElement_BoundaryType_BoundaryType_MAX = LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_OTHERS;
const int LaneBoundaryElement_BoundaryType_BoundaryType_ARRAYSIZE = LaneBoundaryElement_BoundaryType_BoundaryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundaryElement_BoundaryType_descriptor();
inline const ::std::string& LaneBoundaryElement_BoundaryType_Name(LaneBoundaryElement_BoundaryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundaryElement_BoundaryType_descriptor(), value);
}
inline bool LaneBoundaryElement_BoundaryType_Parse(
    const ::std::string& name, LaneBoundaryElement_BoundaryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundaryElement_BoundaryType>(
    LaneBoundaryElement_BoundaryType_descriptor(), name, value);
}
enum LaneBoundaryElement_BoundaryMaterial {
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_UNKNOWN = 0,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_METAL = 1,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_CONCRETE = 2,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_STONE = 3,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_WOOD = 4,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_PLASTIC = 5,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_TRANSPARENT = 6,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_VIBRATION_MARKINGS = 7,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_PAINTED_VIBRATION_DIVIDER = 8,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_1 = 250,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_2 = 251,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_3 = 252,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_4 = 253,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_5 = 254,
  LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_OTHERS = 255
};
bool LaneBoundaryElement_BoundaryMaterial_IsValid(int value);
const LaneBoundaryElement_BoundaryMaterial LaneBoundaryElement_BoundaryMaterial_BoundaryMaterial_MIN = LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_UNKNOWN;
const LaneBoundaryElement_BoundaryMaterial LaneBoundaryElement_BoundaryMaterial_BoundaryMaterial_MAX = LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_OTHERS;
const int LaneBoundaryElement_BoundaryMaterial_BoundaryMaterial_ARRAYSIZE = LaneBoundaryElement_BoundaryMaterial_BoundaryMaterial_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundaryElement_BoundaryMaterial_descriptor();
inline const ::std::string& LaneBoundaryElement_BoundaryMaterial_Name(LaneBoundaryElement_BoundaryMaterial value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundaryElement_BoundaryMaterial_descriptor(), value);
}
inline bool LaneBoundaryElement_BoundaryMaterial_Parse(
    const ::std::string& name, LaneBoundaryElement_BoundaryMaterial* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundaryElement_BoundaryMaterial>(
    LaneBoundaryElement_BoundaryMaterial_descriptor(), name, value);
}
enum LaneBoundaryElement_BoundaryColor {
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_UNKNOWN = 0,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_LIGHT_GRAY = 1,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_GRAY = 2,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_DARK_GRAY = 3,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_BLACK = 4,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RED = 5,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_YELLOW = 6,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_GREEN = 7,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_CYAN = 8,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_BLUE = 9,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_ORANGE = 10,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_WHITE = 11,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_1 = 250,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_2 = 251,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_3 = 252,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_4 = 253,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_5 = 254,
  LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_OTHERS = 255
};
bool LaneBoundaryElement_BoundaryColor_IsValid(int value);
const LaneBoundaryElement_BoundaryColor LaneBoundaryElement_BoundaryColor_BoundaryColor_MIN = LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_UNKNOWN;
const LaneBoundaryElement_BoundaryColor LaneBoundaryElement_BoundaryColor_BoundaryColor_MAX = LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_OTHERS;
const int LaneBoundaryElement_BoundaryColor_BoundaryColor_ARRAYSIZE = LaneBoundaryElement_BoundaryColor_BoundaryColor_MAX + 1;

const ::google::protobuf::EnumDescriptor* LaneBoundaryElement_BoundaryColor_descriptor();
inline const ::std::string& LaneBoundaryElement_BoundaryColor_Name(LaneBoundaryElement_BoundaryColor value) {
  return ::google::protobuf::internal::NameOfEnum(
    LaneBoundaryElement_BoundaryColor_descriptor(), value);
}
inline bool LaneBoundaryElement_BoundaryColor_Parse(
    const ::std::string& name, LaneBoundaryElement_BoundaryColor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LaneBoundaryElement_BoundaryColor>(
    LaneBoundaryElement_BoundaryColor_descriptor(), name, value);
}
// ===================================================================

class LaneBoundaryElement : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.proto.base.LaneBoundaryElement) */ {
 public:
  LaneBoundaryElement();
  virtual ~LaneBoundaryElement();

  LaneBoundaryElement(const LaneBoundaryElement& from);

  inline LaneBoundaryElement& operator=(const LaneBoundaryElement& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LaneBoundaryElement(LaneBoundaryElement&& from) noexcept
    : LaneBoundaryElement() {
    *this = ::std::move(from);
  }

  inline LaneBoundaryElement& operator=(LaneBoundaryElement&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneBoundaryElement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LaneBoundaryElement* internal_default_instance() {
    return reinterpret_cast<const LaneBoundaryElement*>(
               &_LaneBoundaryElement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LaneBoundaryElement* other);
  friend void swap(LaneBoundaryElement& a, LaneBoundaryElement& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LaneBoundaryElement* New() const final {
    return CreateMaybeMessage<LaneBoundaryElement>(NULL);
  }

  LaneBoundaryElement* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LaneBoundaryElement>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LaneBoundaryElement& from);
  void MergeFrom(const LaneBoundaryElement& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LaneBoundaryElement* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LaneBoundaryElement_BoundaryType BoundaryType;
  static const BoundaryType BOUNDARY_TYPE_UNKNOWN =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_UNKNOWN;
  static const BoundaryType BOUNDARY_TYPE_LONG_DASHED_LINE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_LONG_DASHED_LINE;
  static const BoundaryType BOUNDARY_TYPE_DOUBLE_SOLID_LINE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DOUBLE_SOLID_LINE;
  static const BoundaryType BOUNDARY_TYPE_SINGLE_SOLID_LINE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SINGLE_SOLID_LINE;
  static const BoundaryType BOUNDARY_TYPE_SOLID_LINE_DASHED_LINE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SOLID_LINE_DASHED_LINE;
  static const BoundaryType BOUNDARY_TYPE_DASHED_LINE_SOLID_LINE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DASHED_LINE_SOLID_LINE;
  static const BoundaryType BOUNDARY_TYPE_SHORT_DASHED_LINE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SHORT_DASHED_LINE;
  static const BoundaryType BOUNDARY_TYPE_SHADED_AREA_MARKING =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SHADED_AREA_MARKING;
  static const BoundaryType BOUNDARY_TYPE_DASHED_BLOCKS =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DASHED_BLOCKS;
  static const BoundaryType BOUNDARY_TYPE_DOUBLE_DASHED_LINE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DOUBLE_DASHED_LINE;
  static const BoundaryType BOUNDARY_TYPE_CROSSING_ALERT =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_CROSSING_ALERT;
  static const BoundaryType BOUNDARY_TYPE_CURB =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_CURB;
  static const BoundaryType BOUNDARY_TYPE_WALL_FLAT =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_WALL_FLAT;
  static const BoundaryType BOUNDARY_TYPE_WALL_TUNNEL =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_WALL_TUNNEL;
  static const BoundaryType BOUNDARY_TYPE_BARRIER_JERSEY =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_BARRIER_JERSEY;
  static const BoundaryType BOUNDARY_TYPE_BARRIER_SOUND =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_BARRIER_SOUND;
  static const BoundaryType BOUNDARY_TYPE_BARRIER_CABLE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_BARRIER_CABLE;
  static const BoundaryType BOUNDARY_TYPE_GUARDRAIL =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_GUARDRAIL;
  static const BoundaryType BOUNDARY_TYPE_FENCE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_FENCE;
  static const BoundaryType BOUNDARY_TYPE_CURB_TRAVERSABLE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_CURB_TRAVERSABLE;
  static const BoundaryType BOUNDARY_TYPE_END_OF_ROAD =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_END_OF_ROAD;
  static const BoundaryType BOUNDARY_TYPE_CLIFF =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_CLIFF;
  static const BoundaryType BOUNDARY_TYPE_DITCH =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_DITCH;
  static const BoundaryType BOUNDARY_TYPE_GORE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_GORE;
  static const BoundaryType BOUNDARY_TYPE_WALKING_AREA =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_WALKING_AREA;
  static const BoundaryType BOUNDARY_TYPE_OFFSET_SPACE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_OFFSET_SPACE;
  static const BoundaryType BOUNDARY_TYPE_NORMAL_FISH_BONE_LINE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_NORMAL_FISH_BONE_LINE;
  static const BoundaryType BOUNDARY_TYPE_SINGLE_DASHED_LINE =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_SINGLE_DASHED_LINE;
  static const BoundaryType BOUNDARY_TYPE_OTHER_BARRIER =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_OTHER_BARRIER;
  static const BoundaryType BOUNDARY_TYPE_NO_MARKING =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_NO_MARKING;
  static const BoundaryType BOUNDARY_TYPE_RESERVED_1 =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_1;
  static const BoundaryType BOUNDARY_TYPE_RESERVED_2 =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_2;
  static const BoundaryType BOUNDARY_TYPE_RESERVED_3 =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_3;
  static const BoundaryType BOUNDARY_TYPE_RESERVED_4 =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_4;
  static const BoundaryType BOUNDARY_TYPE_RESERVED_5 =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_RESERVED_5;
  static const BoundaryType BOUNDARY_TYPE_OTHERS =
    LaneBoundaryElement_BoundaryType_BOUNDARY_TYPE_OTHERS;
  static inline bool BoundaryType_IsValid(int value) {
    return LaneBoundaryElement_BoundaryType_IsValid(value);
  }
  static const BoundaryType BoundaryType_MIN =
    LaneBoundaryElement_BoundaryType_BoundaryType_MIN;
  static const BoundaryType BoundaryType_MAX =
    LaneBoundaryElement_BoundaryType_BoundaryType_MAX;
  static const int BoundaryType_ARRAYSIZE =
    LaneBoundaryElement_BoundaryType_BoundaryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BoundaryType_descriptor() {
    return LaneBoundaryElement_BoundaryType_descriptor();
  }
  static inline const ::std::string& BoundaryType_Name(BoundaryType value) {
    return LaneBoundaryElement_BoundaryType_Name(value);
  }
  static inline bool BoundaryType_Parse(const ::std::string& name,
      BoundaryType* value) {
    return LaneBoundaryElement_BoundaryType_Parse(name, value);
  }

  typedef LaneBoundaryElement_BoundaryMaterial BoundaryMaterial;
  static const BoundaryMaterial BOUNDARY_MATERIAL_UNKNOWN =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_UNKNOWN;
  static const BoundaryMaterial BOUNDARY_MATERIAL_METAL =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_METAL;
  static const BoundaryMaterial BOUNDARY_MATERIAL_CONCRETE =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_CONCRETE;
  static const BoundaryMaterial BOUNDARY_MATERIAL_STONE =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_STONE;
  static const BoundaryMaterial BOUNDARY_MATERIAL_WOOD =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_WOOD;
  static const BoundaryMaterial BOUNDARY_MATERIAL_PLASTIC =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_PLASTIC;
  static const BoundaryMaterial BOUNDARY_MATERIAL_TRANSPARENT =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_TRANSPARENT;
  static const BoundaryMaterial BOUNDARY_MATERIAL_VIBRATION_MARKINGS =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_VIBRATION_MARKINGS;
  static const BoundaryMaterial BOUNDARY_MATERIAL_PAINTED_VIBRATION_DIVIDER =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_PAINTED_VIBRATION_DIVIDER;
  static const BoundaryMaterial BOUNDARY_MATERIAL_RESERVED_1 =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_1;
  static const BoundaryMaterial BOUNDARY_MATERIAL_RESERVED_2 =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_2;
  static const BoundaryMaterial BOUNDARY_MATERIAL_RESERVED_3 =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_3;
  static const BoundaryMaterial BOUNDARY_MATERIAL_RESERVED_4 =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_4;
  static const BoundaryMaterial BOUNDARY_MATERIAL_RESERVED_5 =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_RESERVED_5;
  static const BoundaryMaterial BOUNDARY_MATERIAL_OTHERS =
    LaneBoundaryElement_BoundaryMaterial_BOUNDARY_MATERIAL_OTHERS;
  static inline bool BoundaryMaterial_IsValid(int value) {
    return LaneBoundaryElement_BoundaryMaterial_IsValid(value);
  }
  static const BoundaryMaterial BoundaryMaterial_MIN =
    LaneBoundaryElement_BoundaryMaterial_BoundaryMaterial_MIN;
  static const BoundaryMaterial BoundaryMaterial_MAX =
    LaneBoundaryElement_BoundaryMaterial_BoundaryMaterial_MAX;
  static const int BoundaryMaterial_ARRAYSIZE =
    LaneBoundaryElement_BoundaryMaterial_BoundaryMaterial_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BoundaryMaterial_descriptor() {
    return LaneBoundaryElement_BoundaryMaterial_descriptor();
  }
  static inline const ::std::string& BoundaryMaterial_Name(BoundaryMaterial value) {
    return LaneBoundaryElement_BoundaryMaterial_Name(value);
  }
  static inline bool BoundaryMaterial_Parse(const ::std::string& name,
      BoundaryMaterial* value) {
    return LaneBoundaryElement_BoundaryMaterial_Parse(name, value);
  }

  typedef LaneBoundaryElement_BoundaryColor BoundaryColor;
  static const BoundaryColor BOUNDARY_COLOR_UNKNOWN =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_UNKNOWN;
  static const BoundaryColor BOUNDARY_COLOR_LIGHT_GRAY =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_LIGHT_GRAY;
  static const BoundaryColor BOUNDARY_COLOR_GRAY =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_GRAY;
  static const BoundaryColor BOUNDARY_COLOR_DARK_GRAY =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_DARK_GRAY;
  static const BoundaryColor BOUNDARY_COLOR_BLACK =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_BLACK;
  static const BoundaryColor BOUNDARY_COLOR_RED =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RED;
  static const BoundaryColor BOUNDARY_COLOR_YELLOW =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_YELLOW;
  static const BoundaryColor BOUNDARY_COLOR_GREEN =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_GREEN;
  static const BoundaryColor BOUNDARY_COLOR_CYAN =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_CYAN;
  static const BoundaryColor BOUNDARY_COLOR_BLUE =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_BLUE;
  static const BoundaryColor BOUNDARY_COLOR_ORANGE =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_ORANGE;
  static const BoundaryColor BOUNDARY_COLOR_WHITE =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_WHITE;
  static const BoundaryColor BOUNDARY_COLOR_RESERVED_1 =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_1;
  static const BoundaryColor BOUNDARY_COLOR_RESERVED_2 =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_2;
  static const BoundaryColor BOUNDARY_COLOR_RESERVED_3 =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_3;
  static const BoundaryColor BOUNDARY_COLOR_RESERVED_4 =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_4;
  static const BoundaryColor BOUNDARY_COLOR_RESERVED_5 =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_RESERVED_5;
  static const BoundaryColor BOUNDARY_COLOR_OTHERS =
    LaneBoundaryElement_BoundaryColor_BOUNDARY_COLOR_OTHERS;
  static inline bool BoundaryColor_IsValid(int value) {
    return LaneBoundaryElement_BoundaryColor_IsValid(value);
  }
  static const BoundaryColor BoundaryColor_MIN =
    LaneBoundaryElement_BoundaryColor_BoundaryColor_MIN;
  static const BoundaryColor BoundaryColor_MAX =
    LaneBoundaryElement_BoundaryColor_BoundaryColor_MAX;
  static const int BoundaryColor_ARRAYSIZE =
    LaneBoundaryElement_BoundaryColor_BoundaryColor_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  BoundaryColor_descriptor() {
    return LaneBoundaryElement_BoundaryColor_descriptor();
  }
  static inline const ::std::string& BoundaryColor_Name(BoundaryColor value) {
    return LaneBoundaryElement_BoundaryColor_Name(value);
  }
  static inline bool BoundaryColor_Parse(const ::std::string& name,
      BoundaryColor* value) {
    return LaneBoundaryElement_BoundaryColor_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double start_pos = 1;
  bool has_start_pos() const;
  void clear_start_pos();
  static const int kStartPosFieldNumber = 1;
  double start_pos() const;
  void set_start_pos(double value);

  // optional double end_pos = 2;
  bool has_end_pos() const;
  void clear_end_pos();
  static const int kEndPosFieldNumber = 2;
  double end_pos() const;
  void set_end_pos(double value);

  // optional .holo.map.proto.base.LaneBoundaryElement.BoundaryType boundary_type = 3;
  bool has_boundary_type() const;
  void clear_boundary_type();
  static const int kBoundaryTypeFieldNumber = 3;
  ::holo::map::proto::base::LaneBoundaryElement_BoundaryType boundary_type() const;
  void set_boundary_type(::holo::map::proto::base::LaneBoundaryElement_BoundaryType value);

  // optional .holo.map.proto.base.LaneBoundaryElement.BoundaryMaterial boundary_material = 4;
  bool has_boundary_material() const;
  void clear_boundary_material();
  static const int kBoundaryMaterialFieldNumber = 4;
  ::holo::map::proto::base::LaneBoundaryElement_BoundaryMaterial boundary_material() const;
  void set_boundary_material(::holo::map::proto::base::LaneBoundaryElement_BoundaryMaterial value);

  // optional .holo.map.proto.base.LaneBoundaryElement.BoundaryColor boundary_color = 5;
  bool has_boundary_color() const;
  void clear_boundary_color();
  static const int kBoundaryColorFieldNumber = 5;
  ::holo::map::proto::base::LaneBoundaryElement_BoundaryColor boundary_color() const;
  void set_boundary_color(::holo::map::proto::base::LaneBoundaryElement_BoundaryColor value);

  // optional uint32 width_cm = 6;
  bool has_width_cm() const;
  void clear_width_cm();
  static const int kWidthCmFieldNumber = 6;
  ::google::protobuf::uint32 width_cm() const;
  void set_width_cm(::google::protobuf::uint32 value);

  // optional bool is_open_to_curb_side = 7;
  bool has_is_open_to_curb_side() const;
  void clear_is_open_to_curb_side();
  static const int kIsOpenToCurbSideFieldNumber = 7;
  bool is_open_to_curb_side() const;
  void set_is_open_to_curb_side(bool value);

  // optional bool is_open_to_middle_side = 8;
  bool has_is_open_to_middle_side() const;
  void clear_is_open_to_middle_side();
  static const int kIsOpenToMiddleSideFieldNumber = 8;
  bool is_open_to_middle_side() const;
  void set_is_open_to_middle_side(bool value);

  // optional uint32 boundary_info_index = 10;
  bool has_boundary_info_index() const;
  void clear_boundary_info_index();
  static const int kBoundaryInfoIndexFieldNumber = 10;
  ::google::protobuf::uint32 boundary_info_index() const;
  void set_boundary_info_index(::google::protobuf::uint32 value);

  // optional uint64 lane_boundary_id = 9;
  bool has_lane_boundary_id() const;
  void clear_lane_boundary_id();
  static const int kLaneBoundaryIdFieldNumber = 9;
  ::google::protobuf::uint64 lane_boundary_id() const;
  void set_lane_boundary_id(::google::protobuf::uint64 value);

  // optional uint32 boundary_vertical_offset_cm = 11;
  bool has_boundary_vertical_offset_cm() const;
  void clear_boundary_vertical_offset_cm();
  static const int kBoundaryVerticalOffsetCmFieldNumber = 11;
  ::google::protobuf::uint32 boundary_vertical_offset_cm() const;
  void set_boundary_vertical_offset_cm(::google::protobuf::uint32 value);

  // optional uint32 length_cm = 12;
  bool has_length_cm() const;
  void clear_length_cm();
  static const int kLengthCmFieldNumber = 12;
  ::google::protobuf::uint32 length_cm() const;
  void set_length_cm(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.proto.base.LaneBoundaryElement)
 private:
  void set_has_start_pos();
  void clear_has_start_pos();
  void set_has_end_pos();
  void clear_has_end_pos();
  void set_has_boundary_type();
  void clear_has_boundary_type();
  void set_has_boundary_material();
  void clear_has_boundary_material();
  void set_has_boundary_color();
  void clear_has_boundary_color();
  void set_has_width_cm();
  void clear_has_width_cm();
  void set_has_is_open_to_curb_side();
  void clear_has_is_open_to_curb_side();
  void set_has_is_open_to_middle_side();
  void clear_has_is_open_to_middle_side();
  void set_has_lane_boundary_id();
  void clear_has_lane_boundary_id();
  void set_has_boundary_info_index();
  void clear_has_boundary_info_index();
  void set_has_boundary_vertical_offset_cm();
  void clear_has_boundary_vertical_offset_cm();
  void set_has_length_cm();
  void clear_has_length_cm();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double start_pos_;
  double end_pos_;
  int boundary_type_;
  int boundary_material_;
  int boundary_color_;
  ::google::protobuf::uint32 width_cm_;
  bool is_open_to_curb_side_;
  bool is_open_to_middle_side_;
  ::google::protobuf::uint32 boundary_info_index_;
  ::google::protobuf::uint64 lane_boundary_id_;
  ::google::protobuf::uint32 boundary_vertical_offset_cm_;
  ::google::protobuf::uint32 length_cm_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fbase_2flane_5fboundary_5felement_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LaneBoundaryElement

// optional double start_pos = 1;
inline bool LaneBoundaryElement::has_start_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneBoundaryElement::set_has_start_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneBoundaryElement::clear_has_start_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneBoundaryElement::clear_start_pos() {
  start_pos_ = 0;
  clear_has_start_pos();
}
inline double LaneBoundaryElement::start_pos() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.start_pos)
  return start_pos_;
}
inline void LaneBoundaryElement::set_start_pos(double value) {
  set_has_start_pos();
  start_pos_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.start_pos)
}

// optional double end_pos = 2;
inline bool LaneBoundaryElement::has_end_pos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneBoundaryElement::set_has_end_pos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneBoundaryElement::clear_has_end_pos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneBoundaryElement::clear_end_pos() {
  end_pos_ = 0;
  clear_has_end_pos();
}
inline double LaneBoundaryElement::end_pos() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.end_pos)
  return end_pos_;
}
inline void LaneBoundaryElement::set_end_pos(double value) {
  set_has_end_pos();
  end_pos_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.end_pos)
}

// optional .holo.map.proto.base.LaneBoundaryElement.BoundaryType boundary_type = 3;
inline bool LaneBoundaryElement::has_boundary_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneBoundaryElement::set_has_boundary_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneBoundaryElement::clear_has_boundary_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneBoundaryElement::clear_boundary_type() {
  boundary_type_ = 0;
  clear_has_boundary_type();
}
inline ::holo::map::proto::base::LaneBoundaryElement_BoundaryType LaneBoundaryElement::boundary_type() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.boundary_type)
  return static_cast< ::holo::map::proto::base::LaneBoundaryElement_BoundaryType >(boundary_type_);
}
inline void LaneBoundaryElement::set_boundary_type(::holo::map::proto::base::LaneBoundaryElement_BoundaryType value) {
  assert(::holo::map::proto::base::LaneBoundaryElement_BoundaryType_IsValid(value));
  set_has_boundary_type();
  boundary_type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.boundary_type)
}

// optional .holo.map.proto.base.LaneBoundaryElement.BoundaryMaterial boundary_material = 4;
inline bool LaneBoundaryElement::has_boundary_material() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneBoundaryElement::set_has_boundary_material() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneBoundaryElement::clear_has_boundary_material() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneBoundaryElement::clear_boundary_material() {
  boundary_material_ = 0;
  clear_has_boundary_material();
}
inline ::holo::map::proto::base::LaneBoundaryElement_BoundaryMaterial LaneBoundaryElement::boundary_material() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.boundary_material)
  return static_cast< ::holo::map::proto::base::LaneBoundaryElement_BoundaryMaterial >(boundary_material_);
}
inline void LaneBoundaryElement::set_boundary_material(::holo::map::proto::base::LaneBoundaryElement_BoundaryMaterial value) {
  assert(::holo::map::proto::base::LaneBoundaryElement_BoundaryMaterial_IsValid(value));
  set_has_boundary_material();
  boundary_material_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.boundary_material)
}

// optional .holo.map.proto.base.LaneBoundaryElement.BoundaryColor boundary_color = 5;
inline bool LaneBoundaryElement::has_boundary_color() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LaneBoundaryElement::set_has_boundary_color() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LaneBoundaryElement::clear_has_boundary_color() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LaneBoundaryElement::clear_boundary_color() {
  boundary_color_ = 0;
  clear_has_boundary_color();
}
inline ::holo::map::proto::base::LaneBoundaryElement_BoundaryColor LaneBoundaryElement::boundary_color() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.boundary_color)
  return static_cast< ::holo::map::proto::base::LaneBoundaryElement_BoundaryColor >(boundary_color_);
}
inline void LaneBoundaryElement::set_boundary_color(::holo::map::proto::base::LaneBoundaryElement_BoundaryColor value) {
  assert(::holo::map::proto::base::LaneBoundaryElement_BoundaryColor_IsValid(value));
  set_has_boundary_color();
  boundary_color_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.boundary_color)
}

// optional uint32 width_cm = 6;
inline bool LaneBoundaryElement::has_width_cm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LaneBoundaryElement::set_has_width_cm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LaneBoundaryElement::clear_has_width_cm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LaneBoundaryElement::clear_width_cm() {
  width_cm_ = 0u;
  clear_has_width_cm();
}
inline ::google::protobuf::uint32 LaneBoundaryElement::width_cm() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.width_cm)
  return width_cm_;
}
inline void LaneBoundaryElement::set_width_cm(::google::protobuf::uint32 value) {
  set_has_width_cm();
  width_cm_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.width_cm)
}

// optional bool is_open_to_curb_side = 7;
inline bool LaneBoundaryElement::has_is_open_to_curb_side() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LaneBoundaryElement::set_has_is_open_to_curb_side() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LaneBoundaryElement::clear_has_is_open_to_curb_side() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LaneBoundaryElement::clear_is_open_to_curb_side() {
  is_open_to_curb_side_ = false;
  clear_has_is_open_to_curb_side();
}
inline bool LaneBoundaryElement::is_open_to_curb_side() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.is_open_to_curb_side)
  return is_open_to_curb_side_;
}
inline void LaneBoundaryElement::set_is_open_to_curb_side(bool value) {
  set_has_is_open_to_curb_side();
  is_open_to_curb_side_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.is_open_to_curb_side)
}

// optional bool is_open_to_middle_side = 8;
inline bool LaneBoundaryElement::has_is_open_to_middle_side() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LaneBoundaryElement::set_has_is_open_to_middle_side() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LaneBoundaryElement::clear_has_is_open_to_middle_side() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LaneBoundaryElement::clear_is_open_to_middle_side() {
  is_open_to_middle_side_ = false;
  clear_has_is_open_to_middle_side();
}
inline bool LaneBoundaryElement::is_open_to_middle_side() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.is_open_to_middle_side)
  return is_open_to_middle_side_;
}
inline void LaneBoundaryElement::set_is_open_to_middle_side(bool value) {
  set_has_is_open_to_middle_side();
  is_open_to_middle_side_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.is_open_to_middle_side)
}

// optional uint64 lane_boundary_id = 9;
inline bool LaneBoundaryElement::has_lane_boundary_id() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LaneBoundaryElement::set_has_lane_boundary_id() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LaneBoundaryElement::clear_has_lane_boundary_id() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LaneBoundaryElement::clear_lane_boundary_id() {
  lane_boundary_id_ = GOOGLE_ULONGLONG(0);
  clear_has_lane_boundary_id();
}
inline ::google::protobuf::uint64 LaneBoundaryElement::lane_boundary_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.lane_boundary_id)
  return lane_boundary_id_;
}
inline void LaneBoundaryElement::set_lane_boundary_id(::google::protobuf::uint64 value) {
  set_has_lane_boundary_id();
  lane_boundary_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.lane_boundary_id)
}

// optional uint32 boundary_info_index = 10;
inline bool LaneBoundaryElement::has_boundary_info_index() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LaneBoundaryElement::set_has_boundary_info_index() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LaneBoundaryElement::clear_has_boundary_info_index() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LaneBoundaryElement::clear_boundary_info_index() {
  boundary_info_index_ = 0u;
  clear_has_boundary_info_index();
}
inline ::google::protobuf::uint32 LaneBoundaryElement::boundary_info_index() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.boundary_info_index)
  return boundary_info_index_;
}
inline void LaneBoundaryElement::set_boundary_info_index(::google::protobuf::uint32 value) {
  set_has_boundary_info_index();
  boundary_info_index_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.boundary_info_index)
}

// optional uint32 boundary_vertical_offset_cm = 11;
inline bool LaneBoundaryElement::has_boundary_vertical_offset_cm() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LaneBoundaryElement::set_has_boundary_vertical_offset_cm() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LaneBoundaryElement::clear_has_boundary_vertical_offset_cm() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LaneBoundaryElement::clear_boundary_vertical_offset_cm() {
  boundary_vertical_offset_cm_ = 0u;
  clear_has_boundary_vertical_offset_cm();
}
inline ::google::protobuf::uint32 LaneBoundaryElement::boundary_vertical_offset_cm() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.boundary_vertical_offset_cm)
  return boundary_vertical_offset_cm_;
}
inline void LaneBoundaryElement::set_boundary_vertical_offset_cm(::google::protobuf::uint32 value) {
  set_has_boundary_vertical_offset_cm();
  boundary_vertical_offset_cm_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.boundary_vertical_offset_cm)
}

// optional uint32 length_cm = 12;
inline bool LaneBoundaryElement::has_length_cm() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LaneBoundaryElement::set_has_length_cm() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LaneBoundaryElement::clear_has_length_cm() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LaneBoundaryElement::clear_length_cm() {
  length_cm_ = 0u;
  clear_has_length_cm();
}
inline ::google::protobuf::uint32 LaneBoundaryElement::length_cm() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.LaneBoundaryElement.length_cm)
  return length_cm_;
}
inline void LaneBoundaryElement::set_length_cm(::google::protobuf::uint32 value) {
  set_has_length_cm();
  length_cm_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.LaneBoundaryElement.length_cm)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace base
}  // namespace proto
}  // namespace map
}  // namespace holo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::holo::map::proto::base::LaneBoundaryElement_BoundaryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::LaneBoundaryElement_BoundaryType>() {
  return ::holo::map::proto::base::LaneBoundaryElement_BoundaryType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::LaneBoundaryElement_BoundaryMaterial> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::LaneBoundaryElement_BoundaryMaterial>() {
  return ::holo::map::proto::base::LaneBoundaryElement_BoundaryMaterial_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::LaneBoundaryElement_BoundaryColor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::LaneBoundaryElement_BoundaryColor>() {
  return ::holo::map::proto::base::LaneBoundaryElement_BoundaryColor_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fbase_2flane_5fboundary_5felement_2eproto
