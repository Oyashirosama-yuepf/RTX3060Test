/*
 * Copyright (C) HoloMatic Technology(Beijing) Co., Ltd. - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 */

/**
 * @file io.hpp
 * @brief This header file defines implementation of point cloud io
 * @author luopei(luopei@holomaitc.com)
 * @author mengzhili(mengzhili@holomaitc.com)
 * @date 2020-10-15
 */

#ifndef HOLO_3D_COMMON_IO_HPP_
#define HOLO_3D_COMMON_IO_HPP_

#include <fstream>

#include <holo/log/hololog.h>
#include <rply/rply.h>

#include <holo/3d/common/point_field.h>
#include <holo/geometry/pose3.h>
#include <holo/geometry/quaternion.h>

namespace holo
{
namespace pointcloud
{
namespace internal
{
using HoloType = holo::pointcloud::PointField::Type;

/**
 * @brief Convert HoloType to ply type
 *
 * @param[in] type HoloType
 * @return e_ply_type
 */
e_ply_type GetRplyType(HoloType type)
{
    switch (type)
    {
        case HoloType::UINT8:
            return PLY_UINT8;
        case HoloType::INT8:
            return PLY_INT8;
        case HoloType::UINT16:
            return PLY_UINT16;
        case HoloType::INT16:
            return PLY_INT16;
        case HoloType::UINT32:
            return PLY_UINT32;
        case HoloType::INT32:
            return PLY_INT32;
        case HoloType::FLOAT32:
            return PLY_FLOAT32;
        case HoloType::FLOAT64:
            return PLY_FLOAT64;
        case HoloType::TIMESTAMP:
            return PLY_FLOAT64;
        default:
            std::string msg = "unknown data type";
            LOG(ERROR) << msg;
            throw exception::OutOfRangeException(msg);
    }
}

/**
 * @brief write ply element info
 *
 * @tparam PointT
 * @param[in] oply pointer to ply object
 * @param[in] num_elements number of vertex
 * @return true if write ply element info success
 * @return false if write ply element info fail
 */
template <typename PointT>
bool WritePlyElementInfo(p_ply oply, size_t const& num_elements)
{
    GetFields<PointT>       get_field;
    std::vector<PointField> fields = get_field();

    if (!ply_add_element(oply, "vertex", num_elements))
    {
        std::string msg = "ply_add_element failed";
        LOG(ERROR) << msg;
        return false;
    }

    for (size_t i = 0U; i < fields.size(); ++i)
    {
        if (!ply_add_scalar_property(oply, fields[i].GetName().c_str(), GetRplyType(fields[i].GetType())))
        {
            std::string msg = "ply_add_scalar_property failed";
            LOG(ERROR) << msg;
            return false;
        }
    }

    return true;
}

/**
 * @brief Write ply header info
 *
 * @tparam PointT
 * @param[in] oply point to ply object
 * @param[in] cloud point cloud to write
 * @return true if write ply header success
 * @return false if write ply header fail
 */
template <typename PointT>
bool WritePlyHeader(p_ply oply, PointCloudT<PointT> const& cloud)
{
    // write comments
    if (!ply_add_comment(oply, "Generated by HOLO 3D library."))
    {
        std::string msg = "ply_add_comment failed";
        LOG(ERROR) << msg;
        return false;
    }

    common::Coordinate coord = cloud.GetCoordinate();

    // write coord info
    if (!ply_add_obj_info(oply, ("coord " + std::to_string(static_cast<uint32_t>(coord))).c_str()))
    {
        std::string msg = "ply_add_obj_info failed";
        LOG(ERROR) << msg;
        return false;
    }

    // write timestamp info
    common::Timestamp const& t = cloud.GetTimestamp();

    std::string time_info = "timestamp " + std::to_string(t.GetSec()) + " " + std::to_string(t.GetNsec());

    if (!ply_add_obj_info(oply, time_info.c_str()))
    {
        std::string msg = "ply_add_obj_info failed";
        LOG(ERROR) << msg;
        return false;
    }

    // write size info
    size_t w = cloud.GetWidth();
    size_t h = cloud.GetHeight();

    if (!ply_add_obj_info(oply, (std::string("size ") + std::to_string(w) + " " + std::to_string(h)).c_str()))
    {
        std::string msg = "ply_add_obj_info failed";
        LOG(ERROR) << msg;
        return false;
    }

    bool is_dense = cloud.IsDense();
    // write dense flag
    if (!ply_add_obj_info(oply, (std::string("dense ") + std::to_string(static_cast<int32_t>(is_dense))).c_str()))
    {
        std::string msg = "ply_add_obj_info failed";
        LOG(ERROR) << msg;
        return false;
    }

    // write pose info in format qw qx qy qz x y z
    using Scalar         = typename PointT::ScalarType;
    using Pose3Type      = holo::geometry::Pose3T<Scalar>;
    using Rot3Type       = holo::geometry::Rot3T<Scalar>;
    using QuaternionType = holo::geometry::QuaternionT<Scalar>;
    Pose3Type pose       = cloud.GetPose();
    Scalar    x          = pose.GetX();
    Scalar    y          = pose.GetY();
    Scalar    z          = pose.GetZ();
    Rot3Type  rot        = pose.GetRotation();

    QuaternionType q(rot.ToMatrix());

    std::string pose_info = "pose " + std::to_string(q.GetW()) + " " + std::to_string(q.GetX()) + " " +
                            std::to_string(q.GetY()) + " " + std::to_string(q.GetZ()) + " " + std::to_string(x) + " " +
                            std::to_string(y) + " " + std::to_string(z);

    if (!ply_add_obj_info(oply, pose_info.c_str()))
    {
        std::string msg = "ply_add_obj_info failed";
        LOG(ERROR) << msg;
        return false;
    }

    WritePlyElementInfo<PointT>(oply, cloud.size());

    if (!ply_write_header(oply))
    {
        std::string msg = "ply_add_obj_info failed";
        LOG(ERROR) << msg;
        return false;
    }

    return true;
}

/**
 * @brief Internal write ply function
 *
 * @tparam PointT
 * @param[in] oply pointer to ply object
 * @param[in] cloud point cloud to write
 * @return true if write ply success
 * @return false if write ply fail
 */
template <typename PointT>
bool WritePlyInternal(p_ply oply, PointCloudT<PointT> const& cloud)
{
    if (!WritePlyHeader(oply, cloud))
    {
        std::string msg = "write ply header failed";
        LOG(ERROR) << msg;
        return false;
    }

    GetFields<PointT>       get_field;
    std::vector<PointField> fields = get_field();

    for (size_t i = 0U; i < cloud.size(); ++i)
    {
        PointT const& p = cloud[i];

        for (size_t j = 0U; j < fields.size(); ++j)
        {
            PointField const& f = fields[j];

            switch (f.GetType())
            {
                case HoloType::UINT8:
                    uint8_t v_8u;
                    GetFieldValue<PointT, uint8_t>(p, f, v_8u);

                    if (!ply_write(oply, static_cast<float64_t>(v_8u)))
                    {
                        return false;
                    }

                    break;
                case HoloType::INT8:
                    int8_t v_8s;
                    GetFieldValue<PointT, int8_t>(p, f, v_8s);

                    if (!ply_write(oply, static_cast<float64_t>(v_8s)))
                    {
                        return false;
                    }

                    break;
                case HoloType::UINT16:
                    uint16_t v_16u;
                    GetFieldValue<PointT, uint16_t>(p, f, v_16u);

                    if (!ply_write(oply, static_cast<float64_t>(v_16u)))
                    {
                        return false;
                    }

                    break;
                case HoloType::INT16:
                    int16_t v_16s;
                    GetFieldValue<PointT, int16_t>(p, f, v_16s);

                    if (!ply_write(oply, static_cast<float64_t>(v_16s)))
                    {
                        return false;
                    }

                    break;
                case HoloType::UINT32:
                    uint32_t v_32u;
                    GetFieldValue<PointT, uint32_t>(p, f, v_32u);

                    if (!ply_write(oply, static_cast<float64_t>(v_32u)))
                    {
                        return false;
                    }

                    break;
                case HoloType::INT32:
                    int32_t v_32s;
                    GetFieldValue<PointT, int32_t>(p, f, v_32s);

                    if (!ply_write(oply, static_cast<float64_t>(v_32s)))
                    {
                        return false;
                    }

                    break;
                case HoloType::FLOAT32:
                    float32_t v_32f;
                    GetFieldValue<PointT, float32_t>(p, f, v_32f);

                    if (!ply_write(oply, static_cast<float64_t>(v_32f)))
                    {
                        return false;
                    }

                    break;
                case HoloType::FLOAT64:
                    float64_t v_64f;
                    GetFieldValue<PointT, float64_t>(p, f, v_64f);

                    if (!ply_write(oply, v_64f))
                    {
                        return false;
                    }

                    break;
                case HoloType::TIMESTAMP: {
                    common::Timestamp stamp;
                    GetFieldValue<PointT, common::Timestamp>(p, f, stamp);

                    if (!ply_write(oply, stamp.ToSec()))
                    {
                        return false;
                    }

                    break;
                }
                default:
                    std::string msg = "unknown data type";
                    LOG(ERROR) << msg;
                    return false;
            }
        }
    }

    return true;
}

/**
 * @brief Read ply header info
 *
 * @tparam PointT
 * @param[in] ply pointer to ply object
 * @param[in] cloud point cloud
 * @return true
 * @return false
 */
template <typename PointT>
bool ReadPlyHeader(p_ply ply, PointCloudT<PointT>& cloud)
{
    if (!ply_read_header(ply))
    {
        std::string msg = "ply_read_header failed";
        LOG(ERROR) << msg;
        return false;
    }

    char const* ptr       = nullptr;
    char const* delimiter = " ";
    char        buffer[256];
    using Scalar         = typename PointT::ScalarType;
    using Point3Type     = holo::geometry::Point3T<Scalar>;
    using Rot3Type       = holo::geometry::Rot3T<Scalar>;
    using QuaternionType = holo::geometry::QuaternionT<Scalar>;
    using Pose3Type      = holo::geometry::Pose3T<Scalar>;

    while ((ptr = ply_get_next_obj_info(ply, ptr)) != nullptr)
    {
        std::strcpy(buffer, ptr);
        char const* token = std::strtok(buffer, delimiter);

        if (std::strcmp(token, "coord") == 0)
        {
            char const* value = std::strtok(NULL, delimiter);
            cloud.SetCoordinate(common::Coordinate(std::atoi(value)));
        }
        else if (std::strcmp(token, "timestamp") == 0)
        {
            char const* sec  = std::strtok(NULL, delimiter);
            char const* nsec = std::strtok(NULL, delimiter);
            cloud.SetTimestamp(Timestamp(std::atof(sec), std::atof(nsec)));
        }
        else if (std::strcmp(token, "size") == 0)
        {
            char const* width  = std::strtok(NULL, delimiter);
            char const* height = std::strtok(NULL, delimiter);
            cloud.resize(std::atoi(width) * std::atoi(height));
        }
        else if (std::strcmp(token, "dense") == 0)
        {
            char const* dense = std::strtok(NULL, delimiter);
            cloud.SetDense(std::atoi(dense));
        }
        else if (std::strcmp(token, "pose") == 0)
        {
            char const* qw = std::strtok(NULL, delimiter);
            char const* qx = std::strtok(NULL, delimiter);
            char const* qy = std::strtok(NULL, delimiter);
            char const* qz = std::strtok(NULL, delimiter);
            char const* x  = std::strtok(NULL, delimiter);
            char const* y  = std::strtok(NULL, delimiter);
            char const* z  = std::strtok(NULL, delimiter);

            QuaternionType q(std::atof(qw), std::atof(qx), std::atof(qy), std::atof(qz));

            Pose3Type pose(Rot3Type(q.ToRotationMatrix()), Point3Type(std::atof(x), std::atof(y), std::atof(z)));
            cloud.SetPose(pose);
        }
    }

    return true;
}

/**
 * @brief Function to be called for each property value
 *
 * @tparam PointT
 * @param[in] argument pointer to ply argument structure
 * @return int
 */
template <typename PointT>
int VertexCallback(p_ply_argument argument)
{
    GetFields<PointT>       get_field;
    std::vector<PointField> fields = get_field();

    PointCloudT<PointT>* cloud = nullptr;
    long                 field_idx;

    if (!ply_get_argument_user_data(argument, (void**)&cloud, &field_idx))
    {
        std::string msg = "ply_get_argument_user_data failed";
        LOG(ERROR) << msg;
        return false;
    }

    p_ply_element ele;
    long          point_idx;

    if (!ply_get_argument_element(argument, &ele, &point_idx))
    {
        std::string msg = "ply_get_argument_element failed";
        LOG(ERROR) << msg;
        return false;
    }

    PointField const& f   = fields[field_idx];
    PointT&           p   = cloud->at(point_idx);
    float64_t         var = ply_get_argument_value(argument);

    switch (f.GetType())
    {
        case HoloType::INT8: {
            uint8_t v_8s = static_cast<int8_t>(var);
            SetFieldValue<PointT, int8_t>(p, f, v_8s);
            break;
        }

        case HoloType::UINT8: {
            uint8_t v_8u = static_cast<uint8_t>(var);
            SetFieldValue<PointT, uint8_t>(p, f, v_8u);
            break;
        }

        case HoloType::UINT16: {
            uint16_t v_16u = static_cast<uint16_t>(var);
            SetFieldValue<PointT, uint16_t>(p, f, v_16u);
            break;
        }
        case HoloType::INT16: {
            int16_t v_16i = static_cast<int16_t>(var);
            SetFieldValue<PointT, int16_t>(p, f, v_16i);
            break;
        }
        case HoloType::UINT32: {
            uint32_t v_32u = static_cast<uint32_t>(var);
            SetFieldValue<PointT, uint32_t>(p, f, v_32u);
            break;
        }
        case HoloType::INT32: {
            int32_t v_32s = static_cast<int32_t>(var);
            SetFieldValue<PointT, int32_t>(p, f, v_32s);
            break;
        }
        case HoloType::FLOAT32: {
            float32_t v_32f = static_cast<float32_t>(var);
            SetFieldValue<PointT, float32_t>(p, f, v_32f);
            break;
        }
        case HoloType::FLOAT64: {
            float64_t v_64f = var;
            SetFieldValue<PointT, float64_t>(p, f, v_64f);
            break;
        }
        case HoloType::TIMESTAMP: {
            common::Timestamp t(var);
            SetFieldValue<PointT, common::Timestamp>(p, f, t);
            break;
        }
        default:
            std::string msg = "unknown data type";
            LOG(ERROR) << msg;
            return false;
    }

    return true;
}

/**
 * @brief Get field index
 *
 * @param[in] fields point fields
 * @param[in] name field name
 * @param[in] type field type
 * @return int64_t field index
 */
int64_t GetFieldIndex(std::vector<PointField> const& fields, std::string const& name, e_ply_type type)
{
    for (size_t i = 0U; i < fields.size(); ++i)
    {
        PointField const& f = fields[i];

        if (f.GetName() == name)
        {
            e_ply_type rply_type = GetRplyType(f.GetType());

            /* ply data type
            typedef enum e_ply_type {
                PLY_INT8, PLY_UINT8, PLY_INT16, PLY_UINT16,
                PLY_INT32, PLY_UIN32, PLY_FLOAT32, PLY_FLOAT64,
                PLY_CHAR, PLY_UCHAR, PLY_SHORT, PLY_USHORT,
                PLY_INT, PLY_UINT, PLY_FLOAT, PLY_DOUBLE,
                PLY_LIST
            } e_ply_type;
            */

            /**
             * As above, rply defined two enum type name for the same type, we use first eight type, the api should be
             * compatible with different name style, so we need to convert first type style to second, we can achieve
             * this by adding 8 on e_ply_type, because the distance between two type style is exactly 8.
             *
             */
            if (rply_type == type || rply_type + 8 == type)
            {
                return i;
            }
        }
    }

    return -1;
}

/**
 * @brief Read ply element and property
 *
 * @tparam PointT
 * @param[in] ply pointer to ply object
 * @param[out] cloud point cloud
 * @return true if read successfully
 * @return false if read failed
 */
template <typename PointT>
bool ReadPlyElementAndProperty(p_ply ply, PointCloudT<PointT>& cloud)
{
    GetFields<PointT>       get_field;
    std::vector<PointField> fields = get_field();

    // iterate over all element on the header of a PLY file
    p_ply_element ele = nullptr;

    while ((ele = ply_get_next_element(ply, ele)) != nullptr)
    {
        long        num_ele;
        char const* ele_name;

        if (!ply_get_element_info(ele, &ele_name, &num_ele))
        {
            std::string msg = "ply_get_element_info failed";
            LOG(ERROR) << msg;
            return false;
        }

        if (std::strcmp(ele_name, "vertex") == 0)
        {
            cloud.resize(num_ele);
            p_ply_property prop = nullptr;

            while ((prop = ply_get_next_property(ele, prop)) != nullptr)
            {
                char const* prop_name;
                e_ply_type  type;
                e_ply_type  length_type;
                e_ply_type  value_type;

                if (!ply_get_property_info(prop, &prop_name, &type, &length_type, &value_type))
                {
                    std::string msg = "ply_get_property_info failed";
                    LOG(ERROR) << msg;
                    return false;
                }

                if (type == PLY_LIST)
                {
                    std::string msg = "not supported point format";
                    LOG(ERROR) << msg;
                    return false;
                }

                int64_t prop_idx = GetFieldIndex(fields, prop_name, type);

                // trying to load a property which does not match the PointT
                if (prop_idx < 0)
                {
                    continue;
                }

                if (!ply_set_read_cb(ply, ele_name, prop_name, VertexCallback<PointT>, &cloud, prop_idx))
                {
                    std::string msg = "ply_set_read_cb failed";
                    LOG(ERROR) << msg;
                    return false;
                }
            }  // iterate on properties
        }      // ele_name == vertex
    }          // iterate on elements

    return true;
}

/**
 * @brief internal function to read ply
 *
 * @tparam PointT
 * @param[in] ply pointer to ply object
 * @param[out] cloud point cloud
 * @return size_t point cloud size
 */
template <typename PointT>
size_t ReadPlyInternal(p_ply ply, PointCloudT<PointT>& cloud)
{
    ReadPlyHeader(ply, cloud);
    ReadPlyElementAndProperty(ply, cloud);

    if (!ply_read(ply))
    {
        std::string msg = "ply_read failed";
        LOG(ERROR) << msg;
        return 0;
    }

    return cloud.size();
}
}  // namespace internal

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename PointT>
bool_t SavePly(std::string const& fn, const PointCloudT<PointT>& cloud, bool_t binary)
{
    p_ply oply = ply_create(fn.c_str(), binary ? PLY_LITTLE_ENDIAN : PLY_ASCII, NULL, 0, NULL);

    if (!oply)
    {
        std::string msg = "ply_create failed";
        LOG(ERROR) << msg;
        return false;
    }

    internal::WritePlyInternal(oply, cloud);

    if (!ply_close(oply))
    {
        std::string msg = "ply_close failed";
        LOG(ERROR) << msg;
        return false;
    }

    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
template <typename PointT>
bool_t LoadPly(std::string const& fn, PointCloudT<PointT>& cloud)
{
    p_ply ply = ply_open(fn.c_str(), NULL, 0, NULL);

    if (!ply)
    {
        LOG(ERROR) << "ply_open failed";
        return false;
    }

    size_t const n = internal::ReadPlyInternal(ply, cloud);
    DLOG(INFO) << "LoadPly: load " << n << " points from " << fn;

    if (!ply_close(ply))
    {
        LOG(ERROR) << "ply_close failed";
        return false;
    }

    return true;
}
}  // namespace pointcloud
}  // namespace holo
#endif  // HOLO_3D_COMMON_IO_HPP_
