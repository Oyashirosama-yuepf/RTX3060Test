/* -*- C++ -*- */
/* Generated by /home/holo/workspace/output/tda4_ubuntu-18.04/debug/host/bin/opendds_idl version 3.16 (ACE version 6.2a_p19) running on input file /home/holo/workspace/src/holo_base_msg/opendds_msg/message/holo_base_msg/core/Types.idl */
#ifndef OPENDDS_IDL_GENERATED_TYPESTYPESUPPORTIMPL_H_J3LK8Y
#define OPENDDS_IDL_GENERATED_TYPESTYPESUPPORTIMPL_H_J3LK8Y
#include "TypesC.h"
#include "dds/DCPS/Definitions.h"
#include "dds/DdsDcpsC.h"
#include "dds/Version.h"
#if DDS_MAJOR_VERSION != 3 || DDS_MINOR_VERSION != 16 || DDS_MICRO_VERSION != 0
#error This file should be regenerated with opendds_idl
#endif
#include "dds/DCPS/Serializer.h"
#include "dds/DCPS/XTypes/TypeObject.h"
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL



/* Begin MODULE: CORBA */


/* End MODULE: CORBA */


/* Begin MODULE: OpenDDS */


/* End MODULE: OpenDDS */


/* Begin MODULE: holo_base_msg */



/* Begin MODULE: core */



/* Begin TYPEDEF: bool_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_bool_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_bool_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_bool_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: bool_t */


/* Begin TYPEDEF: char_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_char_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_char_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_char_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: char_t */


/* Begin TYPEDEF: _cxx_wchar_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core___cxx_wchar_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core___cxx_wchar_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core___cxx_wchar_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: _cxx_wchar_t */


/* Begin TYPEDEF: int8_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_int8_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_int8_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_int8_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: int8_t */


/* Begin TYPEDEF: uint8_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_uint8_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_uint8_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_uint8_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: uint8_t */


/* Begin TYPEDEF: int16_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_int16_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_int16_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_int16_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: int16_t */


/* Begin TYPEDEF: uint16_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_uint16_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_uint16_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_uint16_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: uint16_t */


/* Begin TYPEDEF: int32_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_int32_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_int32_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_int32_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: int32_t */


/* Begin TYPEDEF: uint32_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_uint32_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_uint32_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_uint32_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: uint32_t */


/* Begin TYPEDEF: int64_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_int64_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_int64_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_int64_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: int64_t */


/* Begin TYPEDEF: uint64_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_uint64_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_uint64_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_uint64_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: uint64_t */


/* Begin TYPEDEF: float32_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_float32_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_float32_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_float32_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: float32_t */


/* Begin TYPEDEF: float64_t */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_float64_t_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_float64_t_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_float64_t_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: float64_t */


/* Begin TYPEDEF: BoolSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::BoolSequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::BoolSequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::BoolSequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::BoolSequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_BoolSequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_BoolSequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_BoolSequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: BoolSequence */


/* Begin TYPEDEF: CharSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::CharSequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::CharSequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::CharSequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::CharSequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_CharSequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_CharSequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_CharSequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: CharSequence */


/* Begin TYPEDEF: WcharSequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::WcharSequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::WcharSequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::WcharSequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::WcharSequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_WcharSequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_WcharSequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_WcharSequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: WcharSequence */


/* Begin TYPEDEF: Int8Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Int8Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Int8Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Int8Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Int8Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Int8Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Int8Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Int8Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Int8Sequence */


/* Begin TYPEDEF: Uint8Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Uint8Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Uint8Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Uint8Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Uint8Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Uint8Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Uint8Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Uint8Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Uint8Sequence */


/* Begin TYPEDEF: Int16Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Int16Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Int16Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Int16Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Int16Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Int16Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Int16Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Int16Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Int16Sequence */


/* Begin TYPEDEF: Uint16Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Uint16Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Uint16Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Uint16Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Uint16Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Uint16Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Uint16Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Uint16Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Uint16Sequence */


/* Begin TYPEDEF: Int32Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Int32Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Int32Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Int32Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Int32Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Int32Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Int32Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Int32Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Int32Sequence */


/* Begin TYPEDEF: Uint32Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Uint32Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Uint32Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Uint32Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Uint32Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Uint32Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Uint32Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Uint32Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Uint32Sequence */


/* Begin TYPEDEF: Int64Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Int64Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Int64Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Int64Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Int64Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Int64Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Int64Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Int64Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Int64Sequence */


/* Begin TYPEDEF: Uint64Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Uint64Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Uint64Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Uint64Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Uint64Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Uint64Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Uint64Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Uint64Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Uint64Sequence */


/* Begin TYPEDEF: Float32Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Float32Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Float32Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Float32Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Float32Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Float32Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Float32Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Float32Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Float32Sequence */


/* Begin TYPEDEF: Float64Sequence */

OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

void serialized_size(const Encoding& encoding, size_t& size, const holo_base_msg::core::Float64Sequence& seq);

bool operator<<(Serializer& strm, const holo_base_msg::core::Float64Sequence& seq);

bool operator>>(Serializer& strm, holo_base_msg::core::Float64Sequence& seq);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

bool gen_skip_over(Serializer& ser, holo_base_msg::core::Float64Sequence*);

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

struct holo_base_msg_core_Float64Sequence_xtag {};
template<> const XTypes::TypeIdentifier & getMinimalTypeIdentifier<holo_base_msg_core_Float64Sequence_xtag>();

template<> const XTypes::TypeMap& getMinimalTypeMap<holo_base_msg_core_Float64Sequence_xtag>();

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL


/* End TYPEDEF: Float64Sequence */

/* End MODULE: core */

/* End MODULE: holo_base_msg */
OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
namespace OpenDDS { namespace DCPS {

} }
OPENDDS_END_VERSIONED_NAMESPACE_DECL

#endif /* OPENDDS_IDL_GENERATED_TYPESTYPESUPPORTIMPL_H_J3LK8Y */
