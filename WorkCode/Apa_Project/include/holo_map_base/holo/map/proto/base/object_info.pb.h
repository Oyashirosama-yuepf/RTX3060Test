// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: holo/map/proto/base/object_info.proto

#ifndef PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fbase_2fobject_5finfo_2eproto
#define PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fbase_2fobject_5finfo_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "holo/map/proto/common/coordinate.pb.h"
#include "holo/map/proto/common/geo_box.pb.h"
#include "holo/map/proto/common/geo_point.pb.h"
#include "holo/map/proto/common/geo_line.pb.h"
#include "holo/map/proto/common/geo_multi_line.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_holo_2fmap_2fproto_2fbase_2fobject_5finfo_2eproto 

namespace protobuf_holo_2fmap_2fproto_2fbase_2fobject_5finfo_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_holo_2fmap_2fproto_2fbase_2fobject_5finfo_2eproto
namespace holo {
namespace map {
namespace proto {
namespace base {
class ObjectInfo;
class ObjectInfoDefaultTypeInternal;
extern ObjectInfoDefaultTypeInternal _ObjectInfo_default_instance_;
class ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse;
class ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUseDefaultTypeInternal;
extern ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUseDefaultTypeInternal _ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse_default_instance_;
class ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse;
class ObjectInfo_ExtraObjectGeoPointEntry_DoNotUseDefaultTypeInternal;
extern ObjectInfo_ExtraObjectGeoPointEntry_DoNotUseDefaultTypeInternal _ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse_default_instance_;
class ObjectInfo_ExtraRegionEntry_DoNotUse;
class ObjectInfo_ExtraRegionEntry_DoNotUseDefaultTypeInternal;
extern ObjectInfo_ExtraRegionEntry_DoNotUseDefaultTypeInternal _ObjectInfo_ExtraRegionEntry_DoNotUse_default_instance_;
}  // namespace base
}  // namespace proto
}  // namespace map
}  // namespace holo
namespace google {
namespace protobuf {
template<> ::holo::map::proto::base::ObjectInfo* Arena::CreateMaybeMessage<::holo::map::proto::base::ObjectInfo>(Arena*);
template<> ::holo::map::proto::base::ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse* Arena::CreateMaybeMessage<::holo::map::proto::base::ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse>(Arena*);
template<> ::holo::map::proto::base::ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse* Arena::CreateMaybeMessage<::holo::map::proto::base::ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse>(Arena*);
template<> ::holo::map::proto::base::ObjectInfo_ExtraRegionEntry_DoNotUse* Arena::CreateMaybeMessage<::holo::map::proto::base::ObjectInfo_ExtraRegionEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace holo {
namespace map {
namespace proto {
namespace base {

enum ObjectInfo_ObjectType {
  ObjectInfo_ObjectType_OBJECT_TYPE_UNDEFINED = 0,
  ObjectInfo_ObjectType_OBJECT_TYPE_SIGN = 1,
  ObjectInfo_ObjectType_OBJECT_TYPE_POLE = 2,
  ObjectInfo_ObjectType_OBJECT_TYPE_TRAFICLIGHT = 3,
  ObjectInfo_ObjectType_OBJECT_TYPE_MARKING = 4,
  ObjectInfo_ObjectType_OBJECT_TYPE_WALL = 5,
  ObjectInfo_ObjectType_OBJECT_TYPE_OBSTACLE = 6,
  ObjectInfo_ObjectType_OBJECT_TYPE_BARRIER = 7,
  ObjectInfo_ObjectType_OBJECT_TYPE_OSF = 8
};
bool ObjectInfo_ObjectType_IsValid(int value);
const ObjectInfo_ObjectType ObjectInfo_ObjectType_ObjectType_MIN = ObjectInfo_ObjectType_OBJECT_TYPE_UNDEFINED;
const ObjectInfo_ObjectType ObjectInfo_ObjectType_ObjectType_MAX = ObjectInfo_ObjectType_OBJECT_TYPE_OSF;
const int ObjectInfo_ObjectType_ObjectType_ARRAYSIZE = ObjectInfo_ObjectType_ObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectInfo_ObjectType_descriptor();
inline const ::std::string& ObjectInfo_ObjectType_Name(ObjectInfo_ObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectInfo_ObjectType_descriptor(), value);
}
inline bool ObjectInfo_ObjectType_Parse(
    const ::std::string& name, ObjectInfo_ObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectInfo_ObjectType>(
    ObjectInfo_ObjectType_descriptor(), name, value);
}
enum ObjectInfo_TrafficSignShape {
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_UNDEFINED = 0,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_RECTANGLE = 1,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_ROUND = 2,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_OCTAGON = 3,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_DIAMOND = 4,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_CROSBUCK = 5,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_TRIANGLE_TIP_DOWN = 6,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_ELLIPSE = 7,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_OTHER = 8,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_TRIANGLE_TIP_UP = 9,
  ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_UNKNOWN = 15
};
bool ObjectInfo_TrafficSignShape_IsValid(int value);
const ObjectInfo_TrafficSignShape ObjectInfo_TrafficSignShape_TrafficSignShape_MIN = ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_UNDEFINED;
const ObjectInfo_TrafficSignShape ObjectInfo_TrafficSignShape_TrafficSignShape_MAX = ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_UNKNOWN;
const int ObjectInfo_TrafficSignShape_TrafficSignShape_ARRAYSIZE = ObjectInfo_TrafficSignShape_TrafficSignShape_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectInfo_TrafficSignShape_descriptor();
inline const ::std::string& ObjectInfo_TrafficSignShape_Name(ObjectInfo_TrafficSignShape value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectInfo_TrafficSignShape_descriptor(), value);
}
inline bool ObjectInfo_TrafficSignShape_Parse(
    const ::std::string& name, ObjectInfo_TrafficSignShape* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectInfo_TrafficSignShape>(
    ObjectInfo_TrafficSignShape_descriptor(), name, value);
}
enum ObjectInfo_TrafficSignType {
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_UNDEFINED = 0,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SPEED_LIMIT = 1,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SPEED_LIMIT_END = 2,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ADVISORY_SPEED_LIMIT = 3,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ADVISORY_SPEED_LIMIT_END = 4,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_OVERTAKING = 5,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_OVERTAKING_END = 6,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_DO_NOT_ENTER = 7,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ANIMALS = 8,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_BICYCLE_PATH = 9,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_VEHICLES_PROHIBITED = 10,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_MOTORWAY_END = 11,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_FALLING_ROCKS = 12,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HEIGHT_RESTRICTION = 13,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ICY_ROAD = 14,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_LENGTH_RESTRICTION = 15,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_MOTORWAY = 16,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_OVERTAKING_FOR_TRUCKS = 17,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_OVERTAKING_FOR_TRUCKS_END = 18,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PASSING_RESTRICTION = 19,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CARRIAGEWAY_NARROWS = 20,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SLIPPERY_ROAD = 21,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TRUCK_SPEED_LIMIT = 22,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TURN_RESTRICTION = 23,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_RICTION = 24,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_WEIGHT_RESTRICTION = 25,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_YIELD = 26,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CURVY_ROAD = 27,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NARROW_BRIDGE = 28,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TWO_WAY_TRAFFIC = 29,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PEDESTRIANS = 30,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CHILDREN = 31,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_WIND = 32,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_EMBANKMENT = 33,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_VILLAGE_AHEAD = 34,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TUNNEL = 35,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_FERRY_TERMINAL = 36,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HUMPBACK_BRIDGE = 37,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_UNEVEN_ROAD = 38,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_BUMP = 39,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_DIP = 40,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ROAD_FLOODS = 41,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_RAILROAD_CROSSING = 42,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HIGH_ACCIDENT_AREA = 43,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SLOW_DOWN = 44,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PASS_OBSTACLE = 45,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_GENERAL_HAZARD = 46,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ROAD_WORKS = 47,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TRAFFIC_CONGESTION = 48,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PEDESTRIANS_PROHIBITED = 49,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HONKING_PROHIBITED = 50,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ONEWAY = 51,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PEDESTRIAN_PATH = 52,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_END_OF_ALL_RESTRICTIONS = 53,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PRIORITY_ROAD = 54,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PRIORITY_OVER_ONCOMING = 55,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PEDESTRIAN_CROSSING = 56,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SHARP_CURVY_ROAD = 57,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_LANE_END = 58,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ROLLOVER = 59,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TRAFIC_LIGHT_SIGNALS = 60,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_STOP = 61,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_PARKING = 62,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_INTERSECTION = 63,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_REVERSE_CURVE = 64,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_STEEP_HILLS = 65,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_STEEP_DROP = 66,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_WATCH_HANDICAPPED = 67,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_LIGHT_UP_IN_TUNNEL = 68,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_REVERSIBLE_LANE = 69,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_MAINTAIN_SAFE_DISTANCE = 70,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SEPARATED_ROAD = 71,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CONFLUENCE = 72,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TRUCK_ESCAPE_RAMPS = 73,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ADVERSE_WEATHER = 74,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_STOP_FOR_INSPECTION = 75,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CUSTOMS = 76,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_LANE_DRIVING_DIRECTION = 77,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_BUS_LANE = 78,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_VEHICLE_LANE = 79,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NON_MOTOR_VEHICLE_LANE = 80,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_BRT_Lane = 81,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HOV_Lane = 82,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PARKING = 83,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SIGN_TYPE_COUNT = 84,
  ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SIGN_TYPE_UNKNOWN = 86
};
bool ObjectInfo_TrafficSignType_IsValid(int value);
const ObjectInfo_TrafficSignType ObjectInfo_TrafficSignType_TrafficSignType_MIN = ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_UNDEFINED;
const ObjectInfo_TrafficSignType ObjectInfo_TrafficSignType_TrafficSignType_MAX = ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SIGN_TYPE_UNKNOWN;
const int ObjectInfo_TrafficSignType_TrafficSignType_ARRAYSIZE = ObjectInfo_TrafficSignType_TrafficSignType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectInfo_TrafficSignType_descriptor();
inline const ::std::string& ObjectInfo_TrafficSignType_Name(ObjectInfo_TrafficSignType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectInfo_TrafficSignType_descriptor(), value);
}
inline bool ObjectInfo_TrafficSignType_Parse(
    const ::std::string& name, ObjectInfo_TrafficSignType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectInfo_TrafficSignType>(
    ObjectInfo_TrafficSignType_descriptor(), name, value);
}
enum ObjectInfo_MarkingColor {
  ObjectInfo_MarkingColor_MARKING_COLOR_UNKNOWN = 0,
  ObjectInfo_MarkingColor_MARKING_COLOR_LIGHT_GRAY = 1,
  ObjectInfo_MarkingColor_MARKING_COLOR_GRAY = 2,
  ObjectInfo_MarkingColor_MARKING_COLOR_DARK_GRAY = 3,
  ObjectInfo_MarkingColor_MARKING_COLOR_BLACK = 4,
  ObjectInfo_MarkingColor_MARKING_COLOR_RED = 5,
  ObjectInfo_MarkingColor_MARKING_COLOR_YELLOW = 6,
  ObjectInfo_MarkingColor_MARKING_COLOR_GREEN = 7,
  ObjectInfo_MarkingColor_MARKING_COLOR_CYAN = 8,
  ObjectInfo_MarkingColor_MARKING_COLOR_BLUE = 9,
  ObjectInfo_MarkingColor_MARKING_COLOR_ORANGE = 10,
  ObjectInfo_MarkingColor_MARKING_COLOR_WHITE = 11
};
bool ObjectInfo_MarkingColor_IsValid(int value);
const ObjectInfo_MarkingColor ObjectInfo_MarkingColor_MarkingColor_MIN = ObjectInfo_MarkingColor_MARKING_COLOR_UNKNOWN;
const ObjectInfo_MarkingColor ObjectInfo_MarkingColor_MarkingColor_MAX = ObjectInfo_MarkingColor_MARKING_COLOR_WHITE;
const int ObjectInfo_MarkingColor_MarkingColor_ARRAYSIZE = ObjectInfo_MarkingColor_MarkingColor_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectInfo_MarkingColor_descriptor();
inline const ::std::string& ObjectInfo_MarkingColor_Name(ObjectInfo_MarkingColor value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectInfo_MarkingColor_descriptor(), value);
}
inline bool ObjectInfo_MarkingColor_Parse(
    const ::std::string& name, ObjectInfo_MarkingColor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectInfo_MarkingColor>(
    ObjectInfo_MarkingColor_descriptor(), name, value);
}
enum ObjectInfo_MarkingType {
  ObjectInfo_MarkingType_MARKING_TYPE_UNDEFINED = 0,
  ObjectInfo_MarkingType_MARKING_TYPE_ARROW_STRAIGHT = 1,
  ObjectInfo_MarkingType_MARKING_TYPE_ARROW_LEFT = 2,
  ObjectInfo_MarkingType_MARKING_TYPE_ARROW_RIGHT = 3,
  ObjectInfo_MarkingType_MARKING_TYPE_ARROW_STRAIGHT_AND_LEFT = 4,
  ObjectInfo_MarkingType_MARKING_TYPE_ARROW_STRAIGHT_AND_RIGHT = 5,
  ObjectInfo_MarkingType_MARKING_TYPE_ARROW_LEFT_AND_RIGHT = 6,
  ObjectInfo_MarkingType_MARKING_TYPE_LINE_ELEMENT = 7,
  ObjectInfo_MarkingType_MARKING_TYPE_STOP_LINE = 8,
  ObjectInfo_MarkingType_MARKING_TYPE_CROSSWALK = 9,
  ObjectInfo_MarkingType_MARKING_TYPE_SIGN = 10,
  ObjectInfo_MarkingType_MARKING_TYPE_DASHED_LINE_ELEMENT = 11,
  ObjectInfo_MarkingType_MARKING_TYPE_YIELD_INDICATION = 12,
  ObjectInfo_MarkingType_MARKING_TYPE_VISUAL_SPEED_BUMP = 13,
  ObjectInfo_MarkingType_MARKING_TYPE_SHADED_AREA = 14,
  ObjectInfo_MarkingType_MARKING_TYPE_OTHER = 15,
  ObjectInfo_MarkingType_MARKING_TYPE_TEXT = 16
};
bool ObjectInfo_MarkingType_IsValid(int value);
const ObjectInfo_MarkingType ObjectInfo_MarkingType_MarkingType_MIN = ObjectInfo_MarkingType_MARKING_TYPE_UNDEFINED;
const ObjectInfo_MarkingType ObjectInfo_MarkingType_MarkingType_MAX = ObjectInfo_MarkingType_MARKING_TYPE_TEXT;
const int ObjectInfo_MarkingType_MarkingType_ARRAYSIZE = ObjectInfo_MarkingType_MarkingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectInfo_MarkingType_descriptor();
inline const ::std::string& ObjectInfo_MarkingType_Name(ObjectInfo_MarkingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectInfo_MarkingType_descriptor(), value);
}
inline bool ObjectInfo_MarkingType_Parse(
    const ::std::string& name, ObjectInfo_MarkingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectInfo_MarkingType>(
    ObjectInfo_MarkingType_descriptor(), name, value);
}
enum ObjectInfo_MarkingGeometryType {
  ObjectInfo_MarkingGeometryType_MARKING_GEOMETRY_TYPE_UNDEFINED = 0,
  ObjectInfo_MarkingGeometryType_MARKING_GEOMETRY_TYPE_BOUNDARY_BOX = 1,
  ObjectInfo_MarkingGeometryType_MARKING_GEOMETRY_TYPE_CENTER_LINE = 2
};
bool ObjectInfo_MarkingGeometryType_IsValid(int value);
const ObjectInfo_MarkingGeometryType ObjectInfo_MarkingGeometryType_MarkingGeometryType_MIN = ObjectInfo_MarkingGeometryType_MARKING_GEOMETRY_TYPE_UNDEFINED;
const ObjectInfo_MarkingGeometryType ObjectInfo_MarkingGeometryType_MarkingGeometryType_MAX = ObjectInfo_MarkingGeometryType_MARKING_GEOMETRY_TYPE_CENTER_LINE;
const int ObjectInfo_MarkingGeometryType_MarkingGeometryType_ARRAYSIZE = ObjectInfo_MarkingGeometryType_MarkingGeometryType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectInfo_MarkingGeometryType_descriptor();
inline const ::std::string& ObjectInfo_MarkingGeometryType_Name(ObjectInfo_MarkingGeometryType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectInfo_MarkingGeometryType_descriptor(), value);
}
inline bool ObjectInfo_MarkingGeometryType_Parse(
    const ::std::string& name, ObjectInfo_MarkingGeometryType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectInfo_MarkingGeometryType>(
    ObjectInfo_MarkingGeometryType_descriptor(), name, value);
}
enum ObjectInfo_PoleObjectType {
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_UNDEFINED = 0,
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_LIGHT_POLE = 1,
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_DELINEATOR_POST = 2,
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_REFLECTOR_POST = 3,
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_GANTRY_POLE = 4,
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_SIGNPOST = 5,
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_OTHER = 6,
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_UNCLASSIFIED = 7,
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_GUARDRAIL_POST = 8,
  ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_UNKNOWN = 99
};
bool ObjectInfo_PoleObjectType_IsValid(int value);
const ObjectInfo_PoleObjectType ObjectInfo_PoleObjectType_PoleObjectType_MIN = ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_UNDEFINED;
const ObjectInfo_PoleObjectType ObjectInfo_PoleObjectType_PoleObjectType_MAX = ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_UNKNOWN;
const int ObjectInfo_PoleObjectType_PoleObjectType_ARRAYSIZE = ObjectInfo_PoleObjectType_PoleObjectType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ObjectInfo_PoleObjectType_descriptor();
inline const ::std::string& ObjectInfo_PoleObjectType_Name(ObjectInfo_PoleObjectType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ObjectInfo_PoleObjectType_descriptor(), value);
}
inline bool ObjectInfo_PoleObjectType_Parse(
    const ::std::string& name, ObjectInfo_PoleObjectType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ObjectInfo_PoleObjectType>(
    ObjectInfo_PoleObjectType_descriptor(), name, value);
}
// ===================================================================

class ObjectInfo_ExtraRegionEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ObjectInfo_ExtraRegionEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ObjectInfo_ExtraRegionEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ObjectInfo_ExtraRegionEntry_DoNotUse();
  ObjectInfo_ExtraRegionEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ObjectInfo_ExtraRegionEntry_DoNotUse& other);
  static const ObjectInfo_ExtraRegionEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ObjectInfo_ExtraRegionEntry_DoNotUse*>(&_ObjectInfo_ExtraRegionEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoPoint,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoPoint,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse();
  ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse& other);
  static const ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse*>(&_ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoMultiLine,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse, 
    ::google::protobuf::uint32, ::holo::map::proto::common::GeoMultiLine,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse();
  ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse& other);
  static const ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse*>(&_ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class ObjectInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:holo.map.proto.base.ObjectInfo) */ {
 public:
  ObjectInfo();
  virtual ~ObjectInfo();

  ObjectInfo(const ObjectInfo& from);

  inline ObjectInfo& operator=(const ObjectInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ObjectInfo(ObjectInfo&& from) noexcept
    : ObjectInfo() {
    *this = ::std::move(from);
  }

  inline ObjectInfo& operator=(ObjectInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ObjectInfo* internal_default_instance() {
    return reinterpret_cast<const ObjectInfo*>(
               &_ObjectInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(ObjectInfo* other);
  friend void swap(ObjectInfo& a, ObjectInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ObjectInfo* New() const final {
    return CreateMaybeMessage<ObjectInfo>(NULL);
  }

  ObjectInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ObjectInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ObjectInfo& from);
  void MergeFrom(const ObjectInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ObjectInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef ObjectInfo_ObjectType ObjectType;
  static const ObjectType OBJECT_TYPE_UNDEFINED =
    ObjectInfo_ObjectType_OBJECT_TYPE_UNDEFINED;
  static const ObjectType OBJECT_TYPE_SIGN =
    ObjectInfo_ObjectType_OBJECT_TYPE_SIGN;
  static const ObjectType OBJECT_TYPE_POLE =
    ObjectInfo_ObjectType_OBJECT_TYPE_POLE;
  static const ObjectType OBJECT_TYPE_TRAFICLIGHT =
    ObjectInfo_ObjectType_OBJECT_TYPE_TRAFICLIGHT;
  static const ObjectType OBJECT_TYPE_MARKING =
    ObjectInfo_ObjectType_OBJECT_TYPE_MARKING;
  static const ObjectType OBJECT_TYPE_WALL =
    ObjectInfo_ObjectType_OBJECT_TYPE_WALL;
  static const ObjectType OBJECT_TYPE_OBSTACLE =
    ObjectInfo_ObjectType_OBJECT_TYPE_OBSTACLE;
  static const ObjectType OBJECT_TYPE_BARRIER =
    ObjectInfo_ObjectType_OBJECT_TYPE_BARRIER;
  static const ObjectType OBJECT_TYPE_OSF =
    ObjectInfo_ObjectType_OBJECT_TYPE_OSF;
  static inline bool ObjectType_IsValid(int value) {
    return ObjectInfo_ObjectType_IsValid(value);
  }
  static const ObjectType ObjectType_MIN =
    ObjectInfo_ObjectType_ObjectType_MIN;
  static const ObjectType ObjectType_MAX =
    ObjectInfo_ObjectType_ObjectType_MAX;
  static const int ObjectType_ARRAYSIZE =
    ObjectInfo_ObjectType_ObjectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ObjectType_descriptor() {
    return ObjectInfo_ObjectType_descriptor();
  }
  static inline const ::std::string& ObjectType_Name(ObjectType value) {
    return ObjectInfo_ObjectType_Name(value);
  }
  static inline bool ObjectType_Parse(const ::std::string& name,
      ObjectType* value) {
    return ObjectInfo_ObjectType_Parse(name, value);
  }

  typedef ObjectInfo_TrafficSignShape TrafficSignShape;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_UNDEFINED =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_UNDEFINED;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_RECTANGLE =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_RECTANGLE;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_ROUND =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_ROUND;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_OCTAGON =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_OCTAGON;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_DIAMOND =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_DIAMOND;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_CROSBUCK =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_CROSBUCK;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_TRIANGLE_TIP_DOWN =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_TRIANGLE_TIP_DOWN;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_ELLIPSE =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_ELLIPSE;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_OTHER =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_OTHER;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_TRIANGLE_TIP_UP =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_TRIANGLE_TIP_UP;
  static const TrafficSignShape TRAFFIC_SIGN_SHAPE_UNKNOWN =
    ObjectInfo_TrafficSignShape_TRAFFIC_SIGN_SHAPE_UNKNOWN;
  static inline bool TrafficSignShape_IsValid(int value) {
    return ObjectInfo_TrafficSignShape_IsValid(value);
  }
  static const TrafficSignShape TrafficSignShape_MIN =
    ObjectInfo_TrafficSignShape_TrafficSignShape_MIN;
  static const TrafficSignShape TrafficSignShape_MAX =
    ObjectInfo_TrafficSignShape_TrafficSignShape_MAX;
  static const int TrafficSignShape_ARRAYSIZE =
    ObjectInfo_TrafficSignShape_TrafficSignShape_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficSignShape_descriptor() {
    return ObjectInfo_TrafficSignShape_descriptor();
  }
  static inline const ::std::string& TrafficSignShape_Name(TrafficSignShape value) {
    return ObjectInfo_TrafficSignShape_Name(value);
  }
  static inline bool TrafficSignShape_Parse(const ::std::string& name,
      TrafficSignShape* value) {
    return ObjectInfo_TrafficSignShape_Parse(name, value);
  }

  typedef ObjectInfo_TrafficSignType TrafficSignType;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_UNDEFINED =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_UNDEFINED;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_SPEED_LIMIT =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SPEED_LIMIT;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_SPEED_LIMIT_END =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SPEED_LIMIT_END;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_ADVISORY_SPEED_LIMIT =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ADVISORY_SPEED_LIMIT;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_ADVISORY_SPEED_LIMIT_END =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ADVISORY_SPEED_LIMIT_END;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_NO_OVERTAKING =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_OVERTAKING;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_NO_OVERTAKING_END =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_OVERTAKING_END;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_DO_NOT_ENTER =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_DO_NOT_ENTER;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_ANIMALS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ANIMALS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_BICYCLE_PATH =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_BICYCLE_PATH;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_VEHICLES_PROHIBITED =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_VEHICLES_PROHIBITED;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_MOTORWAY_END =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_MOTORWAY_END;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_FALLING_ROCKS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_FALLING_ROCKS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_HEIGHT_RESTRICTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HEIGHT_RESTRICTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_ICY_ROAD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ICY_ROAD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_LENGTH_RESTRICTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_LENGTH_RESTRICTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_MOTORWAY =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_MOTORWAY;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_NO_OVERTAKING_FOR_TRUCKS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_OVERTAKING_FOR_TRUCKS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_NO_OVERTAKING_FOR_TRUCKS_END =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_OVERTAKING_FOR_TRUCKS_END;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_PASSING_RESTRICTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PASSING_RESTRICTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_CARRIAGEWAY_NARROWS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CARRIAGEWAY_NARROWS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_SLIPPERY_ROAD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SLIPPERY_ROAD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_TRUCK_SPEED_LIMIT =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TRUCK_SPEED_LIMIT;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_TURN_RESTRICTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TURN_RESTRICTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_RICTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_RICTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_WEIGHT_RESTRICTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_WEIGHT_RESTRICTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_YIELD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_YIELD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_CURVY_ROAD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CURVY_ROAD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_NARROW_BRIDGE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NARROW_BRIDGE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_TWO_WAY_TRAFFIC =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TWO_WAY_TRAFFIC;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_PEDESTRIANS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PEDESTRIANS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_CHILDREN =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CHILDREN;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_WIND =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_WIND;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_EMBANKMENT =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_EMBANKMENT;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_VILLAGE_AHEAD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_VILLAGE_AHEAD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_TUNNEL =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TUNNEL;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_FERRY_TERMINAL =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_FERRY_TERMINAL;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_HUMPBACK_BRIDGE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HUMPBACK_BRIDGE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_UNEVEN_ROAD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_UNEVEN_ROAD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_BUMP =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_BUMP;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_DIP =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_DIP;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_ROAD_FLOODS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ROAD_FLOODS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_RAILROAD_CROSSING =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_RAILROAD_CROSSING;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_HIGH_ACCIDENT_AREA =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HIGH_ACCIDENT_AREA;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_SLOW_DOWN =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SLOW_DOWN;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_PASS_OBSTACLE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PASS_OBSTACLE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_GENERAL_HAZARD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_GENERAL_HAZARD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_ROAD_WORKS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ROAD_WORKS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_TRAFFIC_CONGESTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TRAFFIC_CONGESTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_PEDESTRIANS_PROHIBITED =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PEDESTRIANS_PROHIBITED;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_HONKING_PROHIBITED =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HONKING_PROHIBITED;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_ONEWAY =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ONEWAY;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_PEDESTRIAN_PATH =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PEDESTRIAN_PATH;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_END_OF_ALL_RESTRICTIONS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_END_OF_ALL_RESTRICTIONS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_PRIORITY_ROAD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PRIORITY_ROAD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_PRIORITY_OVER_ONCOMING =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PRIORITY_OVER_ONCOMING;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_PEDESTRIAN_CROSSING =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PEDESTRIAN_CROSSING;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_SHARP_CURVY_ROAD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SHARP_CURVY_ROAD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_LANE_END =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_LANE_END;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_ROLLOVER =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ROLLOVER;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_TRAFIC_LIGHT_SIGNALS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TRAFIC_LIGHT_SIGNALS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_STOP =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_STOP;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_NO_PARKING =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NO_PARKING;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_INTERSECTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_INTERSECTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_REVERSE_CURVE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_REVERSE_CURVE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_STEEP_HILLS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_STEEP_HILLS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_STEEP_DROP =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_STEEP_DROP;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_WATCH_HANDICAPPED =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_WATCH_HANDICAPPED;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_LIGHT_UP_IN_TUNNEL =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_LIGHT_UP_IN_TUNNEL;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_REVERSIBLE_LANE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_REVERSIBLE_LANE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_MAINTAIN_SAFE_DISTANCE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_MAINTAIN_SAFE_DISTANCE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_SEPARATED_ROAD =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SEPARATED_ROAD;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_CONFLUENCE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CONFLUENCE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_TRUCK_ESCAPE_RAMPS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_TRUCK_ESCAPE_RAMPS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_ADVERSE_WEATHER =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_ADVERSE_WEATHER;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_STOP_FOR_INSPECTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_STOP_FOR_INSPECTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_CUSTOMS =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_CUSTOMS;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_LANE_DRIVING_DIRECTION =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_LANE_DRIVING_DIRECTION;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_BUS_LANE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_BUS_LANE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_VEHICLE_LANE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_VEHICLE_LANE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_NON_MOTOR_VEHICLE_LANE =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_NON_MOTOR_VEHICLE_LANE;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_BRT_Lane =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_BRT_Lane;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_HOV_Lane =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_HOV_Lane;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_PARKING =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_PARKING;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_SIGN_TYPE_COUNT =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SIGN_TYPE_COUNT;
  static const TrafficSignType TRAFFIC_SIGN_TYPE_SIGN_TYPE_UNKNOWN =
    ObjectInfo_TrafficSignType_TRAFFIC_SIGN_TYPE_SIGN_TYPE_UNKNOWN;
  static inline bool TrafficSignType_IsValid(int value) {
    return ObjectInfo_TrafficSignType_IsValid(value);
  }
  static const TrafficSignType TrafficSignType_MIN =
    ObjectInfo_TrafficSignType_TrafficSignType_MIN;
  static const TrafficSignType TrafficSignType_MAX =
    ObjectInfo_TrafficSignType_TrafficSignType_MAX;
  static const int TrafficSignType_ARRAYSIZE =
    ObjectInfo_TrafficSignType_TrafficSignType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TrafficSignType_descriptor() {
    return ObjectInfo_TrafficSignType_descriptor();
  }
  static inline const ::std::string& TrafficSignType_Name(TrafficSignType value) {
    return ObjectInfo_TrafficSignType_Name(value);
  }
  static inline bool TrafficSignType_Parse(const ::std::string& name,
      TrafficSignType* value) {
    return ObjectInfo_TrafficSignType_Parse(name, value);
  }

  typedef ObjectInfo_MarkingColor MarkingColor;
  static const MarkingColor MARKING_COLOR_UNKNOWN =
    ObjectInfo_MarkingColor_MARKING_COLOR_UNKNOWN;
  static const MarkingColor MARKING_COLOR_LIGHT_GRAY =
    ObjectInfo_MarkingColor_MARKING_COLOR_LIGHT_GRAY;
  static const MarkingColor MARKING_COLOR_GRAY =
    ObjectInfo_MarkingColor_MARKING_COLOR_GRAY;
  static const MarkingColor MARKING_COLOR_DARK_GRAY =
    ObjectInfo_MarkingColor_MARKING_COLOR_DARK_GRAY;
  static const MarkingColor MARKING_COLOR_BLACK =
    ObjectInfo_MarkingColor_MARKING_COLOR_BLACK;
  static const MarkingColor MARKING_COLOR_RED =
    ObjectInfo_MarkingColor_MARKING_COLOR_RED;
  static const MarkingColor MARKING_COLOR_YELLOW =
    ObjectInfo_MarkingColor_MARKING_COLOR_YELLOW;
  static const MarkingColor MARKING_COLOR_GREEN =
    ObjectInfo_MarkingColor_MARKING_COLOR_GREEN;
  static const MarkingColor MARKING_COLOR_CYAN =
    ObjectInfo_MarkingColor_MARKING_COLOR_CYAN;
  static const MarkingColor MARKING_COLOR_BLUE =
    ObjectInfo_MarkingColor_MARKING_COLOR_BLUE;
  static const MarkingColor MARKING_COLOR_ORANGE =
    ObjectInfo_MarkingColor_MARKING_COLOR_ORANGE;
  static const MarkingColor MARKING_COLOR_WHITE =
    ObjectInfo_MarkingColor_MARKING_COLOR_WHITE;
  static inline bool MarkingColor_IsValid(int value) {
    return ObjectInfo_MarkingColor_IsValid(value);
  }
  static const MarkingColor MarkingColor_MIN =
    ObjectInfo_MarkingColor_MarkingColor_MIN;
  static const MarkingColor MarkingColor_MAX =
    ObjectInfo_MarkingColor_MarkingColor_MAX;
  static const int MarkingColor_ARRAYSIZE =
    ObjectInfo_MarkingColor_MarkingColor_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MarkingColor_descriptor() {
    return ObjectInfo_MarkingColor_descriptor();
  }
  static inline const ::std::string& MarkingColor_Name(MarkingColor value) {
    return ObjectInfo_MarkingColor_Name(value);
  }
  static inline bool MarkingColor_Parse(const ::std::string& name,
      MarkingColor* value) {
    return ObjectInfo_MarkingColor_Parse(name, value);
  }

  typedef ObjectInfo_MarkingType MarkingType;
  static const MarkingType MARKING_TYPE_UNDEFINED =
    ObjectInfo_MarkingType_MARKING_TYPE_UNDEFINED;
  static const MarkingType MARKING_TYPE_ARROW_STRAIGHT =
    ObjectInfo_MarkingType_MARKING_TYPE_ARROW_STRAIGHT;
  static const MarkingType MARKING_TYPE_ARROW_LEFT =
    ObjectInfo_MarkingType_MARKING_TYPE_ARROW_LEFT;
  static const MarkingType MARKING_TYPE_ARROW_RIGHT =
    ObjectInfo_MarkingType_MARKING_TYPE_ARROW_RIGHT;
  static const MarkingType MARKING_TYPE_ARROW_STRAIGHT_AND_LEFT =
    ObjectInfo_MarkingType_MARKING_TYPE_ARROW_STRAIGHT_AND_LEFT;
  static const MarkingType MARKING_TYPE_ARROW_STRAIGHT_AND_RIGHT =
    ObjectInfo_MarkingType_MARKING_TYPE_ARROW_STRAIGHT_AND_RIGHT;
  static const MarkingType MARKING_TYPE_ARROW_LEFT_AND_RIGHT =
    ObjectInfo_MarkingType_MARKING_TYPE_ARROW_LEFT_AND_RIGHT;
  static const MarkingType MARKING_TYPE_LINE_ELEMENT =
    ObjectInfo_MarkingType_MARKING_TYPE_LINE_ELEMENT;
  static const MarkingType MARKING_TYPE_STOP_LINE =
    ObjectInfo_MarkingType_MARKING_TYPE_STOP_LINE;
  static const MarkingType MARKING_TYPE_CROSSWALK =
    ObjectInfo_MarkingType_MARKING_TYPE_CROSSWALK;
  static const MarkingType MARKING_TYPE_SIGN =
    ObjectInfo_MarkingType_MARKING_TYPE_SIGN;
  static const MarkingType MARKING_TYPE_DASHED_LINE_ELEMENT =
    ObjectInfo_MarkingType_MARKING_TYPE_DASHED_LINE_ELEMENT;
  static const MarkingType MARKING_TYPE_YIELD_INDICATION =
    ObjectInfo_MarkingType_MARKING_TYPE_YIELD_INDICATION;
  static const MarkingType MARKING_TYPE_VISUAL_SPEED_BUMP =
    ObjectInfo_MarkingType_MARKING_TYPE_VISUAL_SPEED_BUMP;
  static const MarkingType MARKING_TYPE_SHADED_AREA =
    ObjectInfo_MarkingType_MARKING_TYPE_SHADED_AREA;
  static const MarkingType MARKING_TYPE_OTHER =
    ObjectInfo_MarkingType_MARKING_TYPE_OTHER;
  static const MarkingType MARKING_TYPE_TEXT =
    ObjectInfo_MarkingType_MARKING_TYPE_TEXT;
  static inline bool MarkingType_IsValid(int value) {
    return ObjectInfo_MarkingType_IsValid(value);
  }
  static const MarkingType MarkingType_MIN =
    ObjectInfo_MarkingType_MarkingType_MIN;
  static const MarkingType MarkingType_MAX =
    ObjectInfo_MarkingType_MarkingType_MAX;
  static const int MarkingType_ARRAYSIZE =
    ObjectInfo_MarkingType_MarkingType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MarkingType_descriptor() {
    return ObjectInfo_MarkingType_descriptor();
  }
  static inline const ::std::string& MarkingType_Name(MarkingType value) {
    return ObjectInfo_MarkingType_Name(value);
  }
  static inline bool MarkingType_Parse(const ::std::string& name,
      MarkingType* value) {
    return ObjectInfo_MarkingType_Parse(name, value);
  }

  typedef ObjectInfo_MarkingGeometryType MarkingGeometryType;
  static const MarkingGeometryType MARKING_GEOMETRY_TYPE_UNDEFINED =
    ObjectInfo_MarkingGeometryType_MARKING_GEOMETRY_TYPE_UNDEFINED;
  static const MarkingGeometryType MARKING_GEOMETRY_TYPE_BOUNDARY_BOX =
    ObjectInfo_MarkingGeometryType_MARKING_GEOMETRY_TYPE_BOUNDARY_BOX;
  static const MarkingGeometryType MARKING_GEOMETRY_TYPE_CENTER_LINE =
    ObjectInfo_MarkingGeometryType_MARKING_GEOMETRY_TYPE_CENTER_LINE;
  static inline bool MarkingGeometryType_IsValid(int value) {
    return ObjectInfo_MarkingGeometryType_IsValid(value);
  }
  static const MarkingGeometryType MarkingGeometryType_MIN =
    ObjectInfo_MarkingGeometryType_MarkingGeometryType_MIN;
  static const MarkingGeometryType MarkingGeometryType_MAX =
    ObjectInfo_MarkingGeometryType_MarkingGeometryType_MAX;
  static const int MarkingGeometryType_ARRAYSIZE =
    ObjectInfo_MarkingGeometryType_MarkingGeometryType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MarkingGeometryType_descriptor() {
    return ObjectInfo_MarkingGeometryType_descriptor();
  }
  static inline const ::std::string& MarkingGeometryType_Name(MarkingGeometryType value) {
    return ObjectInfo_MarkingGeometryType_Name(value);
  }
  static inline bool MarkingGeometryType_Parse(const ::std::string& name,
      MarkingGeometryType* value) {
    return ObjectInfo_MarkingGeometryType_Parse(name, value);
  }

  typedef ObjectInfo_PoleObjectType PoleObjectType;
  static const PoleObjectType POLE_OBJECT_TYPE_UNDEFINED =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_UNDEFINED;
  static const PoleObjectType POLE_OBJECT_TYPE_LIGHT_POLE =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_LIGHT_POLE;
  static const PoleObjectType POLE_OBJECT_TYPE_DELINEATOR_POST =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_DELINEATOR_POST;
  static const PoleObjectType POLE_OBJECT_TYPE_REFLECTOR_POST =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_REFLECTOR_POST;
  static const PoleObjectType POLE_OBJECT_TYPE_GANTRY_POLE =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_GANTRY_POLE;
  static const PoleObjectType POLE_OBJECT_TYPE_SIGNPOST =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_SIGNPOST;
  static const PoleObjectType POLE_OBJECT_TYPE_OTHER =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_OTHER;
  static const PoleObjectType POLE_OBJECT_TYPE_UNCLASSIFIED =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_UNCLASSIFIED;
  static const PoleObjectType POLE_OBJECT_TYPE_GUARDRAIL_POST =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_GUARDRAIL_POST;
  static const PoleObjectType POLE_OBJECT_TYPE_UNKNOWN =
    ObjectInfo_PoleObjectType_POLE_OBJECT_TYPE_UNKNOWN;
  static inline bool PoleObjectType_IsValid(int value) {
    return ObjectInfo_PoleObjectType_IsValid(value);
  }
  static const PoleObjectType PoleObjectType_MIN =
    ObjectInfo_PoleObjectType_PoleObjectType_MIN;
  static const PoleObjectType PoleObjectType_MAX =
    ObjectInfo_PoleObjectType_PoleObjectType_MAX;
  static const int PoleObjectType_ARRAYSIZE =
    ObjectInfo_PoleObjectType_PoleObjectType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PoleObjectType_descriptor() {
    return ObjectInfo_PoleObjectType_descriptor();
  }
  static inline const ::std::string& PoleObjectType_Name(PoleObjectType value) {
    return ObjectInfo_PoleObjectType_Name(value);
  }
  static inline bool PoleObjectType_Parse(const ::std::string& name,
      PoleObjectType* value) {
    return ObjectInfo_PoleObjectType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated uint64 road_ids = 13 [packed = true];
  int road_ids_size() const;
  void clear_road_ids();
  static const int kRoadIdsFieldNumber = 13;
  ::google::protobuf::uint64 road_ids(int index) const;
  void set_road_ids(int index, ::google::protobuf::uint64 value);
  void add_road_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      road_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_road_ids();

  // repeated uint64 lane_ids = 14 [packed = true];
  int lane_ids_size() const;
  void clear_lane_ids();
  static const int kLaneIdsFieldNumber = 14;
  ::google::protobuf::uint64 lane_ids(int index) const;
  void set_lane_ids(int index, ::google::protobuf::uint64 value);
  void add_lane_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      lane_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_lane_ids();

  // repeated uint64 tile_ids = 24 [packed = true];
  int tile_ids_size() const;
  void clear_tile_ids();
  static const int kTileIdsFieldNumber = 24;
  ::google::protobuf::uint64 tile_ids(int index) const;
  void set_tile_ids(int index, ::google::protobuf::uint64 value);
  void add_tile_ids(::google::protobuf::uint64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      tile_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_tile_ids();

  // map<uint32, .holo.map.proto.common.GeoBox> extra_region = 35;
  int extra_region_size() const;
  void clear_extra_region();
  static const int kExtraRegionFieldNumber = 35;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox >&
      extra_region() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox >*
      mutable_extra_region();

  // map<uint32, .holo.map.proto.common.GeoPoint> extra_object_geo_point = 37;
  int extra_object_geo_point_size() const;
  void clear_extra_object_geo_point();
  static const int kExtraObjectGeoPointFieldNumber = 37;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoPoint >&
      extra_object_geo_point() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoPoint >*
      mutable_extra_object_geo_point();

  // repeated .holo.map.proto.common.GeoLine object_geo_lines = 38;
  int object_geo_lines_size() const;
  void clear_object_geo_lines();
  static const int kObjectGeoLinesFieldNumber = 38;
  ::holo::map::proto::common::GeoLine* mutable_object_geo_lines(int index);
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoLine >*
      mutable_object_geo_lines();
  const ::holo::map::proto::common::GeoLine& object_geo_lines(int index) const;
  ::holo::map::proto::common::GeoLine* add_object_geo_lines();
  const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoLine >&
      object_geo_lines() const;

  // map<uint32, .holo.map.proto.common.GeoMultiLine> extra_object_geo_lines = 39;
  int extra_object_geo_lines_size() const;
  void clear_extra_object_geo_lines();
  static const int kExtraObjectGeoLinesFieldNumber = 39;
  const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoMultiLine >&
      extra_object_geo_lines() const;
  ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoMultiLine >*
      mutable_extra_object_geo_lines();

  // optional .holo.map.proto.common.Coordinate coordinate = 30;
  bool has_coordinate() const;
  void clear_coordinate();
  static const int kCoordinateFieldNumber = 30;
  private:
  const ::holo::map::proto::common::Coordinate& _internal_coordinate() const;
  public:
  const ::holo::map::proto::common::Coordinate& coordinate() const;
  ::holo::map::proto::common::Coordinate* release_coordinate();
  ::holo::map::proto::common::Coordinate* mutable_coordinate();
  void set_allocated_coordinate(::holo::map::proto::common::Coordinate* coordinate);

  // optional .holo.map.proto.common.GeoBox region = 34;
  bool has_region() const;
  void clear_region();
  static const int kRegionFieldNumber = 34;
  private:
  const ::holo::map::proto::common::GeoBox& _internal_region() const;
  public:
  const ::holo::map::proto::common::GeoBox& region() const;
  ::holo::map::proto::common::GeoBox* release_region();
  ::holo::map::proto::common::GeoBox* mutable_region();
  void set_allocated_region(::holo::map::proto::common::GeoBox* region);

  // optional .holo.map.proto.common.GeoPoint object_geo_point = 36;
  bool has_object_geo_point() const;
  void clear_object_geo_point();
  static const int kObjectGeoPointFieldNumber = 36;
  private:
  const ::holo::map::proto::common::GeoPoint& _internal_object_geo_point() const;
  public:
  const ::holo::map::proto::common::GeoPoint& object_geo_point() const;
  ::holo::map::proto::common::GeoPoint* release_object_geo_point();
  ::holo::map::proto::common::GeoPoint* mutable_object_geo_point();
  void set_allocated_object_geo_point(::holo::map::proto::common::GeoPoint* object_geo_point);

  // optional uint64 object_id = 1;
  bool has_object_id() const;
  void clear_object_id();
  static const int kObjectIdFieldNumber = 1;
  ::google::protobuf::uint64 object_id() const;
  void set_object_id(::google::protobuf::uint64 value);

  // optional .holo.map.proto.base.ObjectInfo.ObjectType object_type = 2;
  bool has_object_type() const;
  void clear_object_type();
  static const int kObjectTypeFieldNumber = 2;
  ::holo::map::proto::base::ObjectInfo_ObjectType object_type() const;
  void set_object_type(::holo::map::proto::base::ObjectInfo_ObjectType value);

  // optional int32 height_cm = 3;
  bool has_height_cm() const;
  void clear_height_cm();
  static const int kHeightCmFieldNumber = 3;
  ::google::protobuf::int32 height_cm() const;
  void set_height_cm(::google::protobuf::int32 value);

  // optional .holo.map.proto.base.ObjectInfo.TrafficSignShape traffic_sign_shape = 4;
  bool has_traffic_sign_shape() const;
  void clear_traffic_sign_shape();
  static const int kTrafficSignShapeFieldNumber = 4;
  ::holo::map::proto::base::ObjectInfo_TrafficSignShape traffic_sign_shape() const;
  void set_traffic_sign_shape(::holo::map::proto::base::ObjectInfo_TrafficSignShape value);

  // optional .holo.map.proto.base.ObjectInfo.TrafficSignType traffic_sign_type = 5;
  bool has_traffic_sign_type() const;
  void clear_traffic_sign_type();
  static const int kTrafficSignTypeFieldNumber = 5;
  ::holo::map::proto::base::ObjectInfo_TrafficSignType traffic_sign_type() const;
  void set_traffic_sign_type(::holo::map::proto::base::ObjectInfo_TrafficSignType value);

  // optional uint32 pole_upper_dm = 6;
  bool has_pole_upper_dm() const;
  void clear_pole_upper_dm();
  static const int kPoleUpperDmFieldNumber = 6;
  ::google::protobuf::uint32 pole_upper_dm() const;
  void set_pole_upper_dm(::google::protobuf::uint32 value);

  // optional uint32 pole_lower_dm = 7;
  bool has_pole_lower_dm() const;
  void clear_pole_lower_dm();
  static const int kPoleLowerDmFieldNumber = 7;
  ::google::protobuf::uint32 pole_lower_dm() const;
  void set_pole_lower_dm(::google::protobuf::uint32 value);

  // optional .holo.map.proto.base.ObjectInfo.MarkingColor marking_color = 8;
  bool has_marking_color() const;
  void clear_marking_color();
  static const int kMarkingColorFieldNumber = 8;
  ::holo::map::proto::base::ObjectInfo_MarkingColor marking_color() const;
  void set_marking_color(::holo::map::proto::base::ObjectInfo_MarkingColor value);

  // optional .holo.map.proto.base.ObjectInfo.MarkingType marking_type = 9;
  bool has_marking_type() const;
  void clear_marking_type();
  static const int kMarkingTypeFieldNumber = 9;
  ::holo::map::proto::base::ObjectInfo_MarkingType marking_type() const;
  void set_marking_type(::holo::map::proto::base::ObjectInfo_MarkingType value);

  // optional .holo.map.proto.base.ObjectInfo.MarkingGeometryType marking_geometry_type = 10;
  bool has_marking_geometry_type() const;
  void clear_marking_geometry_type();
  static const int kMarkingGeometryTypeFieldNumber = 10;
  ::holo::map::proto::base::ObjectInfo_MarkingGeometryType marking_geometry_type() const;
  void set_marking_geometry_type(::holo::map::proto::base::ObjectInfo_MarkingGeometryType value);

  // optional .holo.map.proto.base.ObjectInfo.PoleObjectType pole_object_type = 11;
  bool has_pole_object_type() const;
  void clear_pole_object_type();
  static const int kPoleObjectTypeFieldNumber = 11;
  ::holo::map::proto::base::ObjectInfo_PoleObjectType pole_object_type() const;
  void set_pole_object_type(::holo::map::proto::base::ObjectInfo_PoleObjectType value);

  // optional uint64 object_info_id = 25;
  bool has_object_info_id() const;
  void clear_object_info_id();
  static const int kObjectInfoIdFieldNumber = 25;
  ::google::protobuf::uint64 object_info_id() const;
  void set_object_info_id(::google::protobuf::uint64 value);

  // optional bool south_flag = 33;
  bool has_south_flag() const;
  void clear_south_flag();
  static const int kSouthFlagFieldNumber = 33;
  bool south_flag() const;
  void set_south_flag(bool value);

  // optional uint32 zone_id = 31;
  bool has_zone_id() const;
  void clear_zone_id();
  static const int kZoneIdFieldNumber = 31;
  ::google::protobuf::uint32 zone_id() const;
  void set_zone_id(::google::protobuf::uint32 value);

  // optional uint32 extra_zone_id = 32;
  bool has_extra_zone_id() const;
  void clear_extra_zone_id();
  static const int kExtraZoneIdFieldNumber = 32;
  ::google::protobuf::uint32 extra_zone_id() const;
  void set_extra_zone_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:holo.map.proto.base.ObjectInfo)
 private:
  void set_has_object_id();
  void clear_has_object_id();
  void set_has_object_type();
  void clear_has_object_type();
  void set_has_height_cm();
  void clear_has_height_cm();
  void set_has_traffic_sign_shape();
  void clear_has_traffic_sign_shape();
  void set_has_traffic_sign_type();
  void clear_has_traffic_sign_type();
  void set_has_pole_upper_dm();
  void clear_has_pole_upper_dm();
  void set_has_pole_lower_dm();
  void clear_has_pole_lower_dm();
  void set_has_marking_color();
  void clear_has_marking_color();
  void set_has_marking_type();
  void clear_has_marking_type();
  void set_has_marking_geometry_type();
  void clear_has_marking_geometry_type();
  void set_has_pole_object_type();
  void clear_has_pole_object_type();
  void set_has_object_info_id();
  void clear_has_object_info_id();
  void set_has_coordinate();
  void clear_has_coordinate();
  void set_has_zone_id();
  void clear_has_zone_id();
  void set_has_extra_zone_id();
  void clear_has_extra_zone_id();
  void set_has_south_flag();
  void clear_has_south_flag();
  void set_has_region();
  void clear_has_region();
  void set_has_object_geo_point();
  void clear_has_object_geo_point();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > road_ids_;
  mutable int _road_ids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > lane_ids_;
  mutable int _lane_ids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > tile_ids_;
  mutable int _tile_ids_cached_byte_size_;
  ::google::protobuf::internal::MapField<
      ObjectInfo_ExtraRegionEntry_DoNotUse,
      ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > extra_region_;
  ::google::protobuf::internal::MapField<
      ObjectInfo_ExtraObjectGeoPointEntry_DoNotUse,
      ::google::protobuf::uint32, ::holo::map::proto::common::GeoPoint,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > extra_object_geo_point_;
  ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoLine > object_geo_lines_;
  ::google::protobuf::internal::MapField<
      ObjectInfo_ExtraObjectGeoLinesEntry_DoNotUse,
      ::google::protobuf::uint32, ::holo::map::proto::common::GeoMultiLine,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > extra_object_geo_lines_;
  ::holo::map::proto::common::Coordinate* coordinate_;
  ::holo::map::proto::common::GeoBox* region_;
  ::holo::map::proto::common::GeoPoint* object_geo_point_;
  ::google::protobuf::uint64 object_id_;
  int object_type_;
  ::google::protobuf::int32 height_cm_;
  int traffic_sign_shape_;
  int traffic_sign_type_;
  ::google::protobuf::uint32 pole_upper_dm_;
  ::google::protobuf::uint32 pole_lower_dm_;
  int marking_color_;
  int marking_type_;
  int marking_geometry_type_;
  int pole_object_type_;
  ::google::protobuf::uint64 object_info_id_;
  bool south_flag_;
  ::google::protobuf::uint32 zone_id_;
  ::google::protobuf::uint32 extra_zone_id_;
  friend struct ::protobuf_holo_2fmap_2fproto_2fbase_2fobject_5finfo_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ObjectInfo

// optional uint64 object_id = 1;
inline bool ObjectInfo::has_object_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ObjectInfo::set_has_object_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ObjectInfo::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ObjectInfo::clear_object_id() {
  object_id_ = GOOGLE_ULONGLONG(0);
  clear_has_object_id();
}
inline ::google::protobuf::uint64 ObjectInfo::object_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.object_id)
  return object_id_;
}
inline void ObjectInfo::set_object_id(::google::protobuf::uint64 value) {
  set_has_object_id();
  object_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.object_id)
}

// optional .holo.map.proto.base.ObjectInfo.ObjectType object_type = 2;
inline bool ObjectInfo::has_object_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ObjectInfo::set_has_object_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ObjectInfo::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ObjectInfo::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::holo::map::proto::base::ObjectInfo_ObjectType ObjectInfo::object_type() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.object_type)
  return static_cast< ::holo::map::proto::base::ObjectInfo_ObjectType >(object_type_);
}
inline void ObjectInfo::set_object_type(::holo::map::proto::base::ObjectInfo_ObjectType value) {
  assert(::holo::map::proto::base::ObjectInfo_ObjectType_IsValid(value));
  set_has_object_type();
  object_type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.object_type)
}

// optional int32 height_cm = 3;
inline bool ObjectInfo::has_height_cm() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ObjectInfo::set_has_height_cm() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ObjectInfo::clear_has_height_cm() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ObjectInfo::clear_height_cm() {
  height_cm_ = 0;
  clear_has_height_cm();
}
inline ::google::protobuf::int32 ObjectInfo::height_cm() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.height_cm)
  return height_cm_;
}
inline void ObjectInfo::set_height_cm(::google::protobuf::int32 value) {
  set_has_height_cm();
  height_cm_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.height_cm)
}

// optional .holo.map.proto.base.ObjectInfo.TrafficSignShape traffic_sign_shape = 4;
inline bool ObjectInfo::has_traffic_sign_shape() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ObjectInfo::set_has_traffic_sign_shape() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ObjectInfo::clear_has_traffic_sign_shape() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ObjectInfo::clear_traffic_sign_shape() {
  traffic_sign_shape_ = 0;
  clear_has_traffic_sign_shape();
}
inline ::holo::map::proto::base::ObjectInfo_TrafficSignShape ObjectInfo::traffic_sign_shape() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.traffic_sign_shape)
  return static_cast< ::holo::map::proto::base::ObjectInfo_TrafficSignShape >(traffic_sign_shape_);
}
inline void ObjectInfo::set_traffic_sign_shape(::holo::map::proto::base::ObjectInfo_TrafficSignShape value) {
  assert(::holo::map::proto::base::ObjectInfo_TrafficSignShape_IsValid(value));
  set_has_traffic_sign_shape();
  traffic_sign_shape_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.traffic_sign_shape)
}

// optional .holo.map.proto.base.ObjectInfo.TrafficSignType traffic_sign_type = 5;
inline bool ObjectInfo::has_traffic_sign_type() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ObjectInfo::set_has_traffic_sign_type() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ObjectInfo::clear_has_traffic_sign_type() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ObjectInfo::clear_traffic_sign_type() {
  traffic_sign_type_ = 0;
  clear_has_traffic_sign_type();
}
inline ::holo::map::proto::base::ObjectInfo_TrafficSignType ObjectInfo::traffic_sign_type() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.traffic_sign_type)
  return static_cast< ::holo::map::proto::base::ObjectInfo_TrafficSignType >(traffic_sign_type_);
}
inline void ObjectInfo::set_traffic_sign_type(::holo::map::proto::base::ObjectInfo_TrafficSignType value) {
  assert(::holo::map::proto::base::ObjectInfo_TrafficSignType_IsValid(value));
  set_has_traffic_sign_type();
  traffic_sign_type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.traffic_sign_type)
}

// optional uint32 pole_upper_dm = 6;
inline bool ObjectInfo::has_pole_upper_dm() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ObjectInfo::set_has_pole_upper_dm() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ObjectInfo::clear_has_pole_upper_dm() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ObjectInfo::clear_pole_upper_dm() {
  pole_upper_dm_ = 0u;
  clear_has_pole_upper_dm();
}
inline ::google::protobuf::uint32 ObjectInfo::pole_upper_dm() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.pole_upper_dm)
  return pole_upper_dm_;
}
inline void ObjectInfo::set_pole_upper_dm(::google::protobuf::uint32 value) {
  set_has_pole_upper_dm();
  pole_upper_dm_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.pole_upper_dm)
}

// optional uint32 pole_lower_dm = 7;
inline bool ObjectInfo::has_pole_lower_dm() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ObjectInfo::set_has_pole_lower_dm() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ObjectInfo::clear_has_pole_lower_dm() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ObjectInfo::clear_pole_lower_dm() {
  pole_lower_dm_ = 0u;
  clear_has_pole_lower_dm();
}
inline ::google::protobuf::uint32 ObjectInfo::pole_lower_dm() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.pole_lower_dm)
  return pole_lower_dm_;
}
inline void ObjectInfo::set_pole_lower_dm(::google::protobuf::uint32 value) {
  set_has_pole_lower_dm();
  pole_lower_dm_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.pole_lower_dm)
}

// optional .holo.map.proto.base.ObjectInfo.MarkingColor marking_color = 8;
inline bool ObjectInfo::has_marking_color() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ObjectInfo::set_has_marking_color() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ObjectInfo::clear_has_marking_color() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ObjectInfo::clear_marking_color() {
  marking_color_ = 0;
  clear_has_marking_color();
}
inline ::holo::map::proto::base::ObjectInfo_MarkingColor ObjectInfo::marking_color() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.marking_color)
  return static_cast< ::holo::map::proto::base::ObjectInfo_MarkingColor >(marking_color_);
}
inline void ObjectInfo::set_marking_color(::holo::map::proto::base::ObjectInfo_MarkingColor value) {
  assert(::holo::map::proto::base::ObjectInfo_MarkingColor_IsValid(value));
  set_has_marking_color();
  marking_color_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.marking_color)
}

// optional .holo.map.proto.base.ObjectInfo.MarkingType marking_type = 9;
inline bool ObjectInfo::has_marking_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ObjectInfo::set_has_marking_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ObjectInfo::clear_has_marking_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ObjectInfo::clear_marking_type() {
  marking_type_ = 0;
  clear_has_marking_type();
}
inline ::holo::map::proto::base::ObjectInfo_MarkingType ObjectInfo::marking_type() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.marking_type)
  return static_cast< ::holo::map::proto::base::ObjectInfo_MarkingType >(marking_type_);
}
inline void ObjectInfo::set_marking_type(::holo::map::proto::base::ObjectInfo_MarkingType value) {
  assert(::holo::map::proto::base::ObjectInfo_MarkingType_IsValid(value));
  set_has_marking_type();
  marking_type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.marking_type)
}

// optional .holo.map.proto.base.ObjectInfo.MarkingGeometryType marking_geometry_type = 10;
inline bool ObjectInfo::has_marking_geometry_type() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ObjectInfo::set_has_marking_geometry_type() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ObjectInfo::clear_has_marking_geometry_type() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ObjectInfo::clear_marking_geometry_type() {
  marking_geometry_type_ = 0;
  clear_has_marking_geometry_type();
}
inline ::holo::map::proto::base::ObjectInfo_MarkingGeometryType ObjectInfo::marking_geometry_type() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.marking_geometry_type)
  return static_cast< ::holo::map::proto::base::ObjectInfo_MarkingGeometryType >(marking_geometry_type_);
}
inline void ObjectInfo::set_marking_geometry_type(::holo::map::proto::base::ObjectInfo_MarkingGeometryType value) {
  assert(::holo::map::proto::base::ObjectInfo_MarkingGeometryType_IsValid(value));
  set_has_marking_geometry_type();
  marking_geometry_type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.marking_geometry_type)
}

// optional .holo.map.proto.base.ObjectInfo.PoleObjectType pole_object_type = 11;
inline bool ObjectInfo::has_pole_object_type() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ObjectInfo::set_has_pole_object_type() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ObjectInfo::clear_has_pole_object_type() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ObjectInfo::clear_pole_object_type() {
  pole_object_type_ = 0;
  clear_has_pole_object_type();
}
inline ::holo::map::proto::base::ObjectInfo_PoleObjectType ObjectInfo::pole_object_type() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.pole_object_type)
  return static_cast< ::holo::map::proto::base::ObjectInfo_PoleObjectType >(pole_object_type_);
}
inline void ObjectInfo::set_pole_object_type(::holo::map::proto::base::ObjectInfo_PoleObjectType value) {
  assert(::holo::map::proto::base::ObjectInfo_PoleObjectType_IsValid(value));
  set_has_pole_object_type();
  pole_object_type_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.pole_object_type)
}

// repeated uint64 road_ids = 13 [packed = true];
inline int ObjectInfo::road_ids_size() const {
  return road_ids_.size();
}
inline void ObjectInfo::clear_road_ids() {
  road_ids_.Clear();
}
inline ::google::protobuf::uint64 ObjectInfo::road_ids(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.road_ids)
  return road_ids_.Get(index);
}
inline void ObjectInfo::set_road_ids(int index, ::google::protobuf::uint64 value) {
  road_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.road_ids)
}
inline void ObjectInfo::add_road_ids(::google::protobuf::uint64 value) {
  road_ids_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.proto.base.ObjectInfo.road_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ObjectInfo::road_ids() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.ObjectInfo.road_ids)
  return road_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ObjectInfo::mutable_road_ids() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.ObjectInfo.road_ids)
  return &road_ids_;
}

// repeated uint64 lane_ids = 14 [packed = true];
inline int ObjectInfo::lane_ids_size() const {
  return lane_ids_.size();
}
inline void ObjectInfo::clear_lane_ids() {
  lane_ids_.Clear();
}
inline ::google::protobuf::uint64 ObjectInfo::lane_ids(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.lane_ids)
  return lane_ids_.Get(index);
}
inline void ObjectInfo::set_lane_ids(int index, ::google::protobuf::uint64 value) {
  lane_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.lane_ids)
}
inline void ObjectInfo::add_lane_ids(::google::protobuf::uint64 value) {
  lane_ids_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.proto.base.ObjectInfo.lane_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ObjectInfo::lane_ids() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.ObjectInfo.lane_ids)
  return lane_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ObjectInfo::mutable_lane_ids() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.ObjectInfo.lane_ids)
  return &lane_ids_;
}

// repeated uint64 tile_ids = 24 [packed = true];
inline int ObjectInfo::tile_ids_size() const {
  return tile_ids_.size();
}
inline void ObjectInfo::clear_tile_ids() {
  tile_ids_.Clear();
}
inline ::google::protobuf::uint64 ObjectInfo::tile_ids(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.tile_ids)
  return tile_ids_.Get(index);
}
inline void ObjectInfo::set_tile_ids(int index, ::google::protobuf::uint64 value) {
  tile_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.tile_ids)
}
inline void ObjectInfo::add_tile_ids(::google::protobuf::uint64 value) {
  tile_ids_.Add(value);
  // @@protoc_insertion_point(field_add:holo.map.proto.base.ObjectInfo.tile_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ObjectInfo::tile_ids() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.ObjectInfo.tile_ids)
  return tile_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ObjectInfo::mutable_tile_ids() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.ObjectInfo.tile_ids)
  return &tile_ids_;
}

// optional uint64 object_info_id = 25;
inline bool ObjectInfo::has_object_info_id() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ObjectInfo::set_has_object_info_id() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ObjectInfo::clear_has_object_info_id() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ObjectInfo::clear_object_info_id() {
  object_info_id_ = GOOGLE_ULONGLONG(0);
  clear_has_object_info_id();
}
inline ::google::protobuf::uint64 ObjectInfo::object_info_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.object_info_id)
  return object_info_id_;
}
inline void ObjectInfo::set_object_info_id(::google::protobuf::uint64 value) {
  set_has_object_info_id();
  object_info_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.object_info_id)
}

// optional .holo.map.proto.common.Coordinate coordinate = 30;
inline bool ObjectInfo::has_coordinate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectInfo::set_has_coordinate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectInfo::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::holo::map::proto::common::Coordinate& ObjectInfo::_internal_coordinate() const {
  return *coordinate_;
}
inline const ::holo::map::proto::common::Coordinate& ObjectInfo::coordinate() const {
  const ::holo::map::proto::common::Coordinate* p = coordinate_;
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.coordinate)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::proto::common::Coordinate*>(
      &::holo::map::proto::common::_Coordinate_default_instance_);
}
inline ::holo::map::proto::common::Coordinate* ObjectInfo::release_coordinate() {
  // @@protoc_insertion_point(field_release:holo.map.proto.base.ObjectInfo.coordinate)
  clear_has_coordinate();
  ::holo::map::proto::common::Coordinate* temp = coordinate_;
  coordinate_ = NULL;
  return temp;
}
inline ::holo::map::proto::common::Coordinate* ObjectInfo::mutable_coordinate() {
  set_has_coordinate();
  if (coordinate_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::proto::common::Coordinate>(GetArenaNoVirtual());
    coordinate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.ObjectInfo.coordinate)
  return coordinate_;
}
inline void ObjectInfo::set_allocated_coordinate(::holo::map::proto::common::Coordinate* coordinate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(coordinate_);
  }
  if (coordinate) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      coordinate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, coordinate, submessage_arena);
    }
    set_has_coordinate();
  } else {
    clear_has_coordinate();
  }
  coordinate_ = coordinate;
  // @@protoc_insertion_point(field_set_allocated:holo.map.proto.base.ObjectInfo.coordinate)
}

// optional uint32 zone_id = 31;
inline bool ObjectInfo::has_zone_id() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ObjectInfo::set_has_zone_id() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ObjectInfo::clear_has_zone_id() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ObjectInfo::clear_zone_id() {
  zone_id_ = 0u;
  clear_has_zone_id();
}
inline ::google::protobuf::uint32 ObjectInfo::zone_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.zone_id)
  return zone_id_;
}
inline void ObjectInfo::set_zone_id(::google::protobuf::uint32 value) {
  set_has_zone_id();
  zone_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.zone_id)
}

// optional uint32 extra_zone_id = 32;
inline bool ObjectInfo::has_extra_zone_id() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ObjectInfo::set_has_extra_zone_id() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ObjectInfo::clear_has_extra_zone_id() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ObjectInfo::clear_extra_zone_id() {
  extra_zone_id_ = 0u;
  clear_has_extra_zone_id();
}
inline ::google::protobuf::uint32 ObjectInfo::extra_zone_id() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.extra_zone_id)
  return extra_zone_id_;
}
inline void ObjectInfo::set_extra_zone_id(::google::protobuf::uint32 value) {
  set_has_extra_zone_id();
  extra_zone_id_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.extra_zone_id)
}

// optional bool south_flag = 33;
inline bool ObjectInfo::has_south_flag() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ObjectInfo::set_has_south_flag() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ObjectInfo::clear_has_south_flag() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ObjectInfo::clear_south_flag() {
  south_flag_ = false;
  clear_has_south_flag();
}
inline bool ObjectInfo::south_flag() const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.south_flag)
  return south_flag_;
}
inline void ObjectInfo::set_south_flag(bool value) {
  set_has_south_flag();
  south_flag_ = value;
  // @@protoc_insertion_point(field_set:holo.map.proto.base.ObjectInfo.south_flag)
}

// optional .holo.map.proto.common.GeoBox region = 34;
inline bool ObjectInfo::has_region() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectInfo::set_has_region() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectInfo::clear_has_region() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::holo::map::proto::common::GeoBox& ObjectInfo::_internal_region() const {
  return *region_;
}
inline const ::holo::map::proto::common::GeoBox& ObjectInfo::region() const {
  const ::holo::map::proto::common::GeoBox* p = region_;
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.region)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::proto::common::GeoBox*>(
      &::holo::map::proto::common::_GeoBox_default_instance_);
}
inline ::holo::map::proto::common::GeoBox* ObjectInfo::release_region() {
  // @@protoc_insertion_point(field_release:holo.map.proto.base.ObjectInfo.region)
  clear_has_region();
  ::holo::map::proto::common::GeoBox* temp = region_;
  region_ = NULL;
  return temp;
}
inline ::holo::map::proto::common::GeoBox* ObjectInfo::mutable_region() {
  set_has_region();
  if (region_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::proto::common::GeoBox>(GetArenaNoVirtual());
    region_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.ObjectInfo.region)
  return region_;
}
inline void ObjectInfo::set_allocated_region(::holo::map::proto::common::GeoBox* region) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(region_);
  }
  if (region) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      region = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, region, submessage_arena);
    }
    set_has_region();
  } else {
    clear_has_region();
  }
  region_ = region;
  // @@protoc_insertion_point(field_set_allocated:holo.map.proto.base.ObjectInfo.region)
}

// map<uint32, .holo.map.proto.common.GeoBox> extra_region = 35;
inline int ObjectInfo::extra_region_size() const {
  return extra_region_.size();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox >&
ObjectInfo::extra_region() const {
  // @@protoc_insertion_point(field_map:holo.map.proto.base.ObjectInfo.extra_region)
  return extra_region_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoBox >*
ObjectInfo::mutable_extra_region() {
  // @@protoc_insertion_point(field_mutable_map:holo.map.proto.base.ObjectInfo.extra_region)
  return extra_region_.MutableMap();
}

// optional .holo.map.proto.common.GeoPoint object_geo_point = 36;
inline bool ObjectInfo::has_object_geo_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectInfo::set_has_object_geo_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectInfo::clear_has_object_geo_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::holo::map::proto::common::GeoPoint& ObjectInfo::_internal_object_geo_point() const {
  return *object_geo_point_;
}
inline const ::holo::map::proto::common::GeoPoint& ObjectInfo::object_geo_point() const {
  const ::holo::map::proto::common::GeoPoint* p = object_geo_point_;
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.object_geo_point)
  return p != NULL ? *p : *reinterpret_cast<const ::holo::map::proto::common::GeoPoint*>(
      &::holo::map::proto::common::_GeoPoint_default_instance_);
}
inline ::holo::map::proto::common::GeoPoint* ObjectInfo::release_object_geo_point() {
  // @@protoc_insertion_point(field_release:holo.map.proto.base.ObjectInfo.object_geo_point)
  clear_has_object_geo_point();
  ::holo::map::proto::common::GeoPoint* temp = object_geo_point_;
  object_geo_point_ = NULL;
  return temp;
}
inline ::holo::map::proto::common::GeoPoint* ObjectInfo::mutable_object_geo_point() {
  set_has_object_geo_point();
  if (object_geo_point_ == NULL) {
    auto* p = CreateMaybeMessage<::holo::map::proto::common::GeoPoint>(GetArenaNoVirtual());
    object_geo_point_ = p;
  }
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.ObjectInfo.object_geo_point)
  return object_geo_point_;
}
inline void ObjectInfo::set_allocated_object_geo_point(::holo::map::proto::common::GeoPoint* object_geo_point) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(object_geo_point_);
  }
  if (object_geo_point) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      object_geo_point = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, object_geo_point, submessage_arena);
    }
    set_has_object_geo_point();
  } else {
    clear_has_object_geo_point();
  }
  object_geo_point_ = object_geo_point;
  // @@protoc_insertion_point(field_set_allocated:holo.map.proto.base.ObjectInfo.object_geo_point)
}

// map<uint32, .holo.map.proto.common.GeoPoint> extra_object_geo_point = 37;
inline int ObjectInfo::extra_object_geo_point_size() const {
  return extra_object_geo_point_.size();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoPoint >&
ObjectInfo::extra_object_geo_point() const {
  // @@protoc_insertion_point(field_map:holo.map.proto.base.ObjectInfo.extra_object_geo_point)
  return extra_object_geo_point_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoPoint >*
ObjectInfo::mutable_extra_object_geo_point() {
  // @@protoc_insertion_point(field_mutable_map:holo.map.proto.base.ObjectInfo.extra_object_geo_point)
  return extra_object_geo_point_.MutableMap();
}

// repeated .holo.map.proto.common.GeoLine object_geo_lines = 38;
inline int ObjectInfo::object_geo_lines_size() const {
  return object_geo_lines_.size();
}
inline ::holo::map::proto::common::GeoLine* ObjectInfo::mutable_object_geo_lines(int index) {
  // @@protoc_insertion_point(field_mutable:holo.map.proto.base.ObjectInfo.object_geo_lines)
  return object_geo_lines_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoLine >*
ObjectInfo::mutable_object_geo_lines() {
  // @@protoc_insertion_point(field_mutable_list:holo.map.proto.base.ObjectInfo.object_geo_lines)
  return &object_geo_lines_;
}
inline const ::holo::map::proto::common::GeoLine& ObjectInfo::object_geo_lines(int index) const {
  // @@protoc_insertion_point(field_get:holo.map.proto.base.ObjectInfo.object_geo_lines)
  return object_geo_lines_.Get(index);
}
inline ::holo::map::proto::common::GeoLine* ObjectInfo::add_object_geo_lines() {
  // @@protoc_insertion_point(field_add:holo.map.proto.base.ObjectInfo.object_geo_lines)
  return object_geo_lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::holo::map::proto::common::GeoLine >&
ObjectInfo::object_geo_lines() const {
  // @@protoc_insertion_point(field_list:holo.map.proto.base.ObjectInfo.object_geo_lines)
  return object_geo_lines_;
}

// map<uint32, .holo.map.proto.common.GeoMultiLine> extra_object_geo_lines = 39;
inline int ObjectInfo::extra_object_geo_lines_size() const {
  return extra_object_geo_lines_.size();
}
inline const ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoMultiLine >&
ObjectInfo::extra_object_geo_lines() const {
  // @@protoc_insertion_point(field_map:holo.map.proto.base.ObjectInfo.extra_object_geo_lines)
  return extra_object_geo_lines_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::uint32, ::holo::map::proto::common::GeoMultiLine >*
ObjectInfo::mutable_extra_object_geo_lines() {
  // @@protoc_insertion_point(field_mutable_map:holo.map.proto.base.ObjectInfo.extra_object_geo_lines)
  return extra_object_geo_lines_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace base
}  // namespace proto
}  // namespace map
}  // namespace holo

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::holo::map::proto::base::ObjectInfo_ObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::ObjectInfo_ObjectType>() {
  return ::holo::map::proto::base::ObjectInfo_ObjectType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::ObjectInfo_TrafficSignShape> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::ObjectInfo_TrafficSignShape>() {
  return ::holo::map::proto::base::ObjectInfo_TrafficSignShape_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::ObjectInfo_TrafficSignType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::ObjectInfo_TrafficSignType>() {
  return ::holo::map::proto::base::ObjectInfo_TrafficSignType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::ObjectInfo_MarkingColor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::ObjectInfo_MarkingColor>() {
  return ::holo::map::proto::base::ObjectInfo_MarkingColor_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::ObjectInfo_MarkingType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::ObjectInfo_MarkingType>() {
  return ::holo::map::proto::base::ObjectInfo_MarkingType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::ObjectInfo_MarkingGeometryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::ObjectInfo_MarkingGeometryType>() {
  return ::holo::map::proto::base::ObjectInfo_MarkingGeometryType_descriptor();
}
template <> struct is_proto_enum< ::holo::map::proto::base::ObjectInfo_PoleObjectType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::holo::map::proto::base::ObjectInfo_PoleObjectType>() {
  return ::holo::map::proto::base::ObjectInfo_PoleObjectType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_holo_2fmap_2fproto_2fbase_2fobject_5finfo_2eproto
