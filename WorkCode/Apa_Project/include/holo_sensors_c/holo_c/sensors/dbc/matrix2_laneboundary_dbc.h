#ifndef HOLO_SENSORS_HORIZON_MATRIX2_HORIZON_MATRIX2_LANEBOUNDARY_DBC_H
#define HOLO_SENSORS_HORIZON_MATRIX2_HORIZON_MATRIX2_LANEBOUNDARY_DBC_H

/** \file
 * CAN DBC C-Headers
 *
 * These headers were generated by dbc2c.awk on 2020年 06月 02日 星期二 17:10:56 CST.
 *
 * The dbc2c.awk script parses Vector .dbc files, and generates C-style
 * headers with Doxygen documentation from a set of templates.
 *
 * The following databases were parsed:
 * - \ref DB_hb_Lanes
 */

/**
 * @defgroup DB_hb_Lanes CAN Database hb_Lanes
 *
 * Path to file: output/hb_Lanes.dbc
 *
 * Provides the following ECUs:
 * - \ref ECU_Matrix
 */

/**
 * @defgroup ECU_Matrix Electronics Control Unit Matrix
 *
 * This ECU was defined in \ref DB_hb_Lanes.
 *
 * TX messages:
 * - \ref MSG_Road_Information
 * - \ref MSG_Next_Right_Lane_B
 * - \ref MSG_Next_Left_Lane_B
 * - \ref MSG_Next_Right_Lane_A
 * - \ref MSG_Next_Left_Lane_A
 * - \ref MSG_LKA_Right_Lane_B
 * - \ref MSG_LKA_Right_Lane_A
 * - \ref MSG_LKA_Left_Lane_B
 * - \ref MSG_LKA_Left_Lane_A
 *
 * RX signals:
 * - \ref SIG_Road_Information_constructionArea
 * - \ref SIG_Road_Information_roadType
 * - \ref SIG_Road_Information_highwayExitRight
 * - \ref SIG_Road_Information_highwayExitLeft
 * - \ref SIG_Road_Information_Lane_Assignment_Host_Index_0m
 * - \ref SIG_Road_Information_Lane_Assignment_Host_Index_35m
 * - \ref SIG_Road_Information_NumOfLanes_0m
 * - \ref SIG_Road_Information_NumOfLanes_35m
 * - \ref SIG_Road_Information_roadCoverbySnow
 * - \ref SIG_Road_Information_wetRoad
 * - \ref SIG_Road_Information_currentWeather
 * - \ref SIG_Road_Information_reserved_road1
 * - \ref SIG_Road_Information_protocol_version
 * - \ref SIG_Next_Right_Lane_B_laneModelC1
 * - \ref SIG_Next_Right_Lane_B_viewRangeStart
 * - \ref SIG_Next_Right_Lane_B_viewRangeEnd
 * - \ref SIG_Next_Right_Lane_B_laneMarkColor
 * - \ref SIG_Next_Right_Lane_B_reserved_bits1
 * - \ref SIG_Next_Right_Lane_B_Reserved1_NextlaneB
 * - \ref SIG_Next_Left_Lane_B_laneModelC1
 * - \ref SIG_Next_Left_Lane_B_viewRangeStart
 * - \ref SIG_Next_Left_Lane_B_viewRangeEnd
 * - \ref SIG_Next_Left_Lane_B_laneMarkColor
 * - \ref SIG_Next_Left_Lane_B_reserved_bits1
 * - \ref SIG_Next_Left_Lane_B_Reserved1_NextlaneB
 * - \ref SIG_Next_Right_Lane_A_laneType
 * - \ref SIG_Next_Right_Lane_A_laneQuality
 * - \ref SIG_Next_Right_Lane_A_laneModelC0
 * - \ref SIG_Next_Right_Lane_A_laneModelC2
 * - \ref SIG_Next_Right_Lane_A_laneModelC3
 * - \ref SIG_Next_Right_Lane_A_laneWidthMarking
 * - \ref SIG_Next_Right_Lane_A_laneConfidence
 * - \ref SIG_Next_Right_Lane_A_Reserved1_NextlaneA
 * - \ref SIG_Next_Left_Lane_A_laneType
 * - \ref SIG_Next_Left_Lane_A_laneQuality
 * - \ref SIG_Next_Left_Lane_A_laneModelC0
 * - \ref SIG_Next_Left_Lane_A_laneModelC2
 * - \ref SIG_Next_Left_Lane_A_laneModelC3
 * - \ref SIG_Next_Left_Lane_A_laneWidthMarking
 * - \ref SIG_Next_Left_Lane_A_laneConfidence
 * - \ref SIG_Next_Left_Lane_A_Reserved1_NextlaneA
 * - \ref SIG_LKA_Right_Lane_B_laneModelC1
 * - \ref SIG_LKA_Right_Lane_B_viewRangeStart
 * - \ref SIG_LKA_Right_Lane_B_viewRangeEnd
 * - \ref SIG_LKA_Right_Lane_B_laneCrossing
 * - \ref SIG_LKA_Right_Lane_B_laneMarkColor
 * - \ref SIG_LKA_Right_Lane_B_Reserved1_LKAlaneB
 * - \ref SIG_LKA_Right_Lane_B_Reserved2_LKAlaneB
 * - \ref SIG_LKA_Right_Lane_B_Reserved3_LKAlaneB
 * - \ref SIG_LKA_Right_Lane_B_ttlc
 * - \ref SIG_LKA_Right_Lane_A_laneType
 * - \ref SIG_LKA_Right_Lane_A_laneQuality
 * - \ref SIG_LKA_Right_Lane_A_laneModelC0
 * - \ref SIG_LKA_Right_Lane_A_laneModelC2
 * - \ref SIG_LKA_Right_Lane_A_laneModelC3
 * - \ref SIG_LKA_Right_Lane_A_laneWidthMarking
 * - \ref SIG_LKA_Right_Lane_A_laneConfidence
 * - \ref SIG_LKA_Right_Lane_A_Reserved1_LKAlaneA
 * - \ref SIG_LKA_Left_Lane_B_laneModelC1
 * - \ref SIG_LKA_Left_Lane_B_viewRangeStart
 * - \ref SIG_LKA_Left_Lane_B_viewRangeEnd
 * - \ref SIG_LKA_Left_Lane_B_laneCrossing
 * - \ref SIG_LKA_Left_Lane_B_laneMarkColor
 * - \ref SIG_LKA_Left_Lane_B_Reserved1_LKAlaneB
 * - \ref SIG_LKA_Left_Lane_B_Reserved2_LKAlaneB
 * - \ref SIG_LKA_Left_Lane_B_Reserved3_LKAlaneB
 * - \ref SIG_LKA_Left_Lane_B_ttlc
 * - \ref SIG_LKA_Left_Lane_A_laneType
 * - \ref SIG_LKA_Left_Lane_A_laneQuality
 * - \ref SIG_LKA_Left_Lane_A_laneModelC0
 * - \ref SIG_LKA_Left_Lane_A_laneModelC2
 * - \ref SIG_LKA_Left_Lane_A_laneModelC3
 * - \ref SIG_LKA_Left_Lane_A_laneWidthMarking
 * - \ref SIG_LKA_Left_Lane_A_laneConfidence
 * - \ref SIG_LKA_Left_Lane_A_Reserved1_LKAlaneA
 *
 * @ingroup DB_hb_Lanes
 */

/**
 * @defgroup MSG_Road_Information Message Road_Information (0x500)
 *
 * Sent by \ref ECU_Matrix.
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_Road_Information_constructionArea
 * - \ref SIG_Road_Information_roadType
 * - \ref SIG_Road_Information_highwayExitRight
 * - \ref SIG_Road_Information_highwayExitLeft
 * - \ref SIG_Road_Information_Lane_Assignment_Host_Index_0m
 * - \ref SIG_Road_Information_Lane_Assignment_Host_Index_35m
 * - \ref SIG_Road_Information_NumOfLanes_0m
 * - \ref SIG_Road_Information_NumOfLanes_35m
 * - \ref SIG_Road_Information_roadCoverbySnow
 * - \ref SIG_Road_Information_wetRoad
 * - \ref SIG_Road_Information_currentWeather
 * - \ref SIG_Road_Information_reserved_road1
 * - \ref SIG_Road_Information_protocol_version
 *
 * @ingroup ECU_Matrix
 * @{
 */

/**
 * Message Road_Information configuration tuple.
 */
#define MSG_Road_Information 0x500, 0, 8

/**
 * Message Road_Information id.
 */
#define ID_Road_Information 0x500

/**
 * Message Road_Information extended id bit.
 */
#define EXT_Road_Information 0

/**
 * Message Road_Information Data Length Count.
 */
#define DLC_Road_Information 8

/**
 * Message Road_Information cycle time.
 */
#define CYCLE_Road_Information 0

/**
 * Message Road_Information fast cycle time.
 */
#define FAST_Road_Information 0

/**
 * Initialise message Road_Information buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_Road_Information(buf)                                                                                     \
    {                                                                                                                  \
        INITSIG_Road_Information_constructionArea(buf);                                                                \
        INITSIG_Road_Information_roadType(buf);                                                                        \
        INITSIG_Road_Information_highwayExitRight(buf);                                                                \
        INITSIG_Road_Information_highwayExitLeft(buf);                                                                 \
        INITSIG_Road_Information_Lane_Assignment_Host_Index_0m(buf);                                                   \
        INITSIG_Road_Information_Lane_Assignment_Host_Index_35m(buf);                                                  \
        INITSIG_Road_Information_NumOfLanes_0m(buf);                                                                   \
        INITSIG_Road_Information_NumOfLanes_35m(buf);                                                                  \
        INITSIG_Road_Information_roadCoverbySnow(buf);                                                                 \
        INITSIG_Road_Information_wetRoad(buf);                                                                         \
        INITSIG_Road_Information_currentWeather(buf);                                                                  \
        INITSIG_Road_Information_reserved_road1(buf);                                                                  \
        INITSIG_Road_Information_protocol_version(buf);                                                                \
    }

/**
 * @}
 */

/**
 * @defgroup MSG_Next_Right_Lane_B Message Next_Right_Lane_B (0x508)
 *
 * Sent by \ref ECU_Matrix.
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_Next_Right_Lane_B_laneModelC1
 * - \ref SIG_Next_Right_Lane_B_viewRangeStart
 * - \ref SIG_Next_Right_Lane_B_viewRangeEnd
 * - \ref SIG_Next_Right_Lane_B_laneMarkColor
 * - \ref SIG_Next_Right_Lane_B_reserved_bits1
 * - \ref SIG_Next_Right_Lane_B_Reserved1_NextlaneB
 *
 * @ingroup ECU_Matrix
 * @{
 */

/**
 * Message Next_Right_Lane_B configuration tuple.
 */
#define MSG_Next_Right_Lane_B 0x508, 0, 8

/**
 * Message Next_Right_Lane_B id.
 */
#define ID_Next_Right_Lane_B 0x508

/**
 * Message Next_Right_Lane_B extended id bit.
 */
#define EXT_Next_Right_Lane_B 0

/**
 * Message Next_Right_Lane_B Data Length Count.
 */
#define DLC_Next_Right_Lane_B 8

/**
 * Message Next_Right_Lane_B cycle time.
 */
#define CYCLE_Next_Right_Lane_B 0

/**
 * Message Next_Right_Lane_B fast cycle time.
 */
#define FAST_Next_Right_Lane_B 0

/**
 * Initialise message Next_Right_Lane_B buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_Next_Right_Lane_B(buf)                                                                                    \
    {                                                                                                                  \
        INITSIG_Next_Right_Lane_B_laneModelC1(buf);                                                                    \
        INITSIG_Next_Right_Lane_B_viewRangeStart(buf);                                                                 \
        INITSIG_Next_Right_Lane_B_viewRangeEnd(buf);                                                                   \
        INITSIG_Next_Right_Lane_B_laneMarkColor(buf);                                                                  \
        INITSIG_Next_Right_Lane_B_reserved_bits1(buf);                                                                 \
        INITSIG_Next_Right_Lane_B_Reserved1_NextlaneB(buf);                                                            \
    }

/**
 * @}
 */

/**
 * @defgroup MSG_Next_Left_Lane_B Message Next_Left_Lane_B (0x507)
 *
 * Sent by \ref ECU_Matrix.
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_Next_Left_Lane_B_laneModelC1
 * - \ref SIG_Next_Left_Lane_B_viewRangeStart
 * - \ref SIG_Next_Left_Lane_B_viewRangeEnd
 * - \ref SIG_Next_Left_Lane_B_laneMarkColor
 * - \ref SIG_Next_Left_Lane_B_reserved_bits1
 * - \ref SIG_Next_Left_Lane_B_Reserved1_NextlaneB
 *
 * @ingroup ECU_Matrix
 * @{
 */

/**
 * Message Next_Left_Lane_B configuration tuple.
 */
#define MSG_Next_Left_Lane_B 0x507, 0, 8

/**
 * Message Next_Left_Lane_B id.
 */
#define ID_Next_Left_Lane_B 0x507

/**
 * Message Next_Left_Lane_B extended id bit.
 */
#define EXT_Next_Left_Lane_B 0

/**
 * Message Next_Left_Lane_B Data Length Count.
 */
#define DLC_Next_Left_Lane_B 8

/**
 * Message Next_Left_Lane_B cycle time.
 */
#define CYCLE_Next_Left_Lane_B 0

/**
 * Message Next_Left_Lane_B fast cycle time.
 */
#define FAST_Next_Left_Lane_B 0

/**
 * Initialise message Next_Left_Lane_B buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_Next_Left_Lane_B(buf)                                                                                     \
    {                                                                                                                  \
        INITSIG_Next_Left_Lane_B_laneModelC1(buf);                                                                     \
        INITSIG_Next_Left_Lane_B_viewRangeStart(buf);                                                                  \
        INITSIG_Next_Left_Lane_B_viewRangeEnd(buf);                                                                    \
        INITSIG_Next_Left_Lane_B_laneMarkColor(buf);                                                                   \
        INITSIG_Next_Left_Lane_B_reserved_bits1(buf);                                                                  \
        INITSIG_Next_Left_Lane_B_Reserved1_NextlaneB(buf);                                                             \
    }

/**
 * @}
 */

/**
 * @defgroup MSG_Next_Right_Lane_A Message Next_Right_Lane_A (0x506)
 *
 * Sent by \ref ECU_Matrix.
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_Next_Right_Lane_A_laneType
 * - \ref SIG_Next_Right_Lane_A_laneQuality
 * - \ref SIG_Next_Right_Lane_A_laneModelC0
 * - \ref SIG_Next_Right_Lane_A_laneModelC2
 * - \ref SIG_Next_Right_Lane_A_laneModelC3
 * - \ref SIG_Next_Right_Lane_A_laneWidthMarking
 * - \ref SIG_Next_Right_Lane_A_laneConfidence
 * - \ref SIG_Next_Right_Lane_A_Reserved1_NextlaneA
 *
 * @ingroup ECU_Matrix
 * @{
 */

/**
 * Message Next_Right_Lane_A configuration tuple.
 */
#define MSG_Next_Right_Lane_A 0x506, 0, 8

/**
 * Message Next_Right_Lane_A id.
 */
#define ID_Next_Right_Lane_A 0x506

/**
 * Message Next_Right_Lane_A extended id bit.
 */
#define EXT_Next_Right_Lane_A 0

/**
 * Message Next_Right_Lane_A Data Length Count.
 */
#define DLC_Next_Right_Lane_A 8

/**
 * Message Next_Right_Lane_A cycle time.
 */
#define CYCLE_Next_Right_Lane_A 0

/**
 * Message Next_Right_Lane_A fast cycle time.
 */
#define FAST_Next_Right_Lane_A 0

/**
 * Initialise message Next_Right_Lane_A buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_Next_Right_Lane_A(buf)                                                                                    \
    {                                                                                                                  \
        INITSIG_Next_Right_Lane_A_laneType(buf);                                                                       \
        INITSIG_Next_Right_Lane_A_laneQuality(buf);                                                                    \
        INITSIG_Next_Right_Lane_A_laneModelC0(buf);                                                                    \
        INITSIG_Next_Right_Lane_A_laneModelC2(buf);                                                                    \
        INITSIG_Next_Right_Lane_A_laneModelC3(buf);                                                                    \
        INITSIG_Next_Right_Lane_A_laneWidthMarking(buf);                                                               \
        INITSIG_Next_Right_Lane_A_laneConfidence(buf);                                                                 \
        INITSIG_Next_Right_Lane_A_Reserved1_NextlaneA(buf);                                                            \
    }

/**
 * @}
 */

/**
 * @defgroup MSG_Next_Left_Lane_A Message Next_Left_Lane_A (0x505)
 *
 * Sent by \ref ECU_Matrix.
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_Next_Left_Lane_A_laneType
 * - \ref SIG_Next_Left_Lane_A_laneQuality
 * - \ref SIG_Next_Left_Lane_A_laneModelC0
 * - \ref SIG_Next_Left_Lane_A_laneModelC2
 * - \ref SIG_Next_Left_Lane_A_laneModelC3
 * - \ref SIG_Next_Left_Lane_A_laneWidthMarking
 * - \ref SIG_Next_Left_Lane_A_laneConfidence
 * - \ref SIG_Next_Left_Lane_A_Reserved1_NextlaneA
 *
 * @ingroup ECU_Matrix
 * @{
 */

/**
 * Message Next_Left_Lane_A configuration tuple.
 */
#define MSG_Next_Left_Lane_A 0x505, 0, 8

/**
 * Message Next_Left_Lane_A id.
 */
#define ID_Next_Left_Lane_A 0x505

/**
 * Message Next_Left_Lane_A extended id bit.
 */
#define EXT_Next_Left_Lane_A 0

/**
 * Message Next_Left_Lane_A Data Length Count.
 */
#define DLC_Next_Left_Lane_A 8

/**
 * Message Next_Left_Lane_A cycle time.
 */
#define CYCLE_Next_Left_Lane_A 0

/**
 * Message Next_Left_Lane_A fast cycle time.
 */
#define FAST_Next_Left_Lane_A 0

/**
 * Initialise message Next_Left_Lane_A buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_Next_Left_Lane_A(buf)                                                                                     \
    {                                                                                                                  \
        INITSIG_Next_Left_Lane_A_laneType(buf);                                                                        \
        INITSIG_Next_Left_Lane_A_laneQuality(buf);                                                                     \
        INITSIG_Next_Left_Lane_A_laneModelC0(buf);                                                                     \
        INITSIG_Next_Left_Lane_A_laneModelC2(buf);                                                                     \
        INITSIG_Next_Left_Lane_A_laneModelC3(buf);                                                                     \
        INITSIG_Next_Left_Lane_A_laneWidthMarking(buf);                                                                \
        INITSIG_Next_Left_Lane_A_laneConfidence(buf);                                                                  \
        INITSIG_Next_Left_Lane_A_Reserved1_NextlaneA(buf);                                                             \
    }

/**
 * @}
 */

/**
 * @defgroup MSG_LKA_Right_Lane_B Message LKA_Right_Lane_B (0x504)
 *
 * Sent by \ref ECU_Matrix.
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_LKA_Right_Lane_B_laneModelC1
 * - \ref SIG_LKA_Right_Lane_B_viewRangeStart
 * - \ref SIG_LKA_Right_Lane_B_viewRangeEnd
 * - \ref SIG_LKA_Right_Lane_B_laneCrossing
 * - \ref SIG_LKA_Right_Lane_B_laneMarkColor
 * - \ref SIG_LKA_Right_Lane_B_Reserved1_LKAlaneB
 * - \ref SIG_LKA_Right_Lane_B_Reserved2_LKAlaneB
 * - \ref SIG_LKA_Right_Lane_B_Reserved3_LKAlaneB
 * - \ref SIG_LKA_Right_Lane_B_ttlc
 *
 * @ingroup ECU_Matrix
 * @{
 */

/**
 * Message LKA_Right_Lane_B configuration tuple.
 */
#define MSG_LKA_Right_Lane_B 0x504, 0, 8

/**
 * Message LKA_Right_Lane_B id.
 */
#define ID_LKA_Right_Lane_B 0x504

/**
 * Message LKA_Right_Lane_B extended id bit.
 */
#define EXT_LKA_Right_Lane_B 0

/**
 * Message LKA_Right_Lane_B Data Length Count.
 */
#define DLC_LKA_Right_Lane_B 8

/**
 * Message LKA_Right_Lane_B cycle time.
 */
#define CYCLE_LKA_Right_Lane_B 0

/**
 * Message LKA_Right_Lane_B fast cycle time.
 */
#define FAST_LKA_Right_Lane_B 0

/**
 * Initialise message LKA_Right_Lane_B buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_LKA_Right_Lane_B(buf)                                                                                     \
    {                                                                                                                  \
        INITSIG_LKA_Right_Lane_B_laneModelC1(buf);                                                                     \
        INITSIG_LKA_Right_Lane_B_viewRangeStart(buf);                                                                  \
        INITSIG_LKA_Right_Lane_B_viewRangeEnd(buf);                                                                    \
        INITSIG_LKA_Right_Lane_B_laneCrossing(buf);                                                                    \
        INITSIG_LKA_Right_Lane_B_laneMarkColor(buf);                                                                   \
        INITSIG_LKA_Right_Lane_B_Reserved1_LKAlaneB(buf);                                                              \
        INITSIG_LKA_Right_Lane_B_Reserved2_LKAlaneB(buf);                                                              \
        INITSIG_LKA_Right_Lane_B_Reserved3_LKAlaneB(buf);                                                              \
        INITSIG_LKA_Right_Lane_B_ttlc(buf);                                                                            \
    }

/**
 * @}
 */

/**
 * @defgroup MSG_LKA_Right_Lane_A Message LKA_Right_Lane_A (0x503)
 *
 * Sent by \ref ECU_Matrix.
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_LKA_Right_Lane_A_laneType
 * - \ref SIG_LKA_Right_Lane_A_laneQuality
 * - \ref SIG_LKA_Right_Lane_A_laneModelC0
 * - \ref SIG_LKA_Right_Lane_A_laneModelC2
 * - \ref SIG_LKA_Right_Lane_A_laneModelC3
 * - \ref SIG_LKA_Right_Lane_A_laneWidthMarking
 * - \ref SIG_LKA_Right_Lane_A_laneConfidence
 * - \ref SIG_LKA_Right_Lane_A_Reserved1_LKAlaneA
 *
 * @ingroup ECU_Matrix
 * @{
 */

/**
 * Message LKA_Right_Lane_A configuration tuple.
 */
#define MSG_LKA_Right_Lane_A 0x503, 0, 8

/**
 * Message LKA_Right_Lane_A id.
 */
#define ID_LKA_Right_Lane_A 0x503

/**
 * Message LKA_Right_Lane_A extended id bit.
 */
#define EXT_LKA_Right_Lane_A 0

/**
 * Message LKA_Right_Lane_A Data Length Count.
 */
#define DLC_LKA_Right_Lane_A 8

/**
 * Message LKA_Right_Lane_A cycle time.
 */
#define CYCLE_LKA_Right_Lane_A 0

/**
 * Message LKA_Right_Lane_A fast cycle time.
 */
#define FAST_LKA_Right_Lane_A 0

/**
 * Initialise message LKA_Right_Lane_A buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_LKA_Right_Lane_A(buf)                                                                                     \
    {                                                                                                                  \
        INITSIG_LKA_Right_Lane_A_laneType(buf);                                                                        \
        INITSIG_LKA_Right_Lane_A_laneQuality(buf);                                                                     \
        INITSIG_LKA_Right_Lane_A_laneModelC0(buf);                                                                     \
        INITSIG_LKA_Right_Lane_A_laneModelC2(buf);                                                                     \
        INITSIG_LKA_Right_Lane_A_laneModelC3(buf);                                                                     \
        INITSIG_LKA_Right_Lane_A_laneWidthMarking(buf);                                                                \
        INITSIG_LKA_Right_Lane_A_laneConfidence(buf);                                                                  \
        INITSIG_LKA_Right_Lane_A_Reserved1_LKAlaneA(buf);                                                              \
    }

/**
 * @}
 */

/**
 * @defgroup MSG_LKA_Left_Lane_B Message LKA_Left_Lane_B (0x502)
 *
 * Sent by \ref ECU_Matrix.
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_LKA_Left_Lane_B_laneModelC1
 * - \ref SIG_LKA_Left_Lane_B_viewRangeStart
 * - \ref SIG_LKA_Left_Lane_B_viewRangeEnd
 * - \ref SIG_LKA_Left_Lane_B_laneCrossing
 * - \ref SIG_LKA_Left_Lane_B_laneMarkColor
 * - \ref SIG_LKA_Left_Lane_B_Reserved1_LKAlaneB
 * - \ref SIG_LKA_Left_Lane_B_Reserved2_LKAlaneB
 * - \ref SIG_LKA_Left_Lane_B_Reserved3_LKAlaneB
 * - \ref SIG_LKA_Left_Lane_B_ttlc
 *
 * @ingroup ECU_Matrix
 * @{
 */

/**
 * Message LKA_Left_Lane_B configuration tuple.
 */
#define MSG_LKA_Left_Lane_B 0x502, 0, 8

/**
 * Message LKA_Left_Lane_B id.
 */
#define ID_LKA_Left_Lane_B 0x502

/**
 * Message LKA_Left_Lane_B extended id bit.
 */
#define EXT_LKA_Left_Lane_B 0

/**
 * Message LKA_Left_Lane_B Data Length Count.
 */
#define DLC_LKA_Left_Lane_B 8

/**
 * Message LKA_Left_Lane_B cycle time.
 */
#define CYCLE_LKA_Left_Lane_B 0

/**
 * Message LKA_Left_Lane_B fast cycle time.
 */
#define FAST_LKA_Left_Lane_B 0

/**
 * Initialise message LKA_Left_Lane_B buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_LKA_Left_Lane_B(buf)                                                                                      \
    {                                                                                                                  \
        INITSIG_LKA_Left_Lane_B_laneModelC1(buf);                                                                      \
        INITSIG_LKA_Left_Lane_B_viewRangeStart(buf);                                                                   \
        INITSIG_LKA_Left_Lane_B_viewRangeEnd(buf);                                                                     \
        INITSIG_LKA_Left_Lane_B_laneCrossing(buf);                                                                     \
        INITSIG_LKA_Left_Lane_B_laneMarkColor(buf);                                                                    \
        INITSIG_LKA_Left_Lane_B_Reserved1_LKAlaneB(buf);                                                               \
        INITSIG_LKA_Left_Lane_B_Reserved2_LKAlaneB(buf);                                                               \
        INITSIG_LKA_Left_Lane_B_Reserved3_LKAlaneB(buf);                                                               \
        INITSIG_LKA_Left_Lane_B_ttlc(buf);                                                                             \
    }

/**
 * @}
 */

/**
 * @defgroup MSG_LKA_Left_Lane_A Message LKA_Left_Lane_A (0x501)
 *
 * Sent by \ref ECU_Matrix.
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_LKA_Left_Lane_A_laneType
 * - \ref SIG_LKA_Left_Lane_A_laneQuality
 * - \ref SIG_LKA_Left_Lane_A_laneModelC0
 * - \ref SIG_LKA_Left_Lane_A_laneModelC2
 * - \ref SIG_LKA_Left_Lane_A_laneModelC3
 * - \ref SIG_LKA_Left_Lane_A_laneWidthMarking
 * - \ref SIG_LKA_Left_Lane_A_laneConfidence
 * - \ref SIG_LKA_Left_Lane_A_Reserved1_LKAlaneA
 *
 * @ingroup ECU_Matrix
 * @{
 */

/**
 * Message LKA_Left_Lane_A configuration tuple.
 */
#define MSG_LKA_Left_Lane_A 0x501, 0, 8

/**
 * Message LKA_Left_Lane_A id.
 */
#define ID_LKA_Left_Lane_A 0x501

/**
 * Message LKA_Left_Lane_A extended id bit.
 */
#define EXT_LKA_Left_Lane_A 0

/**
 * Message LKA_Left_Lane_A Data Length Count.
 */
#define DLC_LKA_Left_Lane_A 8

/**
 * Message LKA_Left_Lane_A cycle time.
 */
#define CYCLE_LKA_Left_Lane_A 0

/**
 * Message LKA_Left_Lane_A fast cycle time.
 */
#define FAST_LKA_Left_Lane_A 0

/**
 * Initialise message LKA_Left_Lane_A buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_LKA_Left_Lane_A(buf)                                                                                      \
    {                                                                                                                  \
        INITSIG_LKA_Left_Lane_A_laneType(buf);                                                                         \
        INITSIG_LKA_Left_Lane_A_laneQuality(buf);                                                                      \
        INITSIG_LKA_Left_Lane_A_laneModelC0(buf);                                                                      \
        INITSIG_LKA_Left_Lane_A_laneModelC2(buf);                                                                      \
        INITSIG_LKA_Left_Lane_A_laneModelC3(buf);                                                                      \
        INITSIG_LKA_Left_Lane_A_laneWidthMarking(buf);                                                                 \
        INITSIG_LKA_Left_Lane_A_laneConfidence(buf);                                                                   \
        INITSIG_LKA_Left_Lane_A_Reserved1_LKAlaneA(buf);                                                               \
    }

/**
 * @}
 */

/**
 * @defgroup SIG_Road_Information_constructionArea Signal constructionArea of Message Road_Information (0x500)
 *
 * Contains the value table \ref ENUM_Road_Information_constructionArea.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal constructionArea configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_constructionArea and \ref GET_Road_Information_constructionArea instead.
 */
#define SIG_Road_Information_constructionArea 0, 0, 0, 2

/**
 * Signal constructionArea setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_constructionArea or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_constructionArea 0, 0, 0, 2, 0

/**
 * Get signal constructionArea from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_constructionArea(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 0) & 0x03) << 0))

/**
 * Set signal constructionArea in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_constructionArea(buf, val)                                                                \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 0);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 0;                                                                 \
    }

/**
 * Set signal constructionArea in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_constructionArea(buf) SET_Road_Information_constructionArea(buf, 0)

/**
 * Signal constructionArea value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_constructionArea(x, fmt) ((x)*fmt)

/**
 * Signal constructionArea raw initial value.
 */
#define START_Road_Information_constructionArea 0

/**
 * Signal constructionArea raw minimum value.
 */
#define MIN_Road_Information_constructionArea 0

/**
 * Signal constructionArea raw maximum value.
 */
#define MAX_Road_Information_constructionArea 3

/**
 * Signal constructionArea raw offset value.
 */
#define OFF_Road_Information_constructionArea 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Road_Information_constructionArea Value Table for Signal constructionArea in Message Road_Information
 * (0x500)
 *
 * Enum values defined for \ref SIG_Road_Information_constructionArea.
 *
 * @ingroup SIG_Road_Information_constructionArea
 */

/**
 * Value table Road_Information_constructionArea entry Detected.
 *
 * Both
 *
 * @ingroup ENUM_Road_Information_constructionArea
 */
#define Road_Information_constructionArea_Detected 3

/**
 * Value table Road_Information_constructionArea entry Detected_2.
 *
 * Left
 *
 * @ingroup ENUM_Road_Information_constructionArea
 */
#define Road_Information_constructionArea_Detected_2 2

/**
 * Value table Road_Information_constructionArea entry Detected_1.
 *
 * Right
 *
 * @ingroup ENUM_Road_Information_constructionArea
 */
#define Road_Information_constructionArea_Detected_1 1

/**
 * Value table Road_Information_constructionArea entry CA.
 *
 * not detected
 *
 * @ingroup ENUM_Road_Information_constructionArea
 */
#define Road_Information_constructionArea_CA 0

/**
 * @defgroup SIG_Road_Information_roadType Signal roadType of Message Road_Information (0x500)
 *
 * Contains the value table \ref ENUM_Road_Information_roadType.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal roadType configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_roadType and \ref GET_Road_Information_roadType instead.
 */
#define SIG_Road_Information_roadType 0, 0, 2, 2

/**
 * Signal roadType setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_roadType or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_roadType 0, 0, 2, 2, 0

/**
 * Get signal roadType from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_roadType(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 2) & 0x03) << 0))

/**
 * Set signal roadType in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_roadType(buf, val)                                                                        \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 2);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 2;                                                                 \
    }

/**
 * Set signal roadType in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_roadType(buf) SET_Road_Information_roadType(buf, 0)

/**
 * Signal roadType value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_roadType(x, fmt) ((x)*fmt)

/**
 * Signal roadType raw initial value.
 */
#define START_Road_Information_roadType 0

/**
 * Signal roadType raw minimum value.
 */
#define MIN_Road_Information_roadType 0

/**
 * Signal roadType raw maximum value.
 */
#define MAX_Road_Information_roadType 2

/**
 * Signal roadType raw offset value.
 */
#define OFF_Road_Information_roadType 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Road_Information_roadType Value Table for Signal roadType in Message Road_Information (0x500)
 *
 * Enum values defined for \ref SIG_Road_Information_roadType.
 *
 * @ingroup SIG_Road_Information_roadType
 */

/**
 * Value table Road_Information_roadType entry Urban.
 *
 * @ingroup ENUM_Road_Information_roadType
 */
#define Road_Information_roadType_Urban 2

/**
 * Value table Road_Information_roadType entry Highway.
 *
 * @ingroup ENUM_Road_Information_roadType
 */
#define Road_Information_roadType_Highway 1

/**
 * Value table Road_Information_roadType entry Unknown.
 *
 * @ingroup ENUM_Road_Information_roadType
 */
#define Road_Information_roadType_Unknown 0

/**
 * @defgroup SIG_Road_Information_highwayExitRight Signal highwayExitRight of Message Road_Information (0x500)
 *
 * When we detect highway exit to our right this flag is turned on.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal highwayExitRight configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_highwayExitRight and \ref GET_Road_Information_highwayExitRight instead.
 */
#define SIG_Road_Information_highwayExitRight 0, 0, 4, 1

/**
 * Signal highwayExitRight setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_highwayExitRight or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_highwayExitRight 0, 0, 4, 1, 0

/**
 * Get signal highwayExitRight from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_highwayExitRight(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 4) & 0x01) << 0))

/**
 * Set signal highwayExitRight in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_highwayExitRight(buf, val)                                                                \
    {                                                                                                                  \
        buf[0] &= ~(0x01 << 4);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x01) << 4;                                                                 \
    }

/**
 * Set signal highwayExitRight in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_highwayExitRight(buf) SET_Road_Information_highwayExitRight(buf, 0)

/**
 * Signal highwayExitRight value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_highwayExitRight(x, fmt) ((x)*fmt)

/**
 * Signal highwayExitRight raw initial value.
 */
#define START_Road_Information_highwayExitRight 0

/**
 * Signal highwayExitRight raw minimum value.
 */
#define MIN_Road_Information_highwayExitRight 0

/**
 * Signal highwayExitRight raw maximum value.
 */
#define MAX_Road_Information_highwayExitRight 1

/**
 * Signal highwayExitRight raw offset value.
 */
#define OFF_Road_Information_highwayExitRight 0

/**
 * @}
 */

/**
 * @defgroup SIG_Road_Information_highwayExitLeft Signal highwayExitLeft of Message Road_Information (0x500)
 *
 * When we detect highway exit to our left this flag is turned on.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal highwayExitLeft configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_highwayExitLeft and \ref GET_Road_Information_highwayExitLeft instead.
 */
#define SIG_Road_Information_highwayExitLeft 0, 0, 5, 1

/**
 * Signal highwayExitLeft setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_highwayExitLeft or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_highwayExitLeft 0, 0, 5, 1, 0

/**
 * Get signal highwayExitLeft from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_highwayExitLeft(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 5) & 0x01) << 0))

/**
 * Set signal highwayExitLeft in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_highwayExitLeft(buf, val)                                                                 \
    {                                                                                                                  \
        buf[0] &= ~(0x01 << 5);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x01) << 5;                                                                 \
    }

/**
 * Set signal highwayExitLeft in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_highwayExitLeft(buf) SET_Road_Information_highwayExitLeft(buf, 0)

/**
 * Signal highwayExitLeft value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_highwayExitLeft(x, fmt) ((x)*fmt)

/**
 * Signal highwayExitLeft raw initial value.
 */
#define START_Road_Information_highwayExitLeft 0

/**
 * Signal highwayExitLeft raw minimum value.
 */
#define MIN_Road_Information_highwayExitLeft 0

/**
 * Signal highwayExitLeft raw maximum value.
 */
#define MAX_Road_Information_highwayExitLeft 1

/**
 * Signal highwayExitLeft raw offset value.
 */
#define OFF_Road_Information_highwayExitLeft 0

/**
 * @}
 */

/**
 * @defgroup SIG_Road_Information_Lane_Assignment_Host_Index_0m Signal Lane_Assignment_Host_Index_0m of Message
 * Road_Information (0x500)
 *
 * Position of ego vehicle in lanes. 0=unknown position 1= most left lane. All lanes (including oncoming) are taken into
 * account.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal Lane_Assignment_Host_Index_0m configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_Lane_Assignment_Host_Index_0m and \ref
 *GET_Road_Information_Lane_Assignment_Host_Index_0m instead.
 */
#define SIG_Road_Information_Lane_Assignment_Host_Index_0m 0, 0, 6, 4

/**
 * Signal Lane_Assignment_Host_Index_0m setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_Lane_Assignment_Host_Index_0m or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_Lane_Assignment_Host_Index_0m 0, 0, 6, 4, 0

/**
 * Get signal Lane_Assignment_Host_Index_0m from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_Lane_Assignment_Host_Index_0m(buf)                                                        \
    (0 | (uint8_t)(+(uint8_t)((buf[0] >> 6) & 0x03) << 0) | (uint8_t)(+(uint8_t)((buf[1] >> 0) & 0x03) << 2))

/**
 * Set signal Lane_Assignment_Host_Index_0m in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_Lane_Assignment_Host_Index_0m(buf, val)                                                   \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 6);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 6;                                                                 \
        buf[1] &= ~(0x03 << 0);                                                                                        \
        buf[1] |= (((uint8_t)(val) >> 2) & 0x03) << 0;                                                                 \
    }

/**
 * Set signal Lane_Assignment_Host_Index_0m in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_Lane_Assignment_Host_Index_0m(buf)                                                    \
    SET_Road_Information_Lane_Assignment_Host_Index_0m(buf, 0)

/**
 * Signal Lane_Assignment_Host_Index_0m value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_Lane_Assignment_Host_Index_0m(x, fmt) ((x)*fmt)

/**
 * Signal Lane_Assignment_Host_Index_0m raw initial value.
 */
#define START_Road_Information_Lane_Assignment_Host_Index_0m 0

/**
 * Signal Lane_Assignment_Host_Index_0m raw minimum value.
 */
#define MIN_Road_Information_Lane_Assignment_Host_Index_0m 0

/**
 * Signal Lane_Assignment_Host_Index_0m raw maximum value.
 */
#define MAX_Road_Information_Lane_Assignment_Host_Index_0m 9

/**
 * Signal Lane_Assignment_Host_Index_0m raw offset value.
 */
#define OFF_Road_Information_Lane_Assignment_Host_Index_0m 0

/**
 * @}
 */

/**
 * @defgroup SIG_Road_Information_Lane_Assignment_Host_Index_35m Signal Lane_Assignment_Host_Index_35m of Message
 * Road_Information (0x500)
 *
 * Position of ego vehicle in lanes. 0=unknown position 1= most left lane. All lanes (including oncoming) are taken into
 * account.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal Lane_Assignment_Host_Index_35m configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_Lane_Assignment_Host_Index_35m and \ref
 *GET_Road_Information_Lane_Assignment_Host_Index_35m instead.
 */
#define SIG_Road_Information_Lane_Assignment_Host_Index_35m 0, 0, 10, 4

/**
 * Signal Lane_Assignment_Host_Index_35m setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_Lane_Assignment_Host_Index_35m or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_Lane_Assignment_Host_Index_35m 0, 0, 10, 4, 0

/**
 * Get signal Lane_Assignment_Host_Index_35m from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_Lane_Assignment_Host_Index_35m(buf) (0 | (uint8_t)(+(uint8_t)((buf[1] >> 2) & 0x0f) << 0))

/**
 * Set signal Lane_Assignment_Host_Index_35m in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_Lane_Assignment_Host_Index_35m(buf, val)                                                  \
    {                                                                                                                  \
        buf[1] &= ~(0x0f << 2);                                                                                        \
        buf[1] |= (((uint8_t)(val) >> 0) & 0x0f) << 2;                                                                 \
    }

/**
 * Set signal Lane_Assignment_Host_Index_35m in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_Lane_Assignment_Host_Index_35m(buf)                                                   \
    SET_Road_Information_Lane_Assignment_Host_Index_35m(buf, 0)

/**
 * Signal Lane_Assignment_Host_Index_35m value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_Lane_Assignment_Host_Index_35m(x, fmt) ((x)*fmt)

/**
 * Signal Lane_Assignment_Host_Index_35m raw initial value.
 */
#define START_Road_Information_Lane_Assignment_Host_Index_35m 0

/**
 * Signal Lane_Assignment_Host_Index_35m raw minimum value.
 */
#define MIN_Road_Information_Lane_Assignment_Host_Index_35m 0

/**
 * Signal Lane_Assignment_Host_Index_35m raw maximum value.
 */
#define MAX_Road_Information_Lane_Assignment_Host_Index_35m 9

/**
 * Signal Lane_Assignment_Host_Index_35m raw offset value.
 */
#define OFF_Road_Information_Lane_Assignment_Host_Index_35m 0

/**
 * @}
 */

/**
 * @defgroup SIG_Road_Information_NumOfLanes_0m Signal NumOfLanes_0m of Message Road_Information (0x500)
 *
 * 0-9 lanes
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal NumOfLanes_0m configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_NumOfLanes_0m and \ref GET_Road_Information_NumOfLanes_0m instead.
 */
#define SIG_Road_Information_NumOfLanes_0m 0, 0, 14, 4

/**
 * Signal NumOfLanes_0m setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_NumOfLanes_0m or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_NumOfLanes_0m 0, 0, 14, 4, 0

/**
 * Get signal NumOfLanes_0m from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_NumOfLanes_0m(buf)                                                                        \
    (0 | (uint8_t)(+(uint8_t)((buf[1] >> 6) & 0x03) << 0) | (uint8_t)(+(uint8_t)((buf[2] >> 0) & 0x03) << 2))

/**
 * Set signal NumOfLanes_0m in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_NumOfLanes_0m(buf, val)                                                                   \
    {                                                                                                                  \
        buf[1] &= ~(0x03 << 6);                                                                                        \
        buf[1] |= (((uint8_t)(val) >> 0) & 0x03) << 6;                                                                 \
        buf[2] &= ~(0x03 << 0);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 2) & 0x03) << 0;                                                                 \
    }

/**
 * Set signal NumOfLanes_0m in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_NumOfLanes_0m(buf) SET_Road_Information_NumOfLanes_0m(buf, 0)

/**
 * Signal NumOfLanes_0m value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_NumOfLanes_0m(x, fmt) ((x)*fmt)

/**
 * Signal NumOfLanes_0m raw initial value.
 */
#define START_Road_Information_NumOfLanes_0m 0

/**
 * Signal NumOfLanes_0m raw minimum value.
 */
#define MIN_Road_Information_NumOfLanes_0m 1

/**
 * Signal NumOfLanes_0m raw maximum value.
 */
#define MAX_Road_Information_NumOfLanes_0m 9

/**
 * Signal NumOfLanes_0m raw offset value.
 */
#define OFF_Road_Information_NumOfLanes_0m 0

/**
 * @}
 */

/**
 * @defgroup SIG_Road_Information_NumOfLanes_35m Signal NumOfLanes_35m of Message Road_Information (0x500)
 *
 * 0-9 lanes
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal NumOfLanes_35m configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_NumOfLanes_35m and \ref GET_Road_Information_NumOfLanes_35m instead.
 */
#define SIG_Road_Information_NumOfLanes_35m 0, 0, 18, 4

/**
 * Signal NumOfLanes_35m setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_NumOfLanes_35m or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_NumOfLanes_35m 0, 0, 18, 4, 0

/**
 * Get signal NumOfLanes_35m from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_NumOfLanes_35m(buf) (0 | (uint8_t)(+(uint8_t)((buf[2] >> 2) & 0x0f) << 0))

/**
 * Set signal NumOfLanes_35m in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_NumOfLanes_35m(buf, val)                                                                  \
    {                                                                                                                  \
        buf[2] &= ~(0x0f << 2);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x0f) << 2;                                                                 \
    }

/**
 * Set signal NumOfLanes_35m in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_NumOfLanes_35m(buf) SET_Road_Information_NumOfLanes_35m(buf, 0)

/**
 * Signal NumOfLanes_35m value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_NumOfLanes_35m(x, fmt) ((x)*fmt)

/**
 * Signal NumOfLanes_35m raw initial value.
 */
#define START_Road_Information_NumOfLanes_35m 0

/**
 * Signal NumOfLanes_35m raw minimum value.
 */
#define MIN_Road_Information_NumOfLanes_35m 1

/**
 * Signal NumOfLanes_35m raw maximum value.
 */
#define MAX_Road_Information_NumOfLanes_35m 9

/**
 * Signal NumOfLanes_35m raw offset value.
 */
#define OFF_Road_Information_NumOfLanes_35m 0

/**
 * @}
 */

/**
 * @defgroup SIG_Road_Information_roadCoverbySnow Signal roadCoverbySnow of Message Road_Information (0x500)
 *
 * True when the road is covered with snow
 *
 * Contains the value table \ref ENUM_Road_Information_roadCoverbySnow.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal roadCoverbySnow configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_roadCoverbySnow and \ref GET_Road_Information_roadCoverbySnow instead.
 */
#define SIG_Road_Information_roadCoverbySnow 0, 0, 22, 1

/**
 * Signal roadCoverbySnow setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_roadCoverbySnow or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_roadCoverbySnow 0, 0, 22, 1, 0

/**
 * Get signal roadCoverbySnow from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_roadCoverbySnow(buf) (0 | (uint8_t)(+(uint8_t)((buf[2] >> 6) & 0x01) << 0))

/**
 * Set signal roadCoverbySnow in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_roadCoverbySnow(buf, val)                                                                 \
    {                                                                                                                  \
        buf[2] &= ~(0x01 << 6);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x01) << 6;                                                                 \
    }

/**
 * Set signal roadCoverbySnow in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_roadCoverbySnow(buf) SET_Road_Information_roadCoverbySnow(buf, 0)

/**
 * Signal roadCoverbySnow value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_roadCoverbySnow(x, fmt) ((x)*fmt)

/**
 * Signal roadCoverbySnow raw initial value.
 */
#define START_Road_Information_roadCoverbySnow 0

/**
 * Signal roadCoverbySnow raw minimum value.
 */
#define MIN_Road_Information_roadCoverbySnow 0

/**
 * Signal roadCoverbySnow raw maximum value.
 */
#define MAX_Road_Information_roadCoverbySnow 1

/**
 * Signal roadCoverbySnow raw offset value.
 */
#define OFF_Road_Information_roadCoverbySnow 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Road_Information_roadCoverbySnow Value Table for Signal roadCoverbySnow in Message Road_Information
 * (0x500)
 *
 * Enum values defined for \ref SIG_Road_Information_roadCoverbySnow.
 *
 * @ingroup SIG_Road_Information_roadCoverbySnow
 */

/**
 * Value table Road_Information_roadCoverbySnow entry Snow.
 *
 * @ingroup ENUM_Road_Information_roadCoverbySnow
 */
#define Road_Information_roadCoverbySnow_Snow 1

/**
 * Value table Road_Information_roadCoverbySnow entry No.
 *
 * @ingroup ENUM_Road_Information_roadCoverbySnow
 */
#define Road_Information_roadCoverbySnow_No 0

/**
 * @defgroup SIG_Road_Information_wetRoad Signal wetRoad of Message Road_Information (0x500)
 *
 * True when the road is wed
 *
 * Contains the value table \ref ENUM_Road_Information_wetRoad.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal wetRoad configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_wetRoad and \ref GET_Road_Information_wetRoad instead.
 */
#define SIG_Road_Information_wetRoad 0, 0, 23, 1

/**
 * Signal wetRoad setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_wetRoad or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_wetRoad 0, 0, 23, 1, 0

/**
 * Get signal wetRoad from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_wetRoad(buf) (0 | (uint8_t)(+(uint8_t)((buf[2] >> 7) & 0x01) << 0))

/**
 * Set signal wetRoad in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_wetRoad(buf, val)                                                                         \
    {                                                                                                                  \
        buf[2] &= ~(0x01 << 7);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x01) << 7;                                                                 \
    }

/**
 * Set signal wetRoad in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_wetRoad(buf) SET_Road_Information_wetRoad(buf, 0)

/**
 * Signal wetRoad value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_wetRoad(x, fmt) ((x)*fmt)

/**
 * Signal wetRoad raw initial value.
 */
#define START_Road_Information_wetRoad 0

/**
 * Signal wetRoad raw minimum value.
 */
#define MIN_Road_Information_wetRoad 0

/**
 * Signal wetRoad raw maximum value.
 */
#define MAX_Road_Information_wetRoad 1

/**
 * Signal wetRoad raw offset value.
 */
#define OFF_Road_Information_wetRoad 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Road_Information_wetRoad Value Table for Signal wetRoad in Message Road_Information (0x500)
 *
 * Enum values defined for \ref SIG_Road_Information_wetRoad.
 *
 * @ingroup SIG_Road_Information_wetRoad
 */

/**
 * Value table Road_Information_wetRoad entry Wet.
 *
 * @ingroup ENUM_Road_Information_wetRoad
 */
#define Road_Information_wetRoad_Wet 1

/**
 * Value table Road_Information_wetRoad entry Not.
 *
 * Wet
 *
 * @ingroup ENUM_Road_Information_wetRoad
 */
#define Road_Information_wetRoad_Not 0

/**
 * @defgroup SIG_Road_Information_currentWeather Signal currentWeather of Message Road_Information (0x500)
 *
 * weather
 *
 * Contains the value table \ref ENUM_Road_Information_currentWeather.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal currentWeather configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_currentWeather and \ref GET_Road_Information_currentWeather instead.
 */
#define SIG_Road_Information_currentWeather 0, 0, 24, 3

/**
 * Signal currentWeather setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_currentWeather or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_currentWeather 0, 0, 24, 3, 0

/**
 * Get signal currentWeather from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_currentWeather(buf) (0 | (uint8_t)(+(uint8_t)((buf[3] >> 0) & 0x07) << 0))

/**
 * Set signal currentWeather in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_currentWeather(buf, val)                                                                  \
    {                                                                                                                  \
        buf[3] &= ~(0x07 << 0);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x07) << 0;                                                                 \
    }

/**
 * Set signal currentWeather in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_currentWeather(buf) SET_Road_Information_currentWeather(buf, 0)

/**
 * Signal currentWeather value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_currentWeather(x, fmt) ((x)*fmt)

/**
 * Signal currentWeather raw initial value.
 */
#define START_Road_Information_currentWeather 0

/**
 * Signal currentWeather raw minimum value.
 */
#define MIN_Road_Information_currentWeather 0

/**
 * Signal currentWeather raw maximum value.
 */
#define MAX_Road_Information_currentWeather 7

/**
 * Signal currentWeather raw offset value.
 */
#define OFF_Road_Information_currentWeather 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Road_Information_currentWeather Value Table for Signal currentWeather in Message Road_Information
 * (0x500)
 *
 * Enum values defined for \ref SIG_Road_Information_currentWeather.
 *
 * @ingroup SIG_Road_Information_currentWeather
 */

/**
 * Value table Road_Information_currentWeather entry Foggy.
 *
 * @ingroup ENUM_Road_Information_currentWeather
 */
#define Road_Information_currentWeather_Foggy 4

/**
 * Value table Road_Information_currentWeather entry Snow.
 *
 * @ingroup ENUM_Road_Information_currentWeather
 */
#define Road_Information_currentWeather_Snow 3

/**
 * Value table Road_Information_currentWeather entry Rain.
 *
 * @ingroup ENUM_Road_Information_currentWeather
 */
#define Road_Information_currentWeather_Rain 2

/**
 * Value table Road_Information_currentWeather entry Sunny.
 *
 * @ingroup ENUM_Road_Information_currentWeather
 */
#define Road_Information_currentWeather_Sunny 1

/**
 * Value table Road_Information_currentWeather entry Unknown.
 *
 * @ingroup ENUM_Road_Information_currentWeather
 */
#define Road_Information_currentWeather_Unknown 0

/**
 * @defgroup SIG_Road_Information_reserved_road1 Signal reserved_road1 of Message Road_Information (0x500)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal reserved_road1 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_reserved_road1 and \ref GET_Road_Information_reserved_road1 instead.
 */
#define SIG_Road_Information_reserved_road1 0, 0, 27, 29

/**
 * Signal reserved_road1 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_reserved_road1 or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_reserved_road1 0, 0, 27, 29, 0

/**
 * Get signal reserved_road1 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_reserved_road1(buf)                                                                       \
    (0 | (uint8_t)(+(uint8_t)((buf[3] >> 3) & 0x1f) << 0) | (uint16_t)(+(uint16_t)((buf[4] >> 0) & 0xff) << 5) |       \
     (uint32_t)(+(uint32_t)((buf[5] >> 0) & 0xff) << 13) | (uint32_t)(+(uint32_t)((buf[6] >> 0) & 0xff) << 21))

/**
 * Set signal reserved_road1 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_reserved_road1(buf, val)                                                                  \
    {                                                                                                                  \
        buf[3] &= ~(0x1f << 3);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x1f) << 3;                                                                 \
        buf[4] &= ~(0xff << 0);                                                                                        \
        buf[4] |= ((uint8_t)((uint16_t)(val) >> 5) & 0xff) << 0;                                                       \
        buf[5] &= ~(0xff << 0);                                                                                        \
        buf[5] |= ((uint8_t)((uint32_t)(val) >> 13) & 0xff) << 0;                                                      \
        buf[6] &= ~(0xff << 0);                                                                                        \
        buf[6] |= ((uint8_t)((uint32_t)(val) >> 21) & 0xff) << 0;                                                      \
    }

/**
 * Set signal reserved_road1 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_reserved_road1(buf) SET_Road_Information_reserved_road1(buf, 0)

/**
 * Signal reserved_road1 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_reserved_road1(x, fmt) ((x)*fmt)

/**
 * Signal reserved_road1 raw initial value.
 */
#define START_Road_Information_reserved_road1 0

/**
 * Signal reserved_road1 raw minimum value.
 */
#define MIN_Road_Information_reserved_road1 0

/**
 * Signal reserved_road1 raw maximum value.
 */
#define MAX_Road_Information_reserved_road1 0

/**
 * Signal reserved_road1 raw offset value.
 */
#define OFF_Road_Information_reserved_road1 0

/**
 * @}
 */

/**
 * @defgroup SIG_Road_Information_protocol_version Signal protocol_version of Message Road_Information (0x500)
 *
 * Any change done in the protocol (in any message) should be reflected by incrementing the protocol_version value by 1.
 * First Version is numbered 3 (to be in sync with former revision control)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Road_Information
 * @{
 */

/**
 * Signal protocol_version configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Road_Information_protocol_version and \ref GET_Road_Information_protocol_version instead.
 */
#define SIG_Road_Information_protocol_version 0, 0, 56, 8

/**
 * Signal protocol_version setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Road_Information_protocol_version or \ref INIT_Road_Information instead.
 */
#define SETUP_Road_Information_protocol_version 0, 0, 56, 8, 0

/**
 * Get signal protocol_version from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Road_Information_protocol_version(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 0) & 0xff) << 0))

/**
 * Set signal protocol_version in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Road_Information_protocol_version(buf, val)                                                                \
    {                                                                                                                  \
        buf[7] &= ~(0xff << 0);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
    }

/**
 * Set signal protocol_version in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Road_Information_protocol_version(buf) SET_Road_Information_protocol_version(buf, 0)

/**
 * Signal protocol_version value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Road_Information_protocol_version(x, fmt) ((x)*fmt)

/**
 * Signal protocol_version raw initial value.
 */
#define START_Road_Information_protocol_version 0

/**
 * Signal protocol_version raw minimum value.
 */
#define MIN_Road_Information_protocol_version 10

/**
 * Signal protocol_version raw maximum value.
 */
#define MAX_Road_Information_protocol_version 10

/**
 * Signal protocol_version raw offset value.
 */
#define OFF_Road_Information_protocol_version 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_B_laneModelC1 Signal laneModelC1 of Message Next_Right_Lane_B (0x508)
 *
 * C1 coefficient which Heading Angle can be calculated from
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_B
 * @{
 */

/**
 * Signal laneModelC1 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_B_laneModelC1 and \ref GET_Next_Right_Lane_B_laneModelC1 instead.
 */
#define SIG_Next_Right_Lane_B_laneModelC1 0, 1, 0, 10

/**
 * Signal laneModelC1 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_B_laneModelC1 or \ref INIT_Next_Right_Lane_B instead.
 */
#define SETUP_Next_Right_Lane_B_laneModelC1 0, 1, 0, 10, 0

/**
 * Get signal laneModelC1 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_B_laneModelC1(buf)                                                                         \
    (0 | (uint16_t)(-(uint16_t)((buf[1] >> 1) & 0x01) << 10) | (uint8_t)(+(uint8_t)((buf[0] >> 0) & 0xff) << 0) |      \
     (uint16_t)(+(uint16_t)((buf[1] >> 0) & 0x03) << 8))

/**
 * Set signal laneModelC1 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_B_laneModelC1(buf, val)                                                                    \
    {                                                                                                                  \
        buf[0] &= ~(0xff << 0);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
        buf[1] &= ~(0x03 << 0);                                                                                        \
        buf[1] |= ((uint8_t)((uint16_t)(val) >> 8) & 0x03) << 0;                                                       \
    }

/**
 * Set signal laneModelC1 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_B_laneModelC1(buf) SET_Next_Right_Lane_B_laneModelC1(buf, 0)

/**
 * Signal laneModelC1 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_B_laneModelC1(x, fmt) ((x)*fmt / 1024)

/**
 * Signal laneModelC1 raw initial value.
 */
#define START_Next_Right_Lane_B_laneModelC1 0

/**
 * Signal laneModelC1 raw minimum value.
 */
#define MIN_Next_Right_Lane_B_laneModelC1 -366

/**
 * Signal laneModelC1 raw maximum value.
 */
#define MAX_Next_Right_Lane_B_laneModelC1 366

/**
 * Signal laneModelC1 raw offset value.
 */
#define OFF_Next_Right_Lane_B_laneModelC1 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_B_viewRangeStart Signal viewRangeStart of Message Next_Right_Lane_B (0x508)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_B
 * @{
 */

/**
 * Signal viewRangeStart configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_B_viewRangeStart and \ref GET_Next_Right_Lane_B_viewRangeStart instead.
 */
#define SIG_Next_Right_Lane_B_viewRangeStart 0, 0, 10, 9

/**
 * Signal viewRangeStart setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_B_viewRangeStart or \ref INIT_Next_Right_Lane_B instead.
 */
#define SETUP_Next_Right_Lane_B_viewRangeStart 0, 0, 10, 9, 0

/**
 * Get signal viewRangeStart from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_B_viewRangeStart(buf)                                                                      \
    (0 | (uint8_t)(+(uint8_t)((buf[1] >> 2) & 0x3f) << 0) | (uint16_t)(+(uint16_t)((buf[2] >> 0) & 0x07) << 6))

/**
 * Set signal viewRangeStart in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_B_viewRangeStart(buf, val)                                                                 \
    {                                                                                                                  \
        buf[1] &= ~(0x3f << 2);                                                                                        \
        buf[1] |= (((uint8_t)(val) >> 0) & 0x3f) << 2;                                                                 \
        buf[2] &= ~(0x07 << 0);                                                                                        \
        buf[2] |= ((uint8_t)((uint16_t)(val) >> 6) & 0x07) << 0;                                                       \
    }

/**
 * Set signal viewRangeStart in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_B_viewRangeStart(buf) SET_Next_Right_Lane_B_viewRangeStart(buf, 0)

/**
 * Signal viewRangeStart value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_B_viewRangeStart(x, fmt) ((x)*fmt / 2)

/**
 * Signal viewRangeStart raw initial value.
 */
#define START_Next_Right_Lane_B_viewRangeStart 0

/**
 * Signal viewRangeStart raw minimum value.
 */
#define MIN_Next_Right_Lane_B_viewRangeStart 0

/**
 * Signal viewRangeStart raw maximum value.
 */
#define MAX_Next_Right_Lane_B_viewRangeStart 400

/**
 * Signal viewRangeStart raw offset value.
 */
#define OFF_Next_Right_Lane_B_viewRangeStart 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_B_viewRangeEnd Signal viewRangeEnd of Message Next_Right_Lane_B (0x508)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_B
 * @{
 */

/**
 * Signal viewRangeEnd configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_B_viewRangeEnd and \ref GET_Next_Right_Lane_B_viewRangeEnd instead.
 */
#define SIG_Next_Right_Lane_B_viewRangeEnd 0, 0, 19, 9

/**
 * Signal viewRangeEnd setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_B_viewRangeEnd or \ref INIT_Next_Right_Lane_B instead.
 */
#define SETUP_Next_Right_Lane_B_viewRangeEnd 0, 0, 19, 9, 0

/**
 * Get signal viewRangeEnd from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_B_viewRangeEnd(buf)                                                                        \
    (0 | (uint8_t)(+(uint8_t)((buf[2] >> 3) & 0x1f) << 0) | (uint16_t)(+(uint16_t)((buf[3] >> 0) & 0x0f) << 5))

/**
 * Set signal viewRangeEnd in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_B_viewRangeEnd(buf, val)                                                                   \
    {                                                                                                                  \
        buf[2] &= ~(0x1f << 3);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x1f) << 3;                                                                 \
        buf[3] &= ~(0x0f << 0);                                                                                        \
        buf[3] |= ((uint8_t)((uint16_t)(val) >> 5) & 0x0f) << 0;                                                       \
    }

/**
 * Set signal viewRangeEnd in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_B_viewRangeEnd(buf) SET_Next_Right_Lane_B_viewRangeEnd(buf, 0)

/**
 * Signal viewRangeEnd value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_B_viewRangeEnd(x, fmt) ((x)*fmt / 2)

/**
 * Signal viewRangeEnd raw initial value.
 */
#define START_Next_Right_Lane_B_viewRangeEnd 0

/**
 * Signal viewRangeEnd raw minimum value.
 */
#define MIN_Next_Right_Lane_B_viewRangeEnd 0

/**
 * Signal viewRangeEnd raw maximum value.
 */
#define MAX_Next_Right_Lane_B_viewRangeEnd 400

/**
 * Signal viewRangeEnd raw offset value.
 */
#define OFF_Next_Right_Lane_B_viewRangeEnd 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_B_laneMarkColor Signal laneMarkColor of Message Next_Right_Lane_B (0x508)
 *
 * Contains the value table \ref ENUM_Next_Right_Lane_B_laneMarkColor.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_B
 * @{
 */

/**
 * Signal laneMarkColor configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_B_laneMarkColor and \ref GET_Next_Right_Lane_B_laneMarkColor instead.
 */
#define SIG_Next_Right_Lane_B_laneMarkColor 0, 0, 28, 3

/**
 * Signal laneMarkColor setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_B_laneMarkColor or \ref INIT_Next_Right_Lane_B instead.
 */
#define SETUP_Next_Right_Lane_B_laneMarkColor 0, 0, 28, 3, 0

/**
 * Get signal laneMarkColor from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_B_laneMarkColor(buf) (0 | (uint8_t)(+(uint8_t)((buf[3] >> 4) & 0x07) << 0))

/**
 * Set signal laneMarkColor in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_B_laneMarkColor(buf, val)                                                                  \
    {                                                                                                                  \
        buf[3] &= ~(0x07 << 4);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x07) << 4;                                                                 \
    }

/**
 * Set signal laneMarkColor in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_B_laneMarkColor(buf) SET_Next_Right_Lane_B_laneMarkColor(buf, 0)

/**
 * Signal laneMarkColor value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_B_laneMarkColor(x, fmt) ((x)*fmt)

/**
 * Signal laneMarkColor raw initial value.
 */
#define START_Next_Right_Lane_B_laneMarkColor 0

/**
 * Signal laneMarkColor raw minimum value.
 */
#define MIN_Next_Right_Lane_B_laneMarkColor 0

/**
 * Signal laneMarkColor raw maximum value.
 */
#define MAX_Next_Right_Lane_B_laneMarkColor 3

/**
 * Signal laneMarkColor raw offset value.
 */
#define OFF_Next_Right_Lane_B_laneMarkColor 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Next_Right_Lane_B_laneMarkColor Value Table for Signal laneMarkColor in Message Next_Right_Lane_B
 * (0x508)
 *
 * Enum values defined for \ref SIG_Next_Right_Lane_B_laneMarkColor.
 *
 * @ingroup SIG_Next_Right_Lane_B_laneMarkColor
 */

/**
 * Value table Next_Right_Lane_B_laneMarkColor entry invalid.
 *
 * @ingroup ENUM_Next_Right_Lane_B_laneMarkColor
 */
#define Next_Right_Lane_B_laneMarkColor_invalid 3

/**
 * Value table Next_Right_Lane_B_laneMarkColor entry blue.
 *
 * @ingroup ENUM_Next_Right_Lane_B_laneMarkColor
 */
#define Next_Right_Lane_B_laneMarkColor_blue 2

/**
 * Value table Next_Right_Lane_B_laneMarkColor entry yellow.
 *
 * @ingroup ENUM_Next_Right_Lane_B_laneMarkColor
 */
#define Next_Right_Lane_B_laneMarkColor_yellow 1

/**
 * Value table Next_Right_Lane_B_laneMarkColor entry white.
 *
 * @ingroup ENUM_Next_Right_Lane_B_laneMarkColor
 */
#define Next_Right_Lane_B_laneMarkColor_white 0

/**
 * @defgroup SIG_Next_Right_Lane_B_reserved_bits1 Signal reserved_bits1 of Message Next_Right_Lane_B (0x508)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_B
 * @{
 */

/**
 * Signal reserved_bits1 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_B_reserved_bits1 and \ref GET_Next_Right_Lane_B_reserved_bits1 instead.
 */
#define SIG_Next_Right_Lane_B_reserved_bits1 0, 0, 31, 1

/**
 * Signal reserved_bits1 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_B_reserved_bits1 or \ref INIT_Next_Right_Lane_B instead.
 */
#define SETUP_Next_Right_Lane_B_reserved_bits1 0, 0, 31, 1, 0

/**
 * Get signal reserved_bits1 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_B_reserved_bits1(buf) (0 | (uint8_t)(+(uint8_t)((buf[3] >> 7) & 0x01) << 0))

/**
 * Set signal reserved_bits1 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_B_reserved_bits1(buf, val)                                                                 \
    {                                                                                                                  \
        buf[3] &= ~(0x01 << 7);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x01) << 7;                                                                 \
    }

/**
 * Set signal reserved_bits1 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_B_reserved_bits1(buf) SET_Next_Right_Lane_B_reserved_bits1(buf, 0)

/**
 * Signal reserved_bits1 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_B_reserved_bits1(x, fmt) ((x)*fmt)

/**
 * Signal reserved_bits1 raw initial value.
 */
#define START_Next_Right_Lane_B_reserved_bits1 0

/**
 * Signal reserved_bits1 raw minimum value.
 */
#define MIN_Next_Right_Lane_B_reserved_bits1 0

/**
 * Signal reserved_bits1 raw maximum value.
 */
#define MAX_Next_Right_Lane_B_reserved_bits1 0

/**
 * Signal reserved_bits1 raw offset value.
 */
#define OFF_Next_Right_Lane_B_reserved_bits1 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_B_Reserved1_NextlaneB Signal Reserved1_NextlaneB of Message Next_Right_Lane_B (0x508)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_B
 * @{
 */

/**
 * Signal Reserved1_NextlaneB configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_B_Reserved1_NextlaneB and \ref GET_Next_Right_Lane_B_Reserved1_NextlaneB instead.
 */
#define SIG_Next_Right_Lane_B_Reserved1_NextlaneB 0, 0, 32, 32

/**
 * Signal Reserved1_NextlaneB setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_B_Reserved1_NextlaneB or \ref INIT_Next_Right_Lane_B instead.
 */
#define SETUP_Next_Right_Lane_B_Reserved1_NextlaneB 0, 0, 32, 32, 0

/**
 * Get signal Reserved1_NextlaneB from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_B_Reserved1_NextlaneB(buf)                                                                 \
    (0 | (uint8_t)(+(uint8_t)((buf[4] >> 0) & 0xff) << 0) | (uint16_t)(+(uint16_t)((buf[5] >> 0) & 0xff) << 8) |       \
     (uint32_t)(+(uint32_t)((buf[6] >> 0) & 0xff) << 16) | (uint32_t)(+(uint32_t)((buf[7] >> 0) & 0xff) << 24))

/**
 * Set signal Reserved1_NextlaneB in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_B_Reserved1_NextlaneB(buf, val)                                                            \
    {                                                                                                                  \
        buf[4] &= ~(0xff << 0);                                                                                        \
        buf[4] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
        buf[5] &= ~(0xff << 0);                                                                                        \
        buf[5] |= ((uint8_t)((uint16_t)(val) >> 8) & 0xff) << 0;                                                       \
        buf[6] &= ~(0xff << 0);                                                                                        \
        buf[6] |= ((uint8_t)((uint32_t)(val) >> 16) & 0xff) << 0;                                                      \
        buf[7] &= ~(0xff << 0);                                                                                        \
        buf[7] |= ((uint8_t)((uint32_t)(val) >> 24) & 0xff) << 0;                                                      \
    }

/**
 * Set signal Reserved1_NextlaneB in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_B_Reserved1_NextlaneB(buf) SET_Next_Right_Lane_B_Reserved1_NextlaneB(buf, 0)

/**
 * Signal Reserved1_NextlaneB value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_B_Reserved1_NextlaneB(x, fmt) ((x)*fmt)

/**
 * Signal Reserved1_NextlaneB raw initial value.
 */
#define START_Next_Right_Lane_B_Reserved1_NextlaneB 0

/**
 * Signal Reserved1_NextlaneB raw minimum value.
 */
#define MIN_Next_Right_Lane_B_Reserved1_NextlaneB 0

/**
 * Signal Reserved1_NextlaneB raw maximum value.
 */
#define MAX_Next_Right_Lane_B_Reserved1_NextlaneB 0

/**
 * Signal Reserved1_NextlaneB raw offset value.
 */
#define OFF_Next_Right_Lane_B_Reserved1_NextlaneB 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_B_laneModelC1 Signal laneModelC1 of Message Next_Left_Lane_B (0x507)
 *
 * C1 coefficient which Heading Angle can be calculated from
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_B
 * @{
 */

/**
 * Signal laneModelC1 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_B_laneModelC1 and \ref GET_Next_Left_Lane_B_laneModelC1 instead.
 */
#define SIG_Next_Left_Lane_B_laneModelC1 0, 1, 0, 10

/**
 * Signal laneModelC1 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_B_laneModelC1 or \ref INIT_Next_Left_Lane_B instead.
 */
#define SETUP_Next_Left_Lane_B_laneModelC1 0, 1, 0, 10, 0

/**
 * Get signal laneModelC1 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_B_laneModelC1(buf)                                                                          \
    (0 | (uint16_t)(-(uint16_t)((buf[1] >> 1) & 0x01) << 10) | (uint8_t)(+(uint8_t)((buf[0] >> 0) & 0xff) << 0) |      \
     (uint16_t)(+(uint16_t)((buf[1] >> 0) & 0x03) << 8))

/**
 * Set signal laneModelC1 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_B_laneModelC1(buf, val)                                                                     \
    {                                                                                                                  \
        buf[0] &= ~(0xff << 0);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
        buf[1] &= ~(0x03 << 0);                                                                                        \
        buf[1] |= ((uint8_t)((uint16_t)(val) >> 8) & 0x03) << 0;                                                       \
    }

/**
 * Set signal laneModelC1 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_B_laneModelC1(buf) SET_Next_Left_Lane_B_laneModelC1(buf, 0)

/**
 * Signal laneModelC1 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_B_laneModelC1(x, fmt) ((x)*fmt / 1024)

/**
 * Signal laneModelC1 raw initial value.
 */
#define START_Next_Left_Lane_B_laneModelC1 0

/**
 * Signal laneModelC1 raw minimum value.
 */
#define MIN_Next_Left_Lane_B_laneModelC1 -366

/**
 * Signal laneModelC1 raw maximum value.
 */
#define MAX_Next_Left_Lane_B_laneModelC1 366

/**
 * Signal laneModelC1 raw offset value.
 */
#define OFF_Next_Left_Lane_B_laneModelC1 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_B_viewRangeStart Signal viewRangeStart of Message Next_Left_Lane_B (0x507)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_B
 * @{
 */

/**
 * Signal viewRangeStart configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_B_viewRangeStart and \ref GET_Next_Left_Lane_B_viewRangeStart instead.
 */
#define SIG_Next_Left_Lane_B_viewRangeStart 0, 0, 10, 9

/**
 * Signal viewRangeStart setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_B_viewRangeStart or \ref INIT_Next_Left_Lane_B instead.
 */
#define SETUP_Next_Left_Lane_B_viewRangeStart 0, 0, 10, 9, 0

/**
 * Get signal viewRangeStart from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_B_viewRangeStart(buf)                                                                       \
    (0 | (uint8_t)(+(uint8_t)((buf[1] >> 2) & 0x3f) << 0) | (uint16_t)(+(uint16_t)((buf[2] >> 0) & 0x07) << 6))

/**
 * Set signal viewRangeStart in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_B_viewRangeStart(buf, val)                                                                  \
    {                                                                                                                  \
        buf[1] &= ~(0x3f << 2);                                                                                        \
        buf[1] |= (((uint8_t)(val) >> 0) & 0x3f) << 2;                                                                 \
        buf[2] &= ~(0x07 << 0);                                                                                        \
        buf[2] |= ((uint8_t)((uint16_t)(val) >> 6) & 0x07) << 0;                                                       \
    }

/**
 * Set signal viewRangeStart in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_B_viewRangeStart(buf) SET_Next_Left_Lane_B_viewRangeStart(buf, 0)

/**
 * Signal viewRangeStart value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_B_viewRangeStart(x, fmt) ((x)*fmt / 2)

/**
 * Signal viewRangeStart raw initial value.
 */
#define START_Next_Left_Lane_B_viewRangeStart 0

/**
 * Signal viewRangeStart raw minimum value.
 */
#define MIN_Next_Left_Lane_B_viewRangeStart 0

/**
 * Signal viewRangeStart raw maximum value.
 */
#define MAX_Next_Left_Lane_B_viewRangeStart 400

/**
 * Signal viewRangeStart raw offset value.
 */
#define OFF_Next_Left_Lane_B_viewRangeStart 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_B_viewRangeEnd Signal viewRangeEnd of Message Next_Left_Lane_B (0x507)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_B
 * @{
 */

/**
 * Signal viewRangeEnd configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_B_viewRangeEnd and \ref GET_Next_Left_Lane_B_viewRangeEnd instead.
 */
#define SIG_Next_Left_Lane_B_viewRangeEnd 0, 0, 19, 9

/**
 * Signal viewRangeEnd setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_B_viewRangeEnd or \ref INIT_Next_Left_Lane_B instead.
 */
#define SETUP_Next_Left_Lane_B_viewRangeEnd 0, 0, 19, 9, 0

/**
 * Get signal viewRangeEnd from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_B_viewRangeEnd(buf)                                                                         \
    (0 | (uint8_t)(+(uint8_t)((buf[2] >> 3) & 0x1f) << 0) | (uint16_t)(+(uint16_t)((buf[3] >> 0) & 0x0f) << 5))

/**
 * Set signal viewRangeEnd in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_B_viewRangeEnd(buf, val)                                                                    \
    {                                                                                                                  \
        buf[2] &= ~(0x1f << 3);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x1f) << 3;                                                                 \
        buf[3] &= ~(0x0f << 0);                                                                                        \
        buf[3] |= ((uint8_t)((uint16_t)(val) >> 5) & 0x0f) << 0;                                                       \
    }

/**
 * Set signal viewRangeEnd in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_B_viewRangeEnd(buf) SET_Next_Left_Lane_B_viewRangeEnd(buf, 0)

/**
 * Signal viewRangeEnd value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_B_viewRangeEnd(x, fmt) ((x)*fmt / 2)

/**
 * Signal viewRangeEnd raw initial value.
 */
#define START_Next_Left_Lane_B_viewRangeEnd 0

/**
 * Signal viewRangeEnd raw minimum value.
 */
#define MIN_Next_Left_Lane_B_viewRangeEnd 0

/**
 * Signal viewRangeEnd raw maximum value.
 */
#define MAX_Next_Left_Lane_B_viewRangeEnd 400

/**
 * Signal viewRangeEnd raw offset value.
 */
#define OFF_Next_Left_Lane_B_viewRangeEnd 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_B_laneMarkColor Signal laneMarkColor of Message Next_Left_Lane_B (0x507)
 *
 * Contains the value table \ref ENUM_Next_Left_Lane_B_laneMarkColor.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_B
 * @{
 */

/**
 * Signal laneMarkColor configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_B_laneMarkColor and \ref GET_Next_Left_Lane_B_laneMarkColor instead.
 */
#define SIG_Next_Left_Lane_B_laneMarkColor 0, 0, 28, 3

/**
 * Signal laneMarkColor setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_B_laneMarkColor or \ref INIT_Next_Left_Lane_B instead.
 */
#define SETUP_Next_Left_Lane_B_laneMarkColor 0, 0, 28, 3, 0

/**
 * Get signal laneMarkColor from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_B_laneMarkColor(buf) (0 | (uint8_t)(+(uint8_t)((buf[3] >> 4) & 0x07) << 0))

/**
 * Set signal laneMarkColor in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_B_laneMarkColor(buf, val)                                                                   \
    {                                                                                                                  \
        buf[3] &= ~(0x07 << 4);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x07) << 4;                                                                 \
    }

/**
 * Set signal laneMarkColor in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_B_laneMarkColor(buf) SET_Next_Left_Lane_B_laneMarkColor(buf, 0)

/**
 * Signal laneMarkColor value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_B_laneMarkColor(x, fmt) ((x)*fmt)

/**
 * Signal laneMarkColor raw initial value.
 */
#define START_Next_Left_Lane_B_laneMarkColor 0

/**
 * Signal laneMarkColor raw minimum value.
 */
#define MIN_Next_Left_Lane_B_laneMarkColor 0

/**
 * Signal laneMarkColor raw maximum value.
 */
#define MAX_Next_Left_Lane_B_laneMarkColor 3

/**
 * Signal laneMarkColor raw offset value.
 */
#define OFF_Next_Left_Lane_B_laneMarkColor 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Next_Left_Lane_B_laneMarkColor Value Table for Signal laneMarkColor in Message Next_Left_Lane_B
 * (0x507)
 *
 * Enum values defined for \ref SIG_Next_Left_Lane_B_laneMarkColor.
 *
 * @ingroup SIG_Next_Left_Lane_B_laneMarkColor
 */

/**
 * Value table Next_Left_Lane_B_laneMarkColor entry invalid.
 *
 * @ingroup ENUM_Next_Left_Lane_B_laneMarkColor
 */
#define Next_Left_Lane_B_laneMarkColor_invalid 3

/**
 * Value table Next_Left_Lane_B_laneMarkColor entry blue.
 *
 * @ingroup ENUM_Next_Left_Lane_B_laneMarkColor
 */
#define Next_Left_Lane_B_laneMarkColor_blue 2

/**
 * Value table Next_Left_Lane_B_laneMarkColor entry yellow.
 *
 * @ingroup ENUM_Next_Left_Lane_B_laneMarkColor
 */
#define Next_Left_Lane_B_laneMarkColor_yellow 1

/**
 * Value table Next_Left_Lane_B_laneMarkColor entry white.
 *
 * @ingroup ENUM_Next_Left_Lane_B_laneMarkColor
 */
#define Next_Left_Lane_B_laneMarkColor_white 0

/**
 * @defgroup SIG_Next_Left_Lane_B_reserved_bits1 Signal reserved_bits1 of Message Next_Left_Lane_B (0x507)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_B
 * @{
 */

/**
 * Signal reserved_bits1 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_B_reserved_bits1 and \ref GET_Next_Left_Lane_B_reserved_bits1 instead.
 */
#define SIG_Next_Left_Lane_B_reserved_bits1 0, 0, 31, 1

/**
 * Signal reserved_bits1 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_B_reserved_bits1 or \ref INIT_Next_Left_Lane_B instead.
 */
#define SETUP_Next_Left_Lane_B_reserved_bits1 0, 0, 31, 1, 0

/**
 * Get signal reserved_bits1 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_B_reserved_bits1(buf) (0 | (uint8_t)(+(uint8_t)((buf[3] >> 7) & 0x01) << 0))

/**
 * Set signal reserved_bits1 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_B_reserved_bits1(buf, val)                                                                  \
    {                                                                                                                  \
        buf[3] &= ~(0x01 << 7);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x01) << 7;                                                                 \
    }

/**
 * Set signal reserved_bits1 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_B_reserved_bits1(buf) SET_Next_Left_Lane_B_reserved_bits1(buf, 0)

/**
 * Signal reserved_bits1 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_B_reserved_bits1(x, fmt) ((x)*fmt)

/**
 * Signal reserved_bits1 raw initial value.
 */
#define START_Next_Left_Lane_B_reserved_bits1 0

/**
 * Signal reserved_bits1 raw minimum value.
 */
#define MIN_Next_Left_Lane_B_reserved_bits1 0

/**
 * Signal reserved_bits1 raw maximum value.
 */
#define MAX_Next_Left_Lane_B_reserved_bits1 0

/**
 * Signal reserved_bits1 raw offset value.
 */
#define OFF_Next_Left_Lane_B_reserved_bits1 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_B_Reserved1_NextlaneB Signal Reserved1_NextlaneB of Message Next_Left_Lane_B (0x507)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_B
 * @{
 */

/**
 * Signal Reserved1_NextlaneB configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_B_Reserved1_NextlaneB and \ref GET_Next_Left_Lane_B_Reserved1_NextlaneB instead.
 */
#define SIG_Next_Left_Lane_B_Reserved1_NextlaneB 0, 0, 32, 32

/**
 * Signal Reserved1_NextlaneB setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_B_Reserved1_NextlaneB or \ref INIT_Next_Left_Lane_B instead.
 */
#define SETUP_Next_Left_Lane_B_Reserved1_NextlaneB 0, 0, 32, 32, 0

/**
 * Get signal Reserved1_NextlaneB from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_B_Reserved1_NextlaneB(buf)                                                                  \
    (0 | (uint8_t)(+(uint8_t)((buf[4] >> 0) & 0xff) << 0) | (uint16_t)(+(uint16_t)((buf[5] >> 0) & 0xff) << 8) |       \
     (uint32_t)(+(uint32_t)((buf[6] >> 0) & 0xff) << 16) | (uint32_t)(+(uint32_t)((buf[7] >> 0) & 0xff) << 24))

/**
 * Set signal Reserved1_NextlaneB in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_B_Reserved1_NextlaneB(buf, val)                                                             \
    {                                                                                                                  \
        buf[4] &= ~(0xff << 0);                                                                                        \
        buf[4] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
        buf[5] &= ~(0xff << 0);                                                                                        \
        buf[5] |= ((uint8_t)((uint16_t)(val) >> 8) & 0xff) << 0;                                                       \
        buf[6] &= ~(0xff << 0);                                                                                        \
        buf[6] |= ((uint8_t)((uint32_t)(val) >> 16) & 0xff) << 0;                                                      \
        buf[7] &= ~(0xff << 0);                                                                                        \
        buf[7] |= ((uint8_t)((uint32_t)(val) >> 24) & 0xff) << 0;                                                      \
    }

/**
 * Set signal Reserved1_NextlaneB in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_B_Reserved1_NextlaneB(buf) SET_Next_Left_Lane_B_Reserved1_NextlaneB(buf, 0)

/**
 * Signal Reserved1_NextlaneB value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_B_Reserved1_NextlaneB(x, fmt) ((x)*fmt)

/**
 * Signal Reserved1_NextlaneB raw initial value.
 */
#define START_Next_Left_Lane_B_Reserved1_NextlaneB 0

/**
 * Signal Reserved1_NextlaneB raw minimum value.
 */
#define MIN_Next_Left_Lane_B_Reserved1_NextlaneB 0

/**
 * Signal Reserved1_NextlaneB raw maximum value.
 */
#define MAX_Next_Left_Lane_B_Reserved1_NextlaneB 0

/**
 * Signal Reserved1_NextlaneB raw offset value.
 */
#define OFF_Next_Left_Lane_B_Reserved1_NextlaneB 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_A_laneType Signal laneType of Message Next_Right_Lane_A (0x506)
 *
 * Contains the value table \ref ENUM_Next_Right_Lane_A_laneType.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_A
 * @{
 */

/**
 * Signal laneType configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_A_laneType and \ref GET_Next_Right_Lane_A_laneType instead.
 */
#define SIG_Next_Right_Lane_A_laneType 0, 0, 0, 4

/**
 * Signal laneType setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_A_laneType or \ref INIT_Next_Right_Lane_A instead.
 */
#define SETUP_Next_Right_Lane_A_laneType 0, 0, 0, 4, 0

/**
 * Get signal laneType from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_A_laneType(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 0) & 0x0f) << 0))

/**
 * Set signal laneType in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_A_laneType(buf, val)                                                                       \
    {                                                                                                                  \
        buf[0] &= ~(0x0f << 0);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x0f) << 0;                                                                 \
    }

/**
 * Set signal laneType in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_A_laneType(buf) SET_Next_Right_Lane_A_laneType(buf, 0)

/**
 * Signal laneType value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_A_laneType(x, fmt) ((x)*fmt)

/**
 * Signal laneType raw initial value.
 */
#define START_Next_Right_Lane_A_laneType 0

/**
 * Signal laneType raw minimum value.
 */
#define MIN_Next_Right_Lane_A_laneType 0

/**
 * Signal laneType raw maximum value.
 */
#define MAX_Next_Right_Lane_A_laneType 15

/**
 * Signal laneType raw offset value.
 */
#define OFF_Next_Right_Lane_A_laneType 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Next_Right_Lane_A_laneType Value Table for Signal laneType in Message Next_Right_Lane_A (0x506)
 *
 * Enum values defined for \ref SIG_Next_Right_Lane_A_laneType.
 *
 * @ingroup SIG_Next_Right_Lane_A_laneType
 */

/**
 * Value table Next_Right_Lane_A_laneType entry Invalid.
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Invalid 15

/**
 * Value table Next_Right_Lane_A_laneType entry Barrier.
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Barrier 8

/**
 * Value table Next_Right_Lane_A_laneType entry Double.
 *
 * Lane(Double Solid)
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Double 7

/**
 * Value table Next_Right_Lane_A_laneType entry Double_6.
 *
 * Lane(Double Dashed)
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Double_6 6

/**
 * Value table Next_Right_Lane_A_laneType entry Double_5.
 *
 * Lane(Left Solid, Right Dashed)
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Double_5 5

/**
 * Value table Next_Right_Lane_A_laneType entry Double_4.
 *
 * Lane(Left Dashed, Right Solid)
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Double_4 4

/**
 * Value table Next_Right_Lane_A_laneType entry Dashed.
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Dashed 3

/**
 * Value table Next_Right_Lane_A_laneType entry Road.
 *
 * Edge
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Road 2

/**
 * Value table Next_Right_Lane_A_laneType entry Solid.
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Solid 1

/**
 * Value table Next_Right_Lane_A_laneType entry Undecided.
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneType
 */
#define Next_Right_Lane_A_laneType_Undecided 0

/**
 * @defgroup SIG_Next_Right_Lane_A_laneQuality Signal laneQuality of Message Next_Right_Lane_A (0x506)
 *
 * Contains the value table \ref ENUM_Next_Right_Lane_A_laneQuality.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_A
 * @{
 */

/**
 * Signal laneQuality configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_A_laneQuality and \ref GET_Next_Right_Lane_A_laneQuality instead.
 */
#define SIG_Next_Right_Lane_A_laneQuality 0, 0, 4, 2

/**
 * Signal laneQuality setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_A_laneQuality or \ref INIT_Next_Right_Lane_A instead.
 */
#define SETUP_Next_Right_Lane_A_laneQuality 0, 0, 4, 2, 0

/**
 * Get signal laneQuality from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_A_laneQuality(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 4) & 0x03) << 0))

/**
 * Set signal laneQuality in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_A_laneQuality(buf, val)                                                                    \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 4);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 4;                                                                 \
    }

/**
 * Set signal laneQuality in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_A_laneQuality(buf) SET_Next_Right_Lane_A_laneQuality(buf, 0)

/**
 * Signal laneQuality value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_A_laneQuality(x, fmt) ((x)*fmt)

/**
 * Signal laneQuality raw initial value.
 */
#define START_Next_Right_Lane_A_laneQuality 0

/**
 * Signal laneQuality raw minimum value.
 */
#define MIN_Next_Right_Lane_A_laneQuality 0

/**
 * Signal laneQuality raw maximum value.
 */
#define MAX_Next_Right_Lane_A_laneQuality 3

/**
 * Signal laneQuality raw offset value.
 */
#define OFF_Next_Right_Lane_A_laneQuality 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Next_Right_Lane_A_laneQuality Value Table for Signal laneQuality in Message Next_Right_Lane_A (0x506)
 *
 * Enum values defined for \ref SIG_Next_Right_Lane_A_laneQuality.
 *
 * @ingroup SIG_Next_Right_Lane_A_laneQuality
 */

/**
 * Value table Next_Right_Lane_A_laneQuality entry Very.
 *
 * High quality
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneQuality
 */
#define Next_Right_Lane_A_laneQuality_Very 3

/**
 * Value table Next_Right_Lane_A_laneQuality entry High.
 *
 * quality
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneQuality
 */
#define Next_Right_Lane_A_laneQuality_High 2

/**
 * Value table Next_Right_Lane_A_laneQuality entry Low.
 *
 * quality
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneQuality
 */
#define Next_Right_Lane_A_laneQuality_Low 1

/**
 * Value table Next_Right_Lane_A_laneQuality entry Undecided.
 *
 * @ingroup ENUM_Next_Right_Lane_A_laneQuality
 */
#define Next_Right_Lane_A_laneQuality_Undecided 0

/**
 * @defgroup SIG_Next_Right_Lane_A_laneModelC0 Signal laneModelC0 of Message Next_Right_Lane_A (0x506)
 *
 * C0 coefficient which is Lane_Position. Positive to the right.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_A
 * @{
 */

/**
 * Signal laneModelC0 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_A_laneModelC0 and \ref GET_Next_Right_Lane_A_laneModelC0 instead.
 */
#define SIG_Next_Right_Lane_A_laneModelC0 0, 1, 6, 11

/**
 * Signal laneModelC0 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_A_laneModelC0 or \ref INIT_Next_Right_Lane_A instead.
 */
#define SETUP_Next_Right_Lane_A_laneModelC0 0, 1, 6, 11, 0

/**
 * Get signal laneModelC0 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_A_laneModelC0(buf)                                                                         \
    (0 | (uint16_t)(-(uint16_t)((buf[2] >> 0) & 0x01) << 11) | (uint8_t)(+(uint8_t)((buf[0] >> 6) & 0x03) << 0) |      \
     (uint16_t)(+(uint16_t)((buf[1] >> 0) & 0xff) << 2) | (uint16_t)(+(uint16_t)((buf[2] >> 0) & 0x01) << 10))

/**
 * Set signal laneModelC0 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_A_laneModelC0(buf, val)                                                                    \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 6);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 6;                                                                 \
        buf[1] &= ~(0xff << 0);                                                                                        \
        buf[1] |= ((uint8_t)((uint16_t)(val) >> 2) & 0xff) << 0;                                                       \
        buf[2] &= ~(0x01 << 0);                                                                                        \
        buf[2] |= ((uint8_t)((uint16_t)(val) >> 10) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC0 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_A_laneModelC0(buf) SET_Next_Right_Lane_A_laneModelC0(buf, 0)

/**
 * Signal laneModelC0 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_A_laneModelC0(x, fmt) ((x)*fmt / 100)

/**
 * Signal laneModelC0 raw initial value.
 */
#define START_Next_Right_Lane_A_laneModelC0 0

/**
 * Signal laneModelC0 raw minimum value.
 */
#define MIN_Next_Right_Lane_A_laneModelC0 -1000

/**
 * Signal laneModelC0 raw maximum value.
 */
#define MAX_Next_Right_Lane_A_laneModelC0 1000

/**
 * Signal laneModelC0 raw offset value.
 */
#define OFF_Next_Right_Lane_A_laneModelC0 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_A_laneModelC2 Signal laneModelC2 of Message Next_Right_Lane_A (0x506)
 *
 * C2 coefficient which Lane Curvature can be calculated from. Positive if curved to right.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_A
 * @{
 */

/**
 * Signal laneModelC2 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_A_laneModelC2 and \ref GET_Next_Right_Lane_A_laneModelC2 instead.
 */
#define SIG_Next_Right_Lane_A_laneModelC2 0, 1, 17, 16

/**
 * Signal laneModelC2 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_A_laneModelC2 or \ref INIT_Next_Right_Lane_A instead.
 */
#define SETUP_Next_Right_Lane_A_laneModelC2 0, 1, 17, 16, 0

/**
 * Get signal laneModelC2 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_A_laneModelC2(buf)                                                                         \
    (0 | (uint8_t)(+(uint8_t)((buf[2] >> 1) & 0x7f) << 0) | (uint16_t)(+(uint16_t)((buf[3] >> 0) & 0xff) << 7) |       \
     (uint16_t)(+(uint16_t)((buf[4] >> 0) & 0x01) << 15))

/**
 * Set signal laneModelC2 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_A_laneModelC2(buf, val)                                                                    \
    {                                                                                                                  \
        buf[2] &= ~(0x7f << 1);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[3] &= ~(0xff << 0);                                                                                        \
        buf[3] |= ((uint8_t)((uint16_t)(val) >> 7) & 0xff) << 0;                                                       \
        buf[4] &= ~(0x01 << 0);                                                                                        \
        buf[4] |= ((uint8_t)((uint16_t)(val) >> 15) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC2 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_A_laneModelC2(buf) SET_Next_Right_Lane_A_laneModelC2(buf, 0)

/**
 * Signal laneModelC2 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_A_laneModelC2(x, fmt) ((x)*fmt * 500 / 511770726)

/**
 * Signal laneModelC2 raw initial value.
 */
#define START_Next_Right_Lane_A_laneModelC2 0

/**
 * Signal laneModelC2 raw minimum value.
 */
#define MIN_Next_Right_Lane_A_laneModelC2 -32753

/**
 * Signal laneModelC2 raw maximum value.
 */
#define MAX_Next_Right_Lane_A_laneModelC2 32753

/**
 * Signal laneModelC2 raw offset value.
 */
#define OFF_Next_Right_Lane_A_laneModelC2 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_A_laneModelC3 Signal laneModelC3 of Message Next_Right_Lane_A (0x506)
 *
 * C3 coefficient which Lane Curvature Derivative can be calculated from. Sign is According to Curvature.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_A
 * @{
 */

/**
 * Signal laneModelC3 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_A_laneModelC3 and \ref GET_Next_Right_Lane_A_laneModelC3 instead.
 */
#define SIG_Next_Right_Lane_A_laneModelC3 0, 1, 33, 16

/**
 * Signal laneModelC3 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_A_laneModelC3 or \ref INIT_Next_Right_Lane_A instead.
 */
#define SETUP_Next_Right_Lane_A_laneModelC3 0, 1, 33, 16, 0

/**
 * Get signal laneModelC3 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_A_laneModelC3(buf)                                                                         \
    (0 | (uint8_t)(+(uint8_t)((buf[4] >> 1) & 0x7f) << 0) | (uint16_t)(+(uint16_t)((buf[5] >> 0) & 0xff) << 7) |       \
     (uint16_t)(+(uint16_t)((buf[6] >> 0) & 0x01) << 15))

/**
 * Set signal laneModelC3 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_A_laneModelC3(buf, val)                                                                    \
    {                                                                                                                  \
        buf[4] &= ~(0x7f << 1);                                                                                        \
        buf[4] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[5] &= ~(0xff << 0);                                                                                        \
        buf[5] |= ((uint8_t)((uint16_t)(val) >> 7) & 0xff) << 0;                                                       \
        buf[6] &= ~(0x01 << 0);                                                                                        \
        buf[6] |= ((uint8_t)((uint16_t)(val) >> 15) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC3 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_A_laneModelC3(buf) SET_Next_Right_Lane_A_laneModelC3(buf, 0)

/**
 * Signal laneModelC3 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_A_laneModelC3(x, fmt) ((x)*fmt / 268435456)

/**
 * Signal laneModelC3 raw initial value.
 */
#define START_Next_Right_Lane_A_laneModelC3 0

/**
 * Signal laneModelC3 raw minimum value.
 */
#define MIN_Next_Right_Lane_A_laneModelC3 -32749

/**
 * Signal laneModelC3 raw maximum value.
 */
#define MAX_Next_Right_Lane_A_laneModelC3 32749

/**
 * Signal laneModelC3 raw offset value.
 */
#define OFF_Next_Right_Lane_A_laneModelC3 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_A_laneWidthMarking Signal laneWidthMarking of Message Next_Right_Lane_A (0x506)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_A
 * @{
 */

/**
 * Signal laneWidthMarking configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_A_laneWidthMarking and \ref GET_Next_Right_Lane_A_laneWidthMarking instead.
 */
#define SIG_Next_Right_Lane_A_laneWidthMarking 0, 0, 49, 8

/**
 * Signal laneWidthMarking setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_A_laneWidthMarking or \ref INIT_Next_Right_Lane_A instead.
 */
#define SETUP_Next_Right_Lane_A_laneWidthMarking 0, 0, 49, 8, 0

/**
 * Get signal laneWidthMarking from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_A_laneWidthMarking(buf)                                                                    \
    (0 | (uint8_t)(+(uint8_t)((buf[6] >> 1) & 0x7f) << 0) | (uint8_t)(+(uint8_t)((buf[7] >> 0) & 0x01) << 7))

/**
 * Set signal laneWidthMarking in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_A_laneWidthMarking(buf, val)                                                               \
    {                                                                                                                  \
        buf[6] &= ~(0x7f << 1);                                                                                        \
        buf[6] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[7] &= ~(0x01 << 0);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 7) & 0x01) << 0;                                                                 \
    }

/**
 * Set signal laneWidthMarking in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_A_laneWidthMarking(buf) SET_Next_Right_Lane_A_laneWidthMarking(buf, 0)

/**
 * Signal laneWidthMarking value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_A_laneWidthMarking(x, fmt) ((x)*fmt / 100)

/**
 * Signal laneWidthMarking raw initial value.
 */
#define START_Next_Right_Lane_A_laneWidthMarking 0

/**
 * Signal laneWidthMarking raw minimum value.
 */
#define MIN_Next_Right_Lane_A_laneWidthMarking 0

/**
 * Signal laneWidthMarking raw maximum value.
 */
#define MAX_Next_Right_Lane_A_laneWidthMarking 250

/**
 * Signal laneWidthMarking raw offset value.
 */
#define OFF_Next_Right_Lane_A_laneWidthMarking 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_A_laneConfidence Signal laneConfidence of Message Next_Right_Lane_A (0x506)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_A
 * @{
 */

/**
 * Signal laneConfidence configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_A_laneConfidence and \ref GET_Next_Right_Lane_A_laneConfidence instead.
 */
#define SIG_Next_Right_Lane_A_laneConfidence 0, 0, 57, 4

/**
 * Signal laneConfidence setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_A_laneConfidence or \ref INIT_Next_Right_Lane_A instead.
 */
#define SETUP_Next_Right_Lane_A_laneConfidence 0, 0, 57, 4, 0

/**
 * Get signal laneConfidence from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_A_laneConfidence(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 1) & 0x0f) << 0))

/**
 * Set signal laneConfidence in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_A_laneConfidence(buf, val)                                                                 \
    {                                                                                                                  \
        buf[7] &= ~(0x0f << 1);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0x0f) << 1;                                                                 \
    }

/**
 * Set signal laneConfidence in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_A_laneConfidence(buf) SET_Next_Right_Lane_A_laneConfidence(buf, 0)

/**
 * Signal laneConfidence value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_A_laneConfidence(x, fmt) ((x)*fmt / 10)

/**
 * Signal laneConfidence raw initial value.
 */
#define START_Next_Right_Lane_A_laneConfidence 0

/**
 * Signal laneConfidence raw minimum value.
 */
#define MIN_Next_Right_Lane_A_laneConfidence 0

/**
 * Signal laneConfidence raw maximum value.
 */
#define MAX_Next_Right_Lane_A_laneConfidence 10

/**
 * Signal laneConfidence raw offset value.
 */
#define OFF_Next_Right_Lane_A_laneConfidence 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Right_Lane_A_Reserved1_NextlaneA Signal Reserved1_NextlaneA of Message Next_Right_Lane_A (0x506)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Right_Lane_A
 * @{
 */

/**
 * Signal Reserved1_NextlaneA configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Right_Lane_A_Reserved1_NextlaneA and \ref GET_Next_Right_Lane_A_Reserved1_NextlaneA instead.
 */
#define SIG_Next_Right_Lane_A_Reserved1_NextlaneA 0, 0, 61, 3

/**
 * Signal Reserved1_NextlaneA setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Right_Lane_A_Reserved1_NextlaneA or \ref INIT_Next_Right_Lane_A instead.
 */
#define SETUP_Next_Right_Lane_A_Reserved1_NextlaneA 0, 0, 61, 3, 0

/**
 * Get signal Reserved1_NextlaneA from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Right_Lane_A_Reserved1_NextlaneA(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 5) & 0x07) << 0))

/**
 * Set signal Reserved1_NextlaneA in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Right_Lane_A_Reserved1_NextlaneA(buf, val)                                                            \
    {                                                                                                                  \
        buf[7] &= ~(0x07 << 5);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0x07) << 5;                                                                 \
    }

/**
 * Set signal Reserved1_NextlaneA in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Right_Lane_A_Reserved1_NextlaneA(buf) SET_Next_Right_Lane_A_Reserved1_NextlaneA(buf, 0)

/**
 * Signal Reserved1_NextlaneA value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Right_Lane_A_Reserved1_NextlaneA(x, fmt) ((x)*fmt)

/**
 * Signal Reserved1_NextlaneA raw initial value.
 */
#define START_Next_Right_Lane_A_Reserved1_NextlaneA 0

/**
 * Signal Reserved1_NextlaneA raw minimum value.
 */
#define MIN_Next_Right_Lane_A_Reserved1_NextlaneA 0

/**
 * Signal Reserved1_NextlaneA raw maximum value.
 */
#define MAX_Next_Right_Lane_A_Reserved1_NextlaneA 0

/**
 * Signal Reserved1_NextlaneA raw offset value.
 */
#define OFF_Next_Right_Lane_A_Reserved1_NextlaneA 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_A_laneType Signal laneType of Message Next_Left_Lane_A (0x505)
 *
 * Contains the value table \ref ENUM_Next_Left_Lane_A_laneType.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_A
 * @{
 */

/**
 * Signal laneType configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_A_laneType and \ref GET_Next_Left_Lane_A_laneType instead.
 */
#define SIG_Next_Left_Lane_A_laneType 0, 0, 0, 4

/**
 * Signal laneType setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_A_laneType or \ref INIT_Next_Left_Lane_A instead.
 */
#define SETUP_Next_Left_Lane_A_laneType 0, 0, 0, 4, 0

/**
 * Get signal laneType from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_A_laneType(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 0) & 0x0f) << 0))

/**
 * Set signal laneType in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_A_laneType(buf, val)                                                                        \
    {                                                                                                                  \
        buf[0] &= ~(0x0f << 0);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x0f) << 0;                                                                 \
    }

/**
 * Set signal laneType in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_A_laneType(buf) SET_Next_Left_Lane_A_laneType(buf, 0)

/**
 * Signal laneType value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_A_laneType(x, fmt) ((x)*fmt)

/**
 * Signal laneType raw initial value.
 */
#define START_Next_Left_Lane_A_laneType 0

/**
 * Signal laneType raw minimum value.
 */
#define MIN_Next_Left_Lane_A_laneType 0

/**
 * Signal laneType raw maximum value.
 */
#define MAX_Next_Left_Lane_A_laneType 15

/**
 * Signal laneType raw offset value.
 */
#define OFF_Next_Left_Lane_A_laneType 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Next_Left_Lane_A_laneType Value Table for Signal laneType in Message Next_Left_Lane_A (0x505)
 *
 * Enum values defined for \ref SIG_Next_Left_Lane_A_laneType.
 *
 * @ingroup SIG_Next_Left_Lane_A_laneType
 */

/**
 * Value table Next_Left_Lane_A_laneType entry Invalid.
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Invalid 15

/**
 * Value table Next_Left_Lane_A_laneType entry Barrier.
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Barrier 8

/**
 * Value table Next_Left_Lane_A_laneType entry Double.
 *
 * Lane(Double Solid)
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Double 7

/**
 * Value table Next_Left_Lane_A_laneType entry Double_6.
 *
 * Lane(Double Dashed)
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Double_6 6

/**
 * Value table Next_Left_Lane_A_laneType entry Double_5.
 *
 * Lane(Left Solid, Right Dashed)
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Double_5 5

/**
 * Value table Next_Left_Lane_A_laneType entry Double_4.
 *
 * Lane(Left Dashed, Right Solid)
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Double_4 4

/**
 * Value table Next_Left_Lane_A_laneType entry Dashed.
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Dashed 3

/**
 * Value table Next_Left_Lane_A_laneType entry Road.
 *
 * Edge
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Road 2

/**
 * Value table Next_Left_Lane_A_laneType entry Solid.
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Solid 1

/**
 * Value table Next_Left_Lane_A_laneType entry Undecided.
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneType
 */
#define Next_Left_Lane_A_laneType_Undecided 0

/**
 * @defgroup SIG_Next_Left_Lane_A_laneQuality Signal laneQuality of Message Next_Left_Lane_A (0x505)
 *
 * Contains the value table \ref ENUM_Next_Left_Lane_A_laneQuality.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_A
 * @{
 */

/**
 * Signal laneQuality configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_A_laneQuality and \ref GET_Next_Left_Lane_A_laneQuality instead.
 */
#define SIG_Next_Left_Lane_A_laneQuality 0, 0, 4, 2

/**
 * Signal laneQuality setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_A_laneQuality or \ref INIT_Next_Left_Lane_A instead.
 */
#define SETUP_Next_Left_Lane_A_laneQuality 0, 0, 4, 2, 0

/**
 * Get signal laneQuality from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_A_laneQuality(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 4) & 0x03) << 0))

/**
 * Set signal laneQuality in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_A_laneQuality(buf, val)                                                                     \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 4);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 4;                                                                 \
    }

/**
 * Set signal laneQuality in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_A_laneQuality(buf) SET_Next_Left_Lane_A_laneQuality(buf, 0)

/**
 * Signal laneQuality value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_A_laneQuality(x, fmt) ((x)*fmt)

/**
 * Signal laneQuality raw initial value.
 */
#define START_Next_Left_Lane_A_laneQuality 0

/**
 * Signal laneQuality raw minimum value.
 */
#define MIN_Next_Left_Lane_A_laneQuality 0

/**
 * Signal laneQuality raw maximum value.
 */
#define MAX_Next_Left_Lane_A_laneQuality 3

/**
 * Signal laneQuality raw offset value.
 */
#define OFF_Next_Left_Lane_A_laneQuality 0

/**
 * @}
 */

/**
 * @defgroup ENUM_Next_Left_Lane_A_laneQuality Value Table for Signal laneQuality in Message Next_Left_Lane_A (0x505)
 *
 * Enum values defined for \ref SIG_Next_Left_Lane_A_laneQuality.
 *
 * @ingroup SIG_Next_Left_Lane_A_laneQuality
 */

/**
 * Value table Next_Left_Lane_A_laneQuality entry Very.
 *
 * High quality
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneQuality
 */
#define Next_Left_Lane_A_laneQuality_Very 3

/**
 * Value table Next_Left_Lane_A_laneQuality entry High.
 *
 * quality
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneQuality
 */
#define Next_Left_Lane_A_laneQuality_High 2

/**
 * Value table Next_Left_Lane_A_laneQuality entry Low.
 *
 * quality
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneQuality
 */
#define Next_Left_Lane_A_laneQuality_Low 1

/**
 * Value table Next_Left_Lane_A_laneQuality entry Undecided.
 *
 * @ingroup ENUM_Next_Left_Lane_A_laneQuality
 */
#define Next_Left_Lane_A_laneQuality_Undecided 0

/**
 * @defgroup SIG_Next_Left_Lane_A_laneModelC0 Signal laneModelC0 of Message Next_Left_Lane_A (0x505)
 *
 * C0 coefficient which is Lane_Position. Positive to the right.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_A
 * @{
 */

/**
 * Signal laneModelC0 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_A_laneModelC0 and \ref GET_Next_Left_Lane_A_laneModelC0 instead.
 */
#define SIG_Next_Left_Lane_A_laneModelC0 0, 1, 6, 11

/**
 * Signal laneModelC0 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_A_laneModelC0 or \ref INIT_Next_Left_Lane_A instead.
 */
#define SETUP_Next_Left_Lane_A_laneModelC0 0, 1, 6, 11, 0

/**
 * Get signal laneModelC0 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_A_laneModelC0(buf)                                                                          \
    (0 | (uint16_t)(-(uint16_t)((buf[2] >> 0) & 0x01) << 11) | (uint8_t)(+(uint8_t)((buf[0] >> 6) & 0x03) << 0) |      \
     (uint16_t)(+(uint16_t)((buf[1] >> 0) & 0xff) << 2) | (uint16_t)(+(uint16_t)((buf[2] >> 0) & 0x01) << 10))

/**
 * Set signal laneModelC0 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_A_laneModelC0(buf, val)                                                                     \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 6);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 6;                                                                 \
        buf[1] &= ~(0xff << 0);                                                                                        \
        buf[1] |= ((uint8_t)((uint16_t)(val) >> 2) & 0xff) << 0;                                                       \
        buf[2] &= ~(0x01 << 0);                                                                                        \
        buf[2] |= ((uint8_t)((uint16_t)(val) >> 10) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC0 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_A_laneModelC0(buf) SET_Next_Left_Lane_A_laneModelC0(buf, 0)

/**
 * Signal laneModelC0 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_A_laneModelC0(x, fmt) ((x)*fmt / 100)

/**
 * Signal laneModelC0 raw initial value.
 */
#define START_Next_Left_Lane_A_laneModelC0 0

/**
 * Signal laneModelC0 raw minimum value.
 */
#define MIN_Next_Left_Lane_A_laneModelC0 -1000

/**
 * Signal laneModelC0 raw maximum value.
 */
#define MAX_Next_Left_Lane_A_laneModelC0 1000

/**
 * Signal laneModelC0 raw offset value.
 */
#define OFF_Next_Left_Lane_A_laneModelC0 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_A_laneModelC2 Signal laneModelC2 of Message Next_Left_Lane_A (0x505)
 *
 * C2 coefficient which Lane Curvature can be calculated from. Positive if curved to right.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_A
 * @{
 */

/**
 * Signal laneModelC2 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_A_laneModelC2 and \ref GET_Next_Left_Lane_A_laneModelC2 instead.
 */
#define SIG_Next_Left_Lane_A_laneModelC2 0, 1, 17, 16

/**
 * Signal laneModelC2 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_A_laneModelC2 or \ref INIT_Next_Left_Lane_A instead.
 */
#define SETUP_Next_Left_Lane_A_laneModelC2 0, 1, 17, 16, 0

/**
 * Get signal laneModelC2 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_A_laneModelC2(buf)                                                                          \
    (0 | (uint8_t)(+(uint8_t)((buf[2] >> 1) & 0x7f) << 0) | (uint16_t)(+(uint16_t)((buf[3] >> 0) & 0xff) << 7) |       \
     (uint16_t)(+(uint16_t)((buf[4] >> 0) & 0x01) << 15))

/**
 * Set signal laneModelC2 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_A_laneModelC2(buf, val)                                                                     \
    {                                                                                                                  \
        buf[2] &= ~(0x7f << 1);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[3] &= ~(0xff << 0);                                                                                        \
        buf[3] |= ((uint8_t)((uint16_t)(val) >> 7) & 0xff) << 0;                                                       \
        buf[4] &= ~(0x01 << 0);                                                                                        \
        buf[4] |= ((uint8_t)((uint16_t)(val) >> 15) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC2 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_A_laneModelC2(buf) SET_Next_Left_Lane_A_laneModelC2(buf, 0)

/**
 * Signal laneModelC2 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_A_laneModelC2(x, fmt) ((x)*fmt * 500 / 511770726)

/**
 * Signal laneModelC2 raw initial value.
 */
#define START_Next_Left_Lane_A_laneModelC2 0

/**
 * Signal laneModelC2 raw minimum value.
 */
#define MIN_Next_Left_Lane_A_laneModelC2 -32753

/**
 * Signal laneModelC2 raw maximum value.
 */
#define MAX_Next_Left_Lane_A_laneModelC2 32753

/**
 * Signal laneModelC2 raw offset value.
 */
#define OFF_Next_Left_Lane_A_laneModelC2 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_A_laneModelC3 Signal laneModelC3 of Message Next_Left_Lane_A (0x505)
 *
 * C3 coefficient which Lane Curvature Derivative can be calculated from. Sign is According to Curvature.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_A
 * @{
 */

/**
 * Signal laneModelC3 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_A_laneModelC3 and \ref GET_Next_Left_Lane_A_laneModelC3 instead.
 */
#define SIG_Next_Left_Lane_A_laneModelC3 0, 1, 33, 16

/**
 * Signal laneModelC3 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_A_laneModelC3 or \ref INIT_Next_Left_Lane_A instead.
 */
#define SETUP_Next_Left_Lane_A_laneModelC3 0, 1, 33, 16, 0

/**
 * Get signal laneModelC3 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_A_laneModelC3(buf)                                                                          \
    (0 | (uint8_t)(+(uint8_t)((buf[4] >> 1) & 0x7f) << 0) | (uint16_t)(+(uint16_t)((buf[5] >> 0) & 0xff) << 7) |       \
     (uint16_t)(+(uint16_t)((buf[6] >> 0) & 0x01) << 15))

/**
 * Set signal laneModelC3 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_A_laneModelC3(buf, val)                                                                     \
    {                                                                                                                  \
        buf[4] &= ~(0x7f << 1);                                                                                        \
        buf[4] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[5] &= ~(0xff << 0);                                                                                        \
        buf[5] |= ((uint8_t)((uint16_t)(val) >> 7) & 0xff) << 0;                                                       \
        buf[6] &= ~(0x01 << 0);                                                                                        \
        buf[6] |= ((uint8_t)((uint16_t)(val) >> 15) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC3 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_A_laneModelC3(buf) SET_Next_Left_Lane_A_laneModelC3(buf, 0)

/**
 * Signal laneModelC3 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_A_laneModelC3(x, fmt) ((x)*fmt / 268435456)

/**
 * Signal laneModelC3 raw initial value.
 */
#define START_Next_Left_Lane_A_laneModelC3 0

/**
 * Signal laneModelC3 raw minimum value.
 */
#define MIN_Next_Left_Lane_A_laneModelC3 -32749

/**
 * Signal laneModelC3 raw maximum value.
 */
#define MAX_Next_Left_Lane_A_laneModelC3 32749

/**
 * Signal laneModelC3 raw offset value.
 */
#define OFF_Next_Left_Lane_A_laneModelC3 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_A_laneWidthMarking Signal laneWidthMarking of Message Next_Left_Lane_A (0x505)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_A
 * @{
 */

/**
 * Signal laneWidthMarking configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_A_laneWidthMarking and \ref GET_Next_Left_Lane_A_laneWidthMarking instead.
 */
#define SIG_Next_Left_Lane_A_laneWidthMarking 0, 0, 49, 8

/**
 * Signal laneWidthMarking setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_A_laneWidthMarking or \ref INIT_Next_Left_Lane_A instead.
 */
#define SETUP_Next_Left_Lane_A_laneWidthMarking 0, 0, 49, 8, 0

/**
 * Get signal laneWidthMarking from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_A_laneWidthMarking(buf)                                                                     \
    (0 | (uint8_t)(+(uint8_t)((buf[6] >> 1) & 0x7f) << 0) | (uint8_t)(+(uint8_t)((buf[7] >> 0) & 0x01) << 7))

/**
 * Set signal laneWidthMarking in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_A_laneWidthMarking(buf, val)                                                                \
    {                                                                                                                  \
        buf[6] &= ~(0x7f << 1);                                                                                        \
        buf[6] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[7] &= ~(0x01 << 0);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 7) & 0x01) << 0;                                                                 \
    }

/**
 * Set signal laneWidthMarking in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_A_laneWidthMarking(buf) SET_Next_Left_Lane_A_laneWidthMarking(buf, 0)

/**
 * Signal laneWidthMarking value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_A_laneWidthMarking(x, fmt) ((x)*fmt / 100)

/**
 * Signal laneWidthMarking raw initial value.
 */
#define START_Next_Left_Lane_A_laneWidthMarking 0

/**
 * Signal laneWidthMarking raw minimum value.
 */
#define MIN_Next_Left_Lane_A_laneWidthMarking 0

/**
 * Signal laneWidthMarking raw maximum value.
 */
#define MAX_Next_Left_Lane_A_laneWidthMarking 250

/**
 * Signal laneWidthMarking raw offset value.
 */
#define OFF_Next_Left_Lane_A_laneWidthMarking 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_A_laneConfidence Signal laneConfidence of Message Next_Left_Lane_A (0x505)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_A
 * @{
 */

/**
 * Signal laneConfidence configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_A_laneConfidence and \ref GET_Next_Left_Lane_A_laneConfidence instead.
 */
#define SIG_Next_Left_Lane_A_laneConfidence 0, 0, 57, 4

/**
 * Signal laneConfidence setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_A_laneConfidence or \ref INIT_Next_Left_Lane_A instead.
 */
#define SETUP_Next_Left_Lane_A_laneConfidence 0, 0, 57, 4, 0

/**
 * Get signal laneConfidence from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_A_laneConfidence(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 1) & 0x0f) << 0))

/**
 * Set signal laneConfidence in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_A_laneConfidence(buf, val)                                                                  \
    {                                                                                                                  \
        buf[7] &= ~(0x0f << 1);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0x0f) << 1;                                                                 \
    }

/**
 * Set signal laneConfidence in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_A_laneConfidence(buf) SET_Next_Left_Lane_A_laneConfidence(buf, 0)

/**
 * Signal laneConfidence value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_A_laneConfidence(x, fmt) ((x)*fmt / 10)

/**
 * Signal laneConfidence raw initial value.
 */
#define START_Next_Left_Lane_A_laneConfidence 0

/**
 * Signal laneConfidence raw minimum value.
 */
#define MIN_Next_Left_Lane_A_laneConfidence 0

/**
 * Signal laneConfidence raw maximum value.
 */
#define MAX_Next_Left_Lane_A_laneConfidence 10

/**
 * Signal laneConfidence raw offset value.
 */
#define OFF_Next_Left_Lane_A_laneConfidence 0

/**
 * @}
 */

/**
 * @defgroup SIG_Next_Left_Lane_A_Reserved1_NextlaneA Signal Reserved1_NextlaneA of Message Next_Left_Lane_A (0x505)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_Next_Left_Lane_A
 * @{
 */

/**
 * Signal Reserved1_NextlaneA configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_Next_Left_Lane_A_Reserved1_NextlaneA and \ref GET_Next_Left_Lane_A_Reserved1_NextlaneA instead.
 */
#define SIG_Next_Left_Lane_A_Reserved1_NextlaneA 0, 0, 61, 3

/**
 * Signal Reserved1_NextlaneA setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_Next_Left_Lane_A_Reserved1_NextlaneA or \ref INIT_Next_Left_Lane_A instead.
 */
#define SETUP_Next_Left_Lane_A_Reserved1_NextlaneA 0, 0, 61, 3, 0

/**
 * Get signal Reserved1_NextlaneA from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_Next_Left_Lane_A_Reserved1_NextlaneA(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 5) & 0x07) << 0))

/**
 * Set signal Reserved1_NextlaneA in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_Next_Left_Lane_A_Reserved1_NextlaneA(buf, val)                                                             \
    {                                                                                                                  \
        buf[7] &= ~(0x07 << 5);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0x07) << 5;                                                                 \
    }

/**
 * Set signal Reserved1_NextlaneA in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_Next_Left_Lane_A_Reserved1_NextlaneA(buf) SET_Next_Left_Lane_A_Reserved1_NextlaneA(buf, 0)

/**
 * Signal Reserved1_NextlaneA value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_Next_Left_Lane_A_Reserved1_NextlaneA(x, fmt) ((x)*fmt)

/**
 * Signal Reserved1_NextlaneA raw initial value.
 */
#define START_Next_Left_Lane_A_Reserved1_NextlaneA 0

/**
 * Signal Reserved1_NextlaneA raw minimum value.
 */
#define MIN_Next_Left_Lane_A_Reserved1_NextlaneA 0

/**
 * Signal Reserved1_NextlaneA raw maximum value.
 */
#define MAX_Next_Left_Lane_A_Reserved1_NextlaneA 0

/**
 * Signal Reserved1_NextlaneA raw offset value.
 */
#define OFF_Next_Left_Lane_A_Reserved1_NextlaneA 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_B_laneModelC1 Signal laneModelC1 of Message LKA_Right_Lane_B (0x504)
 *
 * C1 coefficient which Heading Angle can be calculated from
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_B
 * @{
 */

/**
 * Signal laneModelC1 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_B_laneModelC1 and \ref GET_LKA_Right_Lane_B_laneModelC1 instead.
 */
#define SIG_LKA_Right_Lane_B_laneModelC1 0, 1, 0, 10

/**
 * Signal laneModelC1 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_B_laneModelC1 or \ref INIT_LKA_Right_Lane_B instead.
 */
#define SETUP_LKA_Right_Lane_B_laneModelC1 0, 1, 0, 10, 0

/**
 * Get signal laneModelC1 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_B_laneModelC1(buf)                                                                          \
    (0 | (uint16_t)(-(uint16_t)((buf[1] >> 1) & 0x01) << 10) | (uint8_t)(+(uint8_t)((buf[0] >> 0) & 0xff) << 0) |      \
     (uint16_t)(+(uint16_t)((buf[1] >> 0) & 0x03) << 8))

/**
 * Set signal laneModelC1 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_B_laneModelC1(buf, val)                                                                     \
    {                                                                                                                  \
        buf[0] &= ~(0xff << 0);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
        buf[1] &= ~(0x03 << 0);                                                                                        \
        buf[1] |= ((uint8_t)((uint16_t)(val) >> 8) & 0x03) << 0;                                                       \
    }

/**
 * Set signal laneModelC1 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_B_laneModelC1(buf) SET_LKA_Right_Lane_B_laneModelC1(buf, 0)

/**
 * Signal laneModelC1 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_B_laneModelC1(x, fmt) ((x)*fmt / 1024)

/**
 * Signal laneModelC1 raw initial value.
 */
#define START_LKA_Right_Lane_B_laneModelC1 0

/**
 * Signal laneModelC1 raw minimum value.
 */
#define MIN_LKA_Right_Lane_B_laneModelC1 -366

/**
 * Signal laneModelC1 raw maximum value.
 */
#define MAX_LKA_Right_Lane_B_laneModelC1 366

/**
 * Signal laneModelC1 raw offset value.
 */
#define OFF_LKA_Right_Lane_B_laneModelC1 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_B_viewRangeStart Signal viewRangeStart of Message LKA_Right_Lane_B (0x504)
 *
 * Lane Start point distance
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_B
 * @{
 */

/**
 * Signal viewRangeStart configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_B_viewRangeStart and \ref GET_LKA_Right_Lane_B_viewRangeStart instead.
 */
#define SIG_LKA_Right_Lane_B_viewRangeStart 0, 0, 10, 9

/**
 * Signal viewRangeStart setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_B_viewRangeStart or \ref INIT_LKA_Right_Lane_B instead.
 */
#define SETUP_LKA_Right_Lane_B_viewRangeStart 0, 0, 10, 9, 0

/**
 * Get signal viewRangeStart from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_B_viewRangeStart(buf)                                                                       \
    (0 | (uint8_t)(+(uint8_t)((buf[1] >> 2) & 0x3f) << 0) | (uint16_t)(+(uint16_t)((buf[2] >> 0) & 0x07) << 6))

/**
 * Set signal viewRangeStart in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_B_viewRangeStart(buf, val)                                                                  \
    {                                                                                                                  \
        buf[1] &= ~(0x3f << 2);                                                                                        \
        buf[1] |= (((uint8_t)(val) >> 0) & 0x3f) << 2;                                                                 \
        buf[2] &= ~(0x07 << 0);                                                                                        \
        buf[2] |= ((uint8_t)((uint16_t)(val) >> 6) & 0x07) << 0;                                                       \
    }

/**
 * Set signal viewRangeStart in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_B_viewRangeStart(buf) SET_LKA_Right_Lane_B_viewRangeStart(buf, 0)

/**
 * Signal viewRangeStart value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_B_viewRangeStart(x, fmt) ((x)*fmt / 2)

/**
 * Signal viewRangeStart raw initial value.
 */
#define START_LKA_Right_Lane_B_viewRangeStart 0

/**
 * Signal viewRangeStart raw minimum value.
 */
#define MIN_LKA_Right_Lane_B_viewRangeStart 0

/**
 * Signal viewRangeStart raw maximum value.
 */
#define MAX_LKA_Right_Lane_B_viewRangeStart 400

/**
 * Signal viewRangeStart raw offset value.
 */
#define OFF_LKA_Right_Lane_B_viewRangeStart 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_B_viewRangeEnd Signal viewRangeEnd of Message LKA_Right_Lane_B (0x504)
 *
 * Lane End point distance
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_B
 * @{
 */

/**
 * Signal viewRangeEnd configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_B_viewRangeEnd and \ref GET_LKA_Right_Lane_B_viewRangeEnd instead.
 */
#define SIG_LKA_Right_Lane_B_viewRangeEnd 0, 0, 19, 9

/**
 * Signal viewRangeEnd setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_B_viewRangeEnd or \ref INIT_LKA_Right_Lane_B instead.
 */
#define SETUP_LKA_Right_Lane_B_viewRangeEnd 0, 0, 19, 9, 0

/**
 * Get signal viewRangeEnd from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_B_viewRangeEnd(buf)                                                                         \
    (0 | (uint8_t)(+(uint8_t)((buf[2] >> 3) & 0x1f) << 0) | (uint16_t)(+(uint16_t)((buf[3] >> 0) & 0x0f) << 5))

/**
 * Set signal viewRangeEnd in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_B_viewRangeEnd(buf, val)                                                                    \
    {                                                                                                                  \
        buf[2] &= ~(0x1f << 3);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x1f) << 3;                                                                 \
        buf[3] &= ~(0x0f << 0);                                                                                        \
        buf[3] |= ((uint8_t)((uint16_t)(val) >> 5) & 0x0f) << 0;                                                       \
    }

/**
 * Set signal viewRangeEnd in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_B_viewRangeEnd(buf) SET_LKA_Right_Lane_B_viewRangeEnd(buf, 0)

/**
 * Signal viewRangeEnd value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_B_viewRangeEnd(x, fmt) ((x)*fmt / 2)

/**
 * Signal viewRangeEnd raw initial value.
 */
#define START_LKA_Right_Lane_B_viewRangeEnd 0

/**
 * Signal viewRangeEnd raw minimum value.
 */
#define MIN_LKA_Right_Lane_B_viewRangeEnd 0

/**
 * Signal viewRangeEnd raw maximum value.
 */
#define MAX_LKA_Right_Lane_B_viewRangeEnd 400

/**
 * Signal viewRangeEnd raw offset value.
 */
#define OFF_LKA_Right_Lane_B_viewRangeEnd 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_B_laneCrossing Signal laneCrossing of Message LKA_Right_Lane_B (0x504)
 *
 * Reserved. Not Implmented
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_B
 * @{
 */

/**
 * Signal laneCrossing configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_B_laneCrossing and \ref GET_LKA_Right_Lane_B_laneCrossing instead.
 */
#define SIG_LKA_Right_Lane_B_laneCrossing 0, 0, 28, 1

/**
 * Signal laneCrossing setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_B_laneCrossing or \ref INIT_LKA_Right_Lane_B instead.
 */
#define SETUP_LKA_Right_Lane_B_laneCrossing 0, 0, 28, 1, 0

/**
 * Get signal laneCrossing from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_B_laneCrossing(buf) (0 | (uint8_t)(+(uint8_t)((buf[3] >> 4) & 0x01) << 0))

/**
 * Set signal laneCrossing in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_B_laneCrossing(buf, val)                                                                    \
    {                                                                                                                  \
        buf[3] &= ~(0x01 << 4);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x01) << 4;                                                                 \
    }

/**
 * Set signal laneCrossing in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_B_laneCrossing(buf) SET_LKA_Right_Lane_B_laneCrossing(buf, 0)

/**
 * Signal laneCrossing value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_B_laneCrossing(x, fmt) ((x)*fmt)

/**
 * Signal laneCrossing raw initial value.
 */
#define START_LKA_Right_Lane_B_laneCrossing 0

/**
 * Signal laneCrossing raw minimum value.
 */
#define MIN_LKA_Right_Lane_B_laneCrossing 0

/**
 * Signal laneCrossing raw maximum value.
 */
#define MAX_LKA_Right_Lane_B_laneCrossing 1

/**
 * Signal laneCrossing raw offset value.
 */
#define OFF_LKA_Right_Lane_B_laneCrossing 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_B_laneMarkColor Signal laneMarkColor of Message LKA_Right_Lane_B (0x504)
 *
 * Lane Color
 *
 * Contains the value table \ref ENUM_LKA_Right_Lane_B_laneMarkColor.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_B
 * @{
 */

/**
 * Signal laneMarkColor configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_B_laneMarkColor and \ref GET_LKA_Right_Lane_B_laneMarkColor instead.
 */
#define SIG_LKA_Right_Lane_B_laneMarkColor 0, 0, 29, 3

/**
 * Signal laneMarkColor setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_B_laneMarkColor or \ref INIT_LKA_Right_Lane_B instead.
 */
#define SETUP_LKA_Right_Lane_B_laneMarkColor 0, 0, 29, 3, 0

/**
 * Get signal laneMarkColor from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_B_laneMarkColor(buf) (0 | (uint8_t)(+(uint8_t)((buf[3] >> 5) & 0x07) << 0))

/**
 * Set signal laneMarkColor in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_B_laneMarkColor(buf, val)                                                                   \
    {                                                                                                                  \
        buf[3] &= ~(0x07 << 5);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x07) << 5;                                                                 \
    }

/**
 * Set signal laneMarkColor in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_B_laneMarkColor(buf) SET_LKA_Right_Lane_B_laneMarkColor(buf, 0)

/**
 * Signal laneMarkColor value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_B_laneMarkColor(x, fmt) ((x)*fmt)

/**
 * Signal laneMarkColor raw initial value.
 */
#define START_LKA_Right_Lane_B_laneMarkColor 0

/**
 * Signal laneMarkColor raw minimum value.
 */
#define MIN_LKA_Right_Lane_B_laneMarkColor 0

/**
 * Signal laneMarkColor raw maximum value.
 */
#define MAX_LKA_Right_Lane_B_laneMarkColor 3

/**
 * Signal laneMarkColor raw offset value.
 */
#define OFF_LKA_Right_Lane_B_laneMarkColor 0

/**
 * @}
 */

/**
 * @defgroup ENUM_LKA_Right_Lane_B_laneMarkColor Value Table for Signal laneMarkColor in Message LKA_Right_Lane_B
 * (0x504)
 *
 * Enum values defined for \ref SIG_LKA_Right_Lane_B_laneMarkColor.
 *
 * @ingroup SIG_LKA_Right_Lane_B_laneMarkColor
 */

/**
 * Value table LKA_Right_Lane_B_laneMarkColor entry invalid.
 *
 * @ingroup ENUM_LKA_Right_Lane_B_laneMarkColor
 */
#define LKA_Right_Lane_B_laneMarkColor_invalid 3

/**
 * Value table LKA_Right_Lane_B_laneMarkColor entry blue.
 *
 * @ingroup ENUM_LKA_Right_Lane_B_laneMarkColor
 */
#define LKA_Right_Lane_B_laneMarkColor_blue 2

/**
 * Value table LKA_Right_Lane_B_laneMarkColor entry yellow.
 *
 * @ingroup ENUM_LKA_Right_Lane_B_laneMarkColor
 */
#define LKA_Right_Lane_B_laneMarkColor_yellow 1

/**
 * Value table LKA_Right_Lane_B_laneMarkColor entry white.
 *
 * @ingroup ENUM_LKA_Right_Lane_B_laneMarkColor
 */
#define LKA_Right_Lane_B_laneMarkColor_white 0

/**
 * @defgroup SIG_LKA_Right_Lane_B_Reserved1_LKAlaneB Signal Reserved1_LKAlaneB of Message LKA_Right_Lane_B (0x504)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_B
 * @{
 */

/**
 * Signal Reserved1_LKAlaneB configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_B_Reserved1_LKAlaneB and \ref GET_LKA_Right_Lane_B_Reserved1_LKAlaneB instead.
 */
#define SIG_LKA_Right_Lane_B_Reserved1_LKAlaneB 0, 0, 32, 8

/**
 * Signal Reserved1_LKAlaneB setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_B_Reserved1_LKAlaneB or \ref INIT_LKA_Right_Lane_B instead.
 */
#define SETUP_LKA_Right_Lane_B_Reserved1_LKAlaneB 0, 0, 32, 8, 0

/**
 * Get signal Reserved1_LKAlaneB from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_B_Reserved1_LKAlaneB(buf) (0 | (uint8_t)(+(uint8_t)((buf[4] >> 0) & 0xff) << 0))

/**
 * Set signal Reserved1_LKAlaneB in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_B_Reserved1_LKAlaneB(buf, val)                                                              \
    {                                                                                                                  \
        buf[4] &= ~(0xff << 0);                                                                                        \
        buf[4] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
    }

/**
 * Set signal Reserved1_LKAlaneB in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_B_Reserved1_LKAlaneB(buf) SET_LKA_Right_Lane_B_Reserved1_LKAlaneB(buf, 0)

/**
 * Signal Reserved1_LKAlaneB value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_B_Reserved1_LKAlaneB(x, fmt) ((x)*fmt)

/**
 * Signal Reserved1_LKAlaneB raw initial value.
 */
#define START_LKA_Right_Lane_B_Reserved1_LKAlaneB 0

/**
 * Signal Reserved1_LKAlaneB raw minimum value.
 */
#define MIN_LKA_Right_Lane_B_Reserved1_LKAlaneB 0

/**
 * Signal Reserved1_LKAlaneB raw maximum value.
 */
#define MAX_LKA_Right_Lane_B_Reserved1_LKAlaneB 0

/**
 * Signal Reserved1_LKAlaneB raw offset value.
 */
#define OFF_LKA_Right_Lane_B_Reserved1_LKAlaneB 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_B_Reserved2_LKAlaneB Signal Reserved2_LKAlaneB of Message LKA_Right_Lane_B (0x504)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_B
 * @{
 */

/**
 * Signal Reserved2_LKAlaneB configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_B_Reserved2_LKAlaneB and \ref GET_LKA_Right_Lane_B_Reserved2_LKAlaneB instead.
 */
#define SIG_LKA_Right_Lane_B_Reserved2_LKAlaneB 0, 0, 40, 8

/**
 * Signal Reserved2_LKAlaneB setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_B_Reserved2_LKAlaneB or \ref INIT_LKA_Right_Lane_B instead.
 */
#define SETUP_LKA_Right_Lane_B_Reserved2_LKAlaneB 0, 0, 40, 8, 0

/**
 * Get signal Reserved2_LKAlaneB from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_B_Reserved2_LKAlaneB(buf) (0 | (uint8_t)(+(uint8_t)((buf[5] >> 0) & 0xff) << 0))

/**
 * Set signal Reserved2_LKAlaneB in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_B_Reserved2_LKAlaneB(buf, val)                                                              \
    {                                                                                                                  \
        buf[5] &= ~(0xff << 0);                                                                                        \
        buf[5] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
    }

/**
 * Set signal Reserved2_LKAlaneB in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_B_Reserved2_LKAlaneB(buf) SET_LKA_Right_Lane_B_Reserved2_LKAlaneB(buf, 0)

/**
 * Signal Reserved2_LKAlaneB value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_B_Reserved2_LKAlaneB(x, fmt) ((x)*fmt)

/**
 * Signal Reserved2_LKAlaneB raw initial value.
 */
#define START_LKA_Right_Lane_B_Reserved2_LKAlaneB 0

/**
 * Signal Reserved2_LKAlaneB raw minimum value.
 */
#define MIN_LKA_Right_Lane_B_Reserved2_LKAlaneB 0

/**
 * Signal Reserved2_LKAlaneB raw maximum value.
 */
#define MAX_LKA_Right_Lane_B_Reserved2_LKAlaneB 0

/**
 * Signal Reserved2_LKAlaneB raw offset value.
 */
#define OFF_LKA_Right_Lane_B_Reserved2_LKAlaneB 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_B_Reserved3_LKAlaneB Signal Reserved3_LKAlaneB of Message LKA_Right_Lane_B (0x504)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_B
 * @{
 */

/**
 * Signal Reserved3_LKAlaneB configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_B_Reserved3_LKAlaneB and \ref GET_LKA_Right_Lane_B_Reserved3_LKAlaneB instead.
 */
#define SIG_LKA_Right_Lane_B_Reserved3_LKAlaneB 0, 0, 48, 8

/**
 * Signal Reserved3_LKAlaneB setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_B_Reserved3_LKAlaneB or \ref INIT_LKA_Right_Lane_B instead.
 */
#define SETUP_LKA_Right_Lane_B_Reserved3_LKAlaneB 0, 0, 48, 8, 0

/**
 * Get signal Reserved3_LKAlaneB from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_B_Reserved3_LKAlaneB(buf) (0 | (uint8_t)(+(uint8_t)((buf[6] >> 0) & 0xff) << 0))

/**
 * Set signal Reserved3_LKAlaneB in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_B_Reserved3_LKAlaneB(buf, val)                                                              \
    {                                                                                                                  \
        buf[6] &= ~(0xff << 0);                                                                                        \
        buf[6] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
    }

/**
 * Set signal Reserved3_LKAlaneB in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_B_Reserved3_LKAlaneB(buf) SET_LKA_Right_Lane_B_Reserved3_LKAlaneB(buf, 0)

/**
 * Signal Reserved3_LKAlaneB value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_B_Reserved3_LKAlaneB(x, fmt) ((x)*fmt)

/**
 * Signal Reserved3_LKAlaneB raw initial value.
 */
#define START_LKA_Right_Lane_B_Reserved3_LKAlaneB 0

/**
 * Signal Reserved3_LKAlaneB raw minimum value.
 */
#define MIN_LKA_Right_Lane_B_Reserved3_LKAlaneB 0

/**
 * Signal Reserved3_LKAlaneB raw maximum value.
 */
#define MAX_LKA_Right_Lane_B_Reserved3_LKAlaneB 0

/**
 * Signal Reserved3_LKAlaneB raw offset value.
 */
#define OFF_LKA_Right_Lane_B_Reserved3_LKAlaneB 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_B_ttlc Signal ttlc of Message LKA_Right_Lane_B (0x504)
 *
 * LDW,LKA ttlc
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_B
 * @{
 */

/**
 * Signal ttlc configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_B_ttlc and \ref GET_LKA_Right_Lane_B_ttlc instead.
 */
#define SIG_LKA_Right_Lane_B_ttlc 0, 0, 56, 8

/**
 * Signal ttlc setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_B_ttlc or \ref INIT_LKA_Right_Lane_B instead.
 */
#define SETUP_LKA_Right_Lane_B_ttlc 0, 0, 56, 8, 0

/**
 * Get signal ttlc from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_B_ttlc(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 0) & 0xff) << 0))

/**
 * Set signal ttlc in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_B_ttlc(buf, val)                                                                            \
    {                                                                                                                  \
        buf[7] &= ~(0xff << 0);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
    }

/**
 * Set signal ttlc in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_B_ttlc(buf) SET_LKA_Right_Lane_B_ttlc(buf, 0)

/**
 * Signal ttlc value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_B_ttlc(x, fmt) ((x)*fmt / 100)

/**
 * Signal ttlc raw initial value.
 */
#define START_LKA_Right_Lane_B_ttlc 0

/**
 * Signal ttlc raw minimum value.
 */
#define MIN_LKA_Right_Lane_B_ttlc 0

/**
 * Signal ttlc raw maximum value.
 */
#define MAX_LKA_Right_Lane_B_ttlc 200

/**
 * Signal ttlc raw offset value.
 */
#define OFF_LKA_Right_Lane_B_ttlc 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_A_laneType Signal laneType of Message LKA_Right_Lane_A (0x503)
 *
 * Lane Type
 *
 * Contains the value table \ref ENUM_LKA_Right_Lane_A_laneType.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_A
 * @{
 */

/**
 * Signal laneType configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_A_laneType and \ref GET_LKA_Right_Lane_A_laneType instead.
 */
#define SIG_LKA_Right_Lane_A_laneType 0, 0, 0, 4

/**
 * Signal laneType setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_A_laneType or \ref INIT_LKA_Right_Lane_A instead.
 */
#define SETUP_LKA_Right_Lane_A_laneType 0, 0, 0, 4, 0

/**
 * Get signal laneType from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_A_laneType(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 0) & 0x0f) << 0))

/**
 * Set signal laneType in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_A_laneType(buf, val)                                                                        \
    {                                                                                                                  \
        buf[0] &= ~(0x0f << 0);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x0f) << 0;                                                                 \
    }

/**
 * Set signal laneType in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_A_laneType(buf) SET_LKA_Right_Lane_A_laneType(buf, 0)

/**
 * Signal laneType value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_A_laneType(x, fmt) ((x)*fmt)

/**
 * Signal laneType raw initial value.
 */
#define START_LKA_Right_Lane_A_laneType 0

/**
 * Signal laneType raw minimum value.
 */
#define MIN_LKA_Right_Lane_A_laneType 0

/**
 * Signal laneType raw maximum value.
 */
#define MAX_LKA_Right_Lane_A_laneType 15

/**
 * Signal laneType raw offset value.
 */
#define OFF_LKA_Right_Lane_A_laneType 0

/**
 * @}
 */

/**
 * @defgroup ENUM_LKA_Right_Lane_A_laneType Value Table for Signal laneType in Message LKA_Right_Lane_A (0x503)
 *
 * Enum values defined for \ref SIG_LKA_Right_Lane_A_laneType.
 *
 * @ingroup SIG_LKA_Right_Lane_A_laneType
 */

/**
 * Value table LKA_Right_Lane_A_laneType entry Invalid.
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Invalid 15

/**
 * Value table LKA_Right_Lane_A_laneType entry Barrier.
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Barrier 8

/**
 * Value table LKA_Right_Lane_A_laneType entry Double.
 *
 * Lane(Double Solid)
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Double 7

/**
 * Value table LKA_Right_Lane_A_laneType entry Double_6.
 *
 * Lane(Double Dashed)
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Double_6 6

/**
 * Value table LKA_Right_Lane_A_laneType entry Double_5.
 *
 * Lane(Left Solid, Right Dashed)
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Double_5 5

/**
 * Value table LKA_Right_Lane_A_laneType entry Double_4.
 *
 * Lane(Left Dashed, Right Solid)
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Double_4 4

/**
 * Value table LKA_Right_Lane_A_laneType entry Dashed.
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Dashed 3

/**
 * Value table LKA_Right_Lane_A_laneType entry Road.
 *
 * Edge
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Road 2

/**
 * Value table LKA_Right_Lane_A_laneType entry Solid.
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Solid 1

/**
 * Value table LKA_Right_Lane_A_laneType entry Undecided.
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneType
 */
#define LKA_Right_Lane_A_laneType_Undecided 0

/**
 * @defgroup SIG_LKA_Right_Lane_A_laneQuality Signal laneQuality of Message LKA_Right_Lane_A (0x503)
 *
 * Reserved Not Implemented
 *
 * Contains the value table \ref ENUM_LKA_Right_Lane_A_laneQuality.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_A
 * @{
 */

/**
 * Signal laneQuality configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_A_laneQuality and \ref GET_LKA_Right_Lane_A_laneQuality instead.
 */
#define SIG_LKA_Right_Lane_A_laneQuality 0, 0, 4, 2

/**
 * Signal laneQuality setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_A_laneQuality or \ref INIT_LKA_Right_Lane_A instead.
 */
#define SETUP_LKA_Right_Lane_A_laneQuality 0, 0, 4, 2, 0

/**
 * Get signal laneQuality from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_A_laneQuality(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 4) & 0x03) << 0))

/**
 * Set signal laneQuality in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_A_laneQuality(buf, val)                                                                     \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 4);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 4;                                                                 \
    }

/**
 * Set signal laneQuality in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_A_laneQuality(buf) SET_LKA_Right_Lane_A_laneQuality(buf, 0)

/**
 * Signal laneQuality value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_A_laneQuality(x, fmt) ((x)*fmt)

/**
 * Signal laneQuality raw initial value.
 */
#define START_LKA_Right_Lane_A_laneQuality 0

/**
 * Signal laneQuality raw minimum value.
 */
#define MIN_LKA_Right_Lane_A_laneQuality 0

/**
 * Signal laneQuality raw maximum value.
 */
#define MAX_LKA_Right_Lane_A_laneQuality 3

/**
 * Signal laneQuality raw offset value.
 */
#define OFF_LKA_Right_Lane_A_laneQuality 0

/**
 * @}
 */

/**
 * @defgroup ENUM_LKA_Right_Lane_A_laneQuality Value Table for Signal laneQuality in Message LKA_Right_Lane_A (0x503)
 *
 * Enum values defined for \ref SIG_LKA_Right_Lane_A_laneQuality.
 *
 * @ingroup SIG_LKA_Right_Lane_A_laneQuality
 */

/**
 * Value table LKA_Right_Lane_A_laneQuality entry Very.
 *
 * High quality
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneQuality
 */
#define LKA_Right_Lane_A_laneQuality_Very 3

/**
 * Value table LKA_Right_Lane_A_laneQuality entry High.
 *
 * quality
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneQuality
 */
#define LKA_Right_Lane_A_laneQuality_High 2

/**
 * Value table LKA_Right_Lane_A_laneQuality entry Low.
 *
 * quality
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneQuality
 */
#define LKA_Right_Lane_A_laneQuality_Low 1

/**
 * Value table LKA_Right_Lane_A_laneQuality entry Undecided.
 *
 * @ingroup ENUM_LKA_Right_Lane_A_laneQuality
 */
#define LKA_Right_Lane_A_laneQuality_Undecided 0

/**
 * @defgroup SIG_LKA_Right_Lane_A_laneModelC0 Signal laneModelC0 of Message LKA_Right_Lane_A (0x503)
 *
 * C0 coefficient which is Lane_Position. Positive to the left.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_A
 * @{
 */

/**
 * Signal laneModelC0 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_A_laneModelC0 and \ref GET_LKA_Right_Lane_A_laneModelC0 instead.
 */
#define SIG_LKA_Right_Lane_A_laneModelC0 0, 1, 6, 11

/**
 * Signal laneModelC0 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_A_laneModelC0 or \ref INIT_LKA_Right_Lane_A instead.
 */
#define SETUP_LKA_Right_Lane_A_laneModelC0 0, 1, 6, 11, 0

/**
 * Get signal laneModelC0 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_A_laneModelC0(buf)                                                                          \
    (0 | (uint16_t)(-(uint16_t)((buf[2] >> 0) & 0x01) << 11) | (uint8_t)(+(uint8_t)((buf[0] >> 6) & 0x03) << 0) |      \
     (uint16_t)(+(uint16_t)((buf[1] >> 0) & 0xff) << 2) | (uint16_t)(+(uint16_t)((buf[2] >> 0) & 0x01) << 10))

/**
 * Set signal laneModelC0 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_A_laneModelC0(buf, val)                                                                     \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 6);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 6;                                                                 \
        buf[1] &= ~(0xff << 0);                                                                                        \
        buf[1] |= ((uint8_t)((uint16_t)(val) >> 2) & 0xff) << 0;                                                       \
        buf[2] &= ~(0x01 << 0);                                                                                        \
        buf[2] |= ((uint8_t)((uint16_t)(val) >> 10) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC0 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_A_laneModelC0(buf) SET_LKA_Right_Lane_A_laneModelC0(buf, 0)

/**
 * Signal laneModelC0 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_A_laneModelC0(x, fmt) ((x)*fmt / 100)

/**
 * Signal laneModelC0 raw initial value.
 */
#define START_LKA_Right_Lane_A_laneModelC0 0

/**
 * Signal laneModelC0 raw minimum value.
 */
#define MIN_LKA_Right_Lane_A_laneModelC0 -1000

/**
 * Signal laneModelC0 raw maximum value.
 */
#define MAX_LKA_Right_Lane_A_laneModelC0 1000

/**
 * Signal laneModelC0 raw offset value.
 */
#define OFF_LKA_Right_Lane_A_laneModelC0 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_A_laneModelC2 Signal laneModelC2 of Message LKA_Right_Lane_A (0x503)
 *
 * C2 coefficient which Lane Curvature can be calculated from. Positive if curved to left.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_A
 * @{
 */

/**
 * Signal laneModelC2 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_A_laneModelC2 and \ref GET_LKA_Right_Lane_A_laneModelC2 instead.
 */
#define SIG_LKA_Right_Lane_A_laneModelC2 0, 1, 17, 16

/**
 * Signal laneModelC2 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_A_laneModelC2 or \ref INIT_LKA_Right_Lane_A instead.
 */
#define SETUP_LKA_Right_Lane_A_laneModelC2 0, 1, 17, 16, 0

/**
 * Get signal laneModelC2 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_A_laneModelC2(buf)                                                                          \
    (0 | (uint8_t)(+(uint8_t)((buf[2] >> 1) & 0x7f) << 0) | (uint16_t)(+(uint16_t)((buf[3] >> 0) & 0xff) << 7) |       \
     (uint16_t)(+(uint16_t)((buf[4] >> 0) & 0x01) << 15))

/**
 * Set signal laneModelC2 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_A_laneModelC2(buf, val)                                                                     \
    {                                                                                                                  \
        buf[2] &= ~(0x7f << 1);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[3] &= ~(0xff << 0);                                                                                        \
        buf[3] |= ((uint8_t)((uint16_t)(val) >> 7) & 0xff) << 0;                                                       \
        buf[4] &= ~(0x01 << 0);                                                                                        \
        buf[4] |= ((uint8_t)((uint16_t)(val) >> 15) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC2 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_A_laneModelC2(buf) SET_LKA_Right_Lane_A_laneModelC2(buf, 0)

/**
 * Signal laneModelC2 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_A_laneModelC2(x, fmt) ((x)*fmt * 500 / 511770726)

/**
 * Signal laneModelC2 raw initial value.
 */
#define START_LKA_Right_Lane_A_laneModelC2 0

/**
 * Signal laneModelC2 raw minimum value.
 */
#define MIN_LKA_Right_Lane_A_laneModelC2 -32753

/**
 * Signal laneModelC2 raw maximum value.
 */
#define MAX_LKA_Right_Lane_A_laneModelC2 32753

/**
 * Signal laneModelC2 raw offset value.
 */
#define OFF_LKA_Right_Lane_A_laneModelC2 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_A_laneModelC3 Signal laneModelC3 of Message LKA_Right_Lane_A (0x503)
 *
 * C3 coefficient which Lane Curvature Derivative can be calculated from. Sign is According to Curvature.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_A
 * @{
 */

/**
 * Signal laneModelC3 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_A_laneModelC3 and \ref GET_LKA_Right_Lane_A_laneModelC3 instead.
 */
#define SIG_LKA_Right_Lane_A_laneModelC3 0, 1, 33, 16

/**
 * Signal laneModelC3 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_A_laneModelC3 or \ref INIT_LKA_Right_Lane_A instead.
 */
#define SETUP_LKA_Right_Lane_A_laneModelC3 0, 1, 33, 16, 0

/**
 * Get signal laneModelC3 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_A_laneModelC3(buf)                                                                          \
    (0 | (uint8_t)(+(uint8_t)((buf[4] >> 1) & 0x7f) << 0) | (uint16_t)(+(uint16_t)((buf[5] >> 0) & 0xff) << 7) |       \
     (uint16_t)(+(uint16_t)((buf[6] >> 0) & 0x01) << 15))

/**
 * Set signal laneModelC3 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_A_laneModelC3(buf, val)                                                                     \
    {                                                                                                                  \
        buf[4] &= ~(0x7f << 1);                                                                                        \
        buf[4] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[5] &= ~(0xff << 0);                                                                                        \
        buf[5] |= ((uint8_t)((uint16_t)(val) >> 7) & 0xff) << 0;                                                       \
        buf[6] &= ~(0x01 << 0);                                                                                        \
        buf[6] |= ((uint8_t)((uint16_t)(val) >> 15) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC3 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_A_laneModelC3(buf) SET_LKA_Right_Lane_A_laneModelC3(buf, 0)

/**
 * Signal laneModelC3 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_A_laneModelC3(x, fmt) ((x)*fmt / 268435456)

/**
 * Signal laneModelC3 raw initial value.
 */
#define START_LKA_Right_Lane_A_laneModelC3 0

/**
 * Signal laneModelC3 raw minimum value.
 */
#define MIN_LKA_Right_Lane_A_laneModelC3 -32749

/**
 * Signal laneModelC3 raw maximum value.
 */
#define MAX_LKA_Right_Lane_A_laneModelC3 32749

/**
 * Signal laneModelC3 raw offset value.
 */
#define OFF_LKA_Right_Lane_A_laneModelC3 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_A_laneWidthMarking Signal laneWidthMarking of Message LKA_Right_Lane_A (0x503)
 *
 * Lane width
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_A
 * @{
 */

/**
 * Signal laneWidthMarking configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_A_laneWidthMarking and \ref GET_LKA_Right_Lane_A_laneWidthMarking instead.
 */
#define SIG_LKA_Right_Lane_A_laneWidthMarking 0, 0, 49, 8

/**
 * Signal laneWidthMarking setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_A_laneWidthMarking or \ref INIT_LKA_Right_Lane_A instead.
 */
#define SETUP_LKA_Right_Lane_A_laneWidthMarking 0, 0, 49, 8, 0

/**
 * Get signal laneWidthMarking from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_A_laneWidthMarking(buf)                                                                     \
    (0 | (uint8_t)(+(uint8_t)((buf[6] >> 1) & 0x7f) << 0) | (uint8_t)(+(uint8_t)((buf[7] >> 0) & 0x01) << 7))

/**
 * Set signal laneWidthMarking in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_A_laneWidthMarking(buf, val)                                                                \
    {                                                                                                                  \
        buf[6] &= ~(0x7f << 1);                                                                                        \
        buf[6] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[7] &= ~(0x01 << 0);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 7) & 0x01) << 0;                                                                 \
    }

/**
 * Set signal laneWidthMarking in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_A_laneWidthMarking(buf) SET_LKA_Right_Lane_A_laneWidthMarking(buf, 0)

/**
 * Signal laneWidthMarking value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_A_laneWidthMarking(x, fmt) ((x)*fmt / 100)

/**
 * Signal laneWidthMarking raw initial value.
 */
#define START_LKA_Right_Lane_A_laneWidthMarking 0

/**
 * Signal laneWidthMarking raw minimum value.
 */
#define MIN_LKA_Right_Lane_A_laneWidthMarking 0

/**
 * Signal laneWidthMarking raw maximum value.
 */
#define MAX_LKA_Right_Lane_A_laneWidthMarking 250

/**
 * Signal laneWidthMarking raw offset value.
 */
#define OFF_LKA_Right_Lane_A_laneWidthMarking 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_A_laneConfidence Signal laneConfidence of Message LKA_Right_Lane_A (0x503)
 *
 * Lane Confidence
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_A
 * @{
 */

/**
 * Signal laneConfidence configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_A_laneConfidence and \ref GET_LKA_Right_Lane_A_laneConfidence instead.
 */
#define SIG_LKA_Right_Lane_A_laneConfidence 0, 0, 57, 4

/**
 * Signal laneConfidence setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_A_laneConfidence or \ref INIT_LKA_Right_Lane_A instead.
 */
#define SETUP_LKA_Right_Lane_A_laneConfidence 0, 0, 57, 4, 0

/**
 * Get signal laneConfidence from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_A_laneConfidence(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 1) & 0x0f) << 0))

/**
 * Set signal laneConfidence in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_A_laneConfidence(buf, val)                                                                  \
    {                                                                                                                  \
        buf[7] &= ~(0x0f << 1);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0x0f) << 1;                                                                 \
    }

/**
 * Set signal laneConfidence in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_A_laneConfidence(buf) SET_LKA_Right_Lane_A_laneConfidence(buf, 0)

/**
 * Signal laneConfidence value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_A_laneConfidence(x, fmt) ((x)*fmt / 10)

/**
 * Signal laneConfidence raw initial value.
 */
#define START_LKA_Right_Lane_A_laneConfidence 0

/**
 * Signal laneConfidence raw minimum value.
 */
#define MIN_LKA_Right_Lane_A_laneConfidence 0

/**
 * Signal laneConfidence raw maximum value.
 */
#define MAX_LKA_Right_Lane_A_laneConfidence 10

/**
 * Signal laneConfidence raw offset value.
 */
#define OFF_LKA_Right_Lane_A_laneConfidence 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Right_Lane_A_Reserved1_LKAlaneA Signal Reserved1_LKAlaneA of Message LKA_Right_Lane_A (0x503)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Right_Lane_A
 * @{
 */

/**
 * Signal Reserved1_LKAlaneA configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Right_Lane_A_Reserved1_LKAlaneA and \ref GET_LKA_Right_Lane_A_Reserved1_LKAlaneA instead.
 */
#define SIG_LKA_Right_Lane_A_Reserved1_LKAlaneA 0, 0, 61, 3

/**
 * Signal Reserved1_LKAlaneA setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Right_Lane_A_Reserved1_LKAlaneA or \ref INIT_LKA_Right_Lane_A instead.
 */
#define SETUP_LKA_Right_Lane_A_Reserved1_LKAlaneA 0, 0, 61, 3, 0

/**
 * Get signal Reserved1_LKAlaneA from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Right_Lane_A_Reserved1_LKAlaneA(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 5) & 0x07) << 0))

/**
 * Set signal Reserved1_LKAlaneA in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Right_Lane_A_Reserved1_LKAlaneA(buf, val)                                                              \
    {                                                                                                                  \
        buf[7] &= ~(0x07 << 5);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0x07) << 5;                                                                 \
    }

/**
 * Set signal Reserved1_LKAlaneA in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Right_Lane_A_Reserved1_LKAlaneA(buf) SET_LKA_Right_Lane_A_Reserved1_LKAlaneA(buf, 0)

/**
 * Signal Reserved1_LKAlaneA value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Right_Lane_A_Reserved1_LKAlaneA(x, fmt) ((x)*fmt)

/**
 * Signal Reserved1_LKAlaneA raw initial value.
 */
#define START_LKA_Right_Lane_A_Reserved1_LKAlaneA 0

/**
 * Signal Reserved1_LKAlaneA raw minimum value.
 */
#define MIN_LKA_Right_Lane_A_Reserved1_LKAlaneA 0

/**
 * Signal Reserved1_LKAlaneA raw maximum value.
 */
#define MAX_LKA_Right_Lane_A_Reserved1_LKAlaneA 0

/**
 * Signal Reserved1_LKAlaneA raw offset value.
 */
#define OFF_LKA_Right_Lane_A_Reserved1_LKAlaneA 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_B_laneModelC1 Signal laneModelC1 of Message LKA_Left_Lane_B (0x502)
 *
 * C1 coefficient which Heading Angle can be calculated from
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_B
 * @{
 */

/**
 * Signal laneModelC1 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_B_laneModelC1 and \ref GET_LKA_Left_Lane_B_laneModelC1 instead.
 */
#define SIG_LKA_Left_Lane_B_laneModelC1 0, 1, 0, 10

/**
 * Signal laneModelC1 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_B_laneModelC1 or \ref INIT_LKA_Left_Lane_B instead.
 */
#define SETUP_LKA_Left_Lane_B_laneModelC1 0, 1, 0, 10, 0

/**
 * Get signal laneModelC1 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_B_laneModelC1(buf)                                                                           \
    (0 | (uint16_t)(-(uint16_t)((buf[1] >> 1) & 0x01) << 10) | (uint8_t)(+(uint8_t)((buf[0] >> 0) & 0xff) << 0) |      \
     (uint16_t)(+(uint16_t)((buf[1] >> 0) & 0x03) << 8))

/**
 * Set signal laneModelC1 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_B_laneModelC1(buf, val)                                                                      \
    {                                                                                                                  \
        buf[0] &= ~(0xff << 0);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
        buf[1] &= ~(0x03 << 0);                                                                                        \
        buf[1] |= ((uint8_t)((uint16_t)(val) >> 8) & 0x03) << 0;                                                       \
    }

/**
 * Set signal laneModelC1 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_B_laneModelC1(buf) SET_LKA_Left_Lane_B_laneModelC1(buf, 0)

/**
 * Signal laneModelC1 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_B_laneModelC1(x, fmt) ((x)*fmt / 1024)

/**
 * Signal laneModelC1 raw initial value.
 */
#define START_LKA_Left_Lane_B_laneModelC1 0

/**
 * Signal laneModelC1 raw minimum value.
 */
#define MIN_LKA_Left_Lane_B_laneModelC1 -366

/**
 * Signal laneModelC1 raw maximum value.
 */
#define MAX_LKA_Left_Lane_B_laneModelC1 366

/**
 * Signal laneModelC1 raw offset value.
 */
#define OFF_LKA_Left_Lane_B_laneModelC1 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_B_viewRangeStart Signal viewRangeStart of Message LKA_Left_Lane_B (0x502)
 *
 * Lane Start point distance
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_B
 * @{
 */

/**
 * Signal viewRangeStart configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_B_viewRangeStart and \ref GET_LKA_Left_Lane_B_viewRangeStart instead.
 */
#define SIG_LKA_Left_Lane_B_viewRangeStart 0, 0, 10, 9

/**
 * Signal viewRangeStart setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_B_viewRangeStart or \ref INIT_LKA_Left_Lane_B instead.
 */
#define SETUP_LKA_Left_Lane_B_viewRangeStart 0, 0, 10, 9, 0

/**
 * Get signal viewRangeStart from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_B_viewRangeStart(buf)                                                                        \
    (0 | (uint8_t)(+(uint8_t)((buf[1] >> 2) & 0x3f) << 0) | (uint16_t)(+(uint16_t)((buf[2] >> 0) & 0x07) << 6))

/**
 * Set signal viewRangeStart in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_B_viewRangeStart(buf, val)                                                                   \
    {                                                                                                                  \
        buf[1] &= ~(0x3f << 2);                                                                                        \
        buf[1] |= (((uint8_t)(val) >> 0) & 0x3f) << 2;                                                                 \
        buf[2] &= ~(0x07 << 0);                                                                                        \
        buf[2] |= ((uint8_t)((uint16_t)(val) >> 6) & 0x07) << 0;                                                       \
    }

/**
 * Set signal viewRangeStart in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_B_viewRangeStart(buf) SET_LKA_Left_Lane_B_viewRangeStart(buf, 0)

/**
 * Signal viewRangeStart value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_B_viewRangeStart(x, fmt) ((x)*fmt / 2)

/**
 * Signal viewRangeStart raw initial value.
 */
#define START_LKA_Left_Lane_B_viewRangeStart 0

/**
 * Signal viewRangeStart raw minimum value.
 */
#define MIN_LKA_Left_Lane_B_viewRangeStart 0

/**
 * Signal viewRangeStart raw maximum value.
 */
#define MAX_LKA_Left_Lane_B_viewRangeStart 400

/**
 * Signal viewRangeStart raw offset value.
 */
#define OFF_LKA_Left_Lane_B_viewRangeStart 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_B_viewRangeEnd Signal viewRangeEnd of Message LKA_Left_Lane_B (0x502)
 *
 * Lane End point distance
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_B
 * @{
 */

/**
 * Signal viewRangeEnd configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_B_viewRangeEnd and \ref GET_LKA_Left_Lane_B_viewRangeEnd instead.
 */
#define SIG_LKA_Left_Lane_B_viewRangeEnd 0, 0, 19, 9

/**
 * Signal viewRangeEnd setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_B_viewRangeEnd or \ref INIT_LKA_Left_Lane_B instead.
 */
#define SETUP_LKA_Left_Lane_B_viewRangeEnd 0, 0, 19, 9, 0

/**
 * Get signal viewRangeEnd from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_B_viewRangeEnd(buf)                                                                          \
    (0 | (uint8_t)(+(uint8_t)((buf[2] >> 3) & 0x1f) << 0) | (uint16_t)(+(uint16_t)((buf[3] >> 0) & 0x0f) << 5))

/**
 * Set signal viewRangeEnd in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_B_viewRangeEnd(buf, val)                                                                     \
    {                                                                                                                  \
        buf[2] &= ~(0x1f << 3);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x1f) << 3;                                                                 \
        buf[3] &= ~(0x0f << 0);                                                                                        \
        buf[3] |= ((uint8_t)((uint16_t)(val) >> 5) & 0x0f) << 0;                                                       \
    }

/**
 * Set signal viewRangeEnd in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_B_viewRangeEnd(buf) SET_LKA_Left_Lane_B_viewRangeEnd(buf, 0)

/**
 * Signal viewRangeEnd value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_B_viewRangeEnd(x, fmt) ((x)*fmt / 2)

/**
 * Signal viewRangeEnd raw initial value.
 */
#define START_LKA_Left_Lane_B_viewRangeEnd 0

/**
 * Signal viewRangeEnd raw minimum value.
 */
#define MIN_LKA_Left_Lane_B_viewRangeEnd 0

/**
 * Signal viewRangeEnd raw maximum value.
 */
#define MAX_LKA_Left_Lane_B_viewRangeEnd 400

/**
 * Signal viewRangeEnd raw offset value.
 */
#define OFF_LKA_Left_Lane_B_viewRangeEnd 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_B_laneCrossing Signal laneCrossing of Message LKA_Left_Lane_B (0x502)
 *
 * Reserved. Not Implmented
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_B
 * @{
 */

/**
 * Signal laneCrossing configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_B_laneCrossing and \ref GET_LKA_Left_Lane_B_laneCrossing instead.
 */
#define SIG_LKA_Left_Lane_B_laneCrossing 0, 0, 28, 1

/**
 * Signal laneCrossing setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_B_laneCrossing or \ref INIT_LKA_Left_Lane_B instead.
 */
#define SETUP_LKA_Left_Lane_B_laneCrossing 0, 0, 28, 1, 0

/**
 * Get signal laneCrossing from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_B_laneCrossing(buf) (0 | (uint8_t)(+(uint8_t)((buf[3] >> 4) & 0x01) << 0))

/**
 * Set signal laneCrossing in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_B_laneCrossing(buf, val)                                                                     \
    {                                                                                                                  \
        buf[3] &= ~(0x01 << 4);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x01) << 4;                                                                 \
    }

/**
 * Set signal laneCrossing in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_B_laneCrossing(buf) SET_LKA_Left_Lane_B_laneCrossing(buf, 0)

/**
 * Signal laneCrossing value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_B_laneCrossing(x, fmt) ((x)*fmt)

/**
 * Signal laneCrossing raw initial value.
 */
#define START_LKA_Left_Lane_B_laneCrossing 0

/**
 * Signal laneCrossing raw minimum value.
 */
#define MIN_LKA_Left_Lane_B_laneCrossing 0

/**
 * Signal laneCrossing raw maximum value.
 */
#define MAX_LKA_Left_Lane_B_laneCrossing 1

/**
 * Signal laneCrossing raw offset value.
 */
#define OFF_LKA_Left_Lane_B_laneCrossing 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_B_laneMarkColor Signal laneMarkColor of Message LKA_Left_Lane_B (0x502)
 *
 * Lane Color
 *
 * Contains the value table \ref ENUM_LKA_Left_Lane_B_laneMarkColor.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_B
 * @{
 */

/**
 * Signal laneMarkColor configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_B_laneMarkColor and \ref GET_LKA_Left_Lane_B_laneMarkColor instead.
 */
#define SIG_LKA_Left_Lane_B_laneMarkColor 0, 0, 29, 3

/**
 * Signal laneMarkColor setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_B_laneMarkColor or \ref INIT_LKA_Left_Lane_B instead.
 */
#define SETUP_LKA_Left_Lane_B_laneMarkColor 0, 0, 29, 3, 0

/**
 * Get signal laneMarkColor from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_B_laneMarkColor(buf) (0 | (uint8_t)(+(uint8_t)((buf[3] >> 5) & 0x07) << 0))

/**
 * Set signal laneMarkColor in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_B_laneMarkColor(buf, val)                                                                    \
    {                                                                                                                  \
        buf[3] &= ~(0x07 << 5);                                                                                        \
        buf[3] |= (((uint8_t)(val) >> 0) & 0x07) << 5;                                                                 \
    }

/**
 * Set signal laneMarkColor in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_B_laneMarkColor(buf) SET_LKA_Left_Lane_B_laneMarkColor(buf, 0)

/**
 * Signal laneMarkColor value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_B_laneMarkColor(x, fmt) ((x)*fmt)

/**
 * Signal laneMarkColor raw initial value.
 */
#define START_LKA_Left_Lane_B_laneMarkColor 0

/**
 * Signal laneMarkColor raw minimum value.
 */
#define MIN_LKA_Left_Lane_B_laneMarkColor 0

/**
 * Signal laneMarkColor raw maximum value.
 */
#define MAX_LKA_Left_Lane_B_laneMarkColor 3

/**
 * Signal laneMarkColor raw offset value.
 */
#define OFF_LKA_Left_Lane_B_laneMarkColor 0

/**
 * @}
 */

/**
 * @defgroup ENUM_LKA_Left_Lane_B_laneMarkColor Value Table for Signal laneMarkColor in Message LKA_Left_Lane_B (0x502)
 *
 * Enum values defined for \ref SIG_LKA_Left_Lane_B_laneMarkColor.
 *
 * @ingroup SIG_LKA_Left_Lane_B_laneMarkColor
 */

/**
 * Value table LKA_Left_Lane_B_laneMarkColor entry invalid.
 *
 * @ingroup ENUM_LKA_Left_Lane_B_laneMarkColor
 */
#define LKA_Left_Lane_B_laneMarkColor_invalid 3

/**
 * Value table LKA_Left_Lane_B_laneMarkColor entry blue.
 *
 * @ingroup ENUM_LKA_Left_Lane_B_laneMarkColor
 */
#define LKA_Left_Lane_B_laneMarkColor_blue 2

/**
 * Value table LKA_Left_Lane_B_laneMarkColor entry yellow.
 *
 * @ingroup ENUM_LKA_Left_Lane_B_laneMarkColor
 */
#define LKA_Left_Lane_B_laneMarkColor_yellow 1

/**
 * Value table LKA_Left_Lane_B_laneMarkColor entry white.
 *
 * @ingroup ENUM_LKA_Left_Lane_B_laneMarkColor
 */
#define LKA_Left_Lane_B_laneMarkColor_white 0

/**
 * @defgroup SIG_LKA_Left_Lane_B_Reserved1_LKAlaneB Signal Reserved1_LKAlaneB of Message LKA_Left_Lane_B (0x502)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_B
 * @{
 */

/**
 * Signal Reserved1_LKAlaneB configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_B_Reserved1_LKAlaneB and \ref GET_LKA_Left_Lane_B_Reserved1_LKAlaneB instead.
 */
#define SIG_LKA_Left_Lane_B_Reserved1_LKAlaneB 0, 0, 32, 8

/**
 * Signal Reserved1_LKAlaneB setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_B_Reserved1_LKAlaneB or \ref INIT_LKA_Left_Lane_B instead.
 */
#define SETUP_LKA_Left_Lane_B_Reserved1_LKAlaneB 0, 0, 32, 8, 0

/**
 * Get signal Reserved1_LKAlaneB from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_B_Reserved1_LKAlaneB(buf) (0 | (uint8_t)(+(uint8_t)((buf[4] >> 0) & 0xff) << 0))

/**
 * Set signal Reserved1_LKAlaneB in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_B_Reserved1_LKAlaneB(buf, val)                                                               \
    {                                                                                                                  \
        buf[4] &= ~(0xff << 0);                                                                                        \
        buf[4] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
    }

/**
 * Set signal Reserved1_LKAlaneB in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_B_Reserved1_LKAlaneB(buf) SET_LKA_Left_Lane_B_Reserved1_LKAlaneB(buf, 0)

/**
 * Signal Reserved1_LKAlaneB value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_B_Reserved1_LKAlaneB(x, fmt) ((x)*fmt)

/**
 * Signal Reserved1_LKAlaneB raw initial value.
 */
#define START_LKA_Left_Lane_B_Reserved1_LKAlaneB 0

/**
 * Signal Reserved1_LKAlaneB raw minimum value.
 */
#define MIN_LKA_Left_Lane_B_Reserved1_LKAlaneB 0

/**
 * Signal Reserved1_LKAlaneB raw maximum value.
 */
#define MAX_LKA_Left_Lane_B_Reserved1_LKAlaneB 0

/**
 * Signal Reserved1_LKAlaneB raw offset value.
 */
#define OFF_LKA_Left_Lane_B_Reserved1_LKAlaneB 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_B_Reserved2_LKAlaneB Signal Reserved2_LKAlaneB of Message LKA_Left_Lane_B (0x502)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_B
 * @{
 */

/**
 * Signal Reserved2_LKAlaneB configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_B_Reserved2_LKAlaneB and \ref GET_LKA_Left_Lane_B_Reserved2_LKAlaneB instead.
 */
#define SIG_LKA_Left_Lane_B_Reserved2_LKAlaneB 0, 0, 40, 8

/**
 * Signal Reserved2_LKAlaneB setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_B_Reserved2_LKAlaneB or \ref INIT_LKA_Left_Lane_B instead.
 */
#define SETUP_LKA_Left_Lane_B_Reserved2_LKAlaneB 0, 0, 40, 8, 0

/**
 * Get signal Reserved2_LKAlaneB from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_B_Reserved2_LKAlaneB(buf) (0 | (uint8_t)(+(uint8_t)((buf[5] >> 0) & 0xff) << 0))

/**
 * Set signal Reserved2_LKAlaneB in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_B_Reserved2_LKAlaneB(buf, val)                                                               \
    {                                                                                                                  \
        buf[5] &= ~(0xff << 0);                                                                                        \
        buf[5] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
    }

/**
 * Set signal Reserved2_LKAlaneB in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_B_Reserved2_LKAlaneB(buf) SET_LKA_Left_Lane_B_Reserved2_LKAlaneB(buf, 0)

/**
 * Signal Reserved2_LKAlaneB value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_B_Reserved2_LKAlaneB(x, fmt) ((x)*fmt)

/**
 * Signal Reserved2_LKAlaneB raw initial value.
 */
#define START_LKA_Left_Lane_B_Reserved2_LKAlaneB 0

/**
 * Signal Reserved2_LKAlaneB raw minimum value.
 */
#define MIN_LKA_Left_Lane_B_Reserved2_LKAlaneB 0

/**
 * Signal Reserved2_LKAlaneB raw maximum value.
 */
#define MAX_LKA_Left_Lane_B_Reserved2_LKAlaneB 0

/**
 * Signal Reserved2_LKAlaneB raw offset value.
 */
#define OFF_LKA_Left_Lane_B_Reserved2_LKAlaneB 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_B_Reserved3_LKAlaneB Signal Reserved3_LKAlaneB of Message LKA_Left_Lane_B (0x502)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_B
 * @{
 */

/**
 * Signal Reserved3_LKAlaneB configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_B_Reserved3_LKAlaneB and \ref GET_LKA_Left_Lane_B_Reserved3_LKAlaneB instead.
 */
#define SIG_LKA_Left_Lane_B_Reserved3_LKAlaneB 0, 0, 48, 8

/**
 * Signal Reserved3_LKAlaneB setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_B_Reserved3_LKAlaneB or \ref INIT_LKA_Left_Lane_B instead.
 */
#define SETUP_LKA_Left_Lane_B_Reserved3_LKAlaneB 0, 0, 48, 8, 0

/**
 * Get signal Reserved3_LKAlaneB from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_B_Reserved3_LKAlaneB(buf) (0 | (uint8_t)(+(uint8_t)((buf[6] >> 0) & 0xff) << 0))

/**
 * Set signal Reserved3_LKAlaneB in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_B_Reserved3_LKAlaneB(buf, val)                                                               \
    {                                                                                                                  \
        buf[6] &= ~(0xff << 0);                                                                                        \
        buf[6] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
    }

/**
 * Set signal Reserved3_LKAlaneB in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_B_Reserved3_LKAlaneB(buf) SET_LKA_Left_Lane_B_Reserved3_LKAlaneB(buf, 0)

/**
 * Signal Reserved3_LKAlaneB value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_B_Reserved3_LKAlaneB(x, fmt) ((x)*fmt)

/**
 * Signal Reserved3_LKAlaneB raw initial value.
 */
#define START_LKA_Left_Lane_B_Reserved3_LKAlaneB 0

/**
 * Signal Reserved3_LKAlaneB raw minimum value.
 */
#define MIN_LKA_Left_Lane_B_Reserved3_LKAlaneB 0

/**
 * Signal Reserved3_LKAlaneB raw maximum value.
 */
#define MAX_LKA_Left_Lane_B_Reserved3_LKAlaneB 0

/**
 * Signal Reserved3_LKAlaneB raw offset value.
 */
#define OFF_LKA_Left_Lane_B_Reserved3_LKAlaneB 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_B_ttlc Signal ttlc of Message LKA_Left_Lane_B (0x502)
 *
 * LDW,LKA ttlc
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_B
 * @{
 */

/**
 * Signal ttlc configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_B_ttlc and \ref GET_LKA_Left_Lane_B_ttlc instead.
 */
#define SIG_LKA_Left_Lane_B_ttlc 0, 0, 56, 8

/**
 * Signal ttlc setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_B_ttlc or \ref INIT_LKA_Left_Lane_B instead.
 */
#define SETUP_LKA_Left_Lane_B_ttlc 0, 0, 56, 8, 0

/**
 * Get signal ttlc from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_B_ttlc(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 0) & 0xff) << 0))

/**
 * Set signal ttlc in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_B_ttlc(buf, val)                                                                             \
    {                                                                                                                  \
        buf[7] &= ~(0xff << 0);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0xff) << 0;                                                                 \
    }

/**
 * Set signal ttlc in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_B_ttlc(buf) SET_LKA_Left_Lane_B_ttlc(buf, 0)

/**
 * Signal ttlc value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_B_ttlc(x, fmt) ((x)*fmt / 100)

/**
 * Signal ttlc raw initial value.
 */
#define START_LKA_Left_Lane_B_ttlc 0

/**
 * Signal ttlc raw minimum value.
 */
#define MIN_LKA_Left_Lane_B_ttlc 0

/**
 * Signal ttlc raw maximum value.
 */
#define MAX_LKA_Left_Lane_B_ttlc 200

/**
 * Signal ttlc raw offset value.
 */
#define OFF_LKA_Left_Lane_B_ttlc 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_A_laneType Signal laneType of Message LKA_Left_Lane_A (0x501)
 *
 * Lane Type
 *
 * Contains the value table \ref ENUM_LKA_Left_Lane_A_laneType.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_A
 * @{
 */

/**
 * Signal laneType configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_A_laneType and \ref GET_LKA_Left_Lane_A_laneType instead.
 */
#define SIG_LKA_Left_Lane_A_laneType 0, 0, 0, 4

/**
 * Signal laneType setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_A_laneType or \ref INIT_LKA_Left_Lane_A instead.
 */
#define SETUP_LKA_Left_Lane_A_laneType 0, 0, 0, 4, 0

/**
 * Get signal laneType from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_A_laneType(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 0) & 0x0f) << 0))

/**
 * Set signal laneType in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_A_laneType(buf, val)                                                                         \
    {                                                                                                                  \
        buf[0] &= ~(0x0f << 0);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x0f) << 0;                                                                 \
    }

/**
 * Set signal laneType in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_A_laneType(buf) SET_LKA_Left_Lane_A_laneType(buf, 0)

/**
 * Signal laneType value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_A_laneType(x, fmt) ((x)*fmt)

/**
 * Signal laneType raw initial value.
 */
#define START_LKA_Left_Lane_A_laneType 0

/**
 * Signal laneType raw minimum value.
 */
#define MIN_LKA_Left_Lane_A_laneType 0

/**
 * Signal laneType raw maximum value.
 */
#define MAX_LKA_Left_Lane_A_laneType 15

/**
 * Signal laneType raw offset value.
 */
#define OFF_LKA_Left_Lane_A_laneType 0

/**
 * @}
 */

/**
 * @defgroup ENUM_LKA_Left_Lane_A_laneType Value Table for Signal laneType in Message LKA_Left_Lane_A (0x501)
 *
 * Enum values defined for \ref SIG_LKA_Left_Lane_A_laneType.
 *
 * @ingroup SIG_LKA_Left_Lane_A_laneType
 */

/**
 * Value table LKA_Left_Lane_A_laneType entry Invalid.
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Invalid 15

/**
 * Value table LKA_Left_Lane_A_laneType entry Barrier.
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Barrier 8

/**
 * Value table LKA_Left_Lane_A_laneType entry Double.
 *
 * Lane(Double Solid)
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Double 7

/**
 * Value table LKA_Left_Lane_A_laneType entry Double_6.
 *
 * Lane(Double Dashed)
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Double_6 6

/**
 * Value table LKA_Left_Lane_A_laneType entry Double_5.
 *
 * Lane(Left Solid, Right Dashed)
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Double_5 5

/**
 * Value table LKA_Left_Lane_A_laneType entry Double_4.
 *
 * Lane(Left Dashed, Right Solid)
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Double_4 4

/**
 * Value table LKA_Left_Lane_A_laneType entry Dashed.
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Dashed 3

/**
 * Value table LKA_Left_Lane_A_laneType entry Road.
 *
 * Edge
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Road 2

/**
 * Value table LKA_Left_Lane_A_laneType entry Solid.
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Solid 1

/**
 * Value table LKA_Left_Lane_A_laneType entry Undecided.
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneType
 */
#define LKA_Left_Lane_A_laneType_Undecided 0

/**
 * @defgroup SIG_LKA_Left_Lane_A_laneQuality Signal laneQuality of Message LKA_Left_Lane_A (0x501)
 *
 * Reserved Not Implemented
 *
 * Contains the value table \ref ENUM_LKA_Left_Lane_A_laneQuality.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_A
 * @{
 */

/**
 * Signal laneQuality configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_A_laneQuality and \ref GET_LKA_Left_Lane_A_laneQuality instead.
 */
#define SIG_LKA_Left_Lane_A_laneQuality 0, 0, 4, 2

/**
 * Signal laneQuality setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_A_laneQuality or \ref INIT_LKA_Left_Lane_A instead.
 */
#define SETUP_LKA_Left_Lane_A_laneQuality 0, 0, 4, 2, 0

/**
 * Get signal laneQuality from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_A_laneQuality(buf) (0 | (uint8_t)(+(uint8_t)((buf[0] >> 4) & 0x03) << 0))

/**
 * Set signal laneQuality in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_A_laneQuality(buf, val)                                                                      \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 4);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 4;                                                                 \
    }

/**
 * Set signal laneQuality in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_A_laneQuality(buf) SET_LKA_Left_Lane_A_laneQuality(buf, 0)

/**
 * Signal laneQuality value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_A_laneQuality(x, fmt) ((x)*fmt)

/**
 * Signal laneQuality raw initial value.
 */
#define START_LKA_Left_Lane_A_laneQuality 0

/**
 * Signal laneQuality raw minimum value.
 */
#define MIN_LKA_Left_Lane_A_laneQuality 0

/**
 * Signal laneQuality raw maximum value.
 */
#define MAX_LKA_Left_Lane_A_laneQuality 3

/**
 * Signal laneQuality raw offset value.
 */
#define OFF_LKA_Left_Lane_A_laneQuality 0

/**
 * @}
 */

/**
 * @defgroup ENUM_LKA_Left_Lane_A_laneQuality Value Table for Signal laneQuality in Message LKA_Left_Lane_A (0x501)
 *
 * Enum values defined for \ref SIG_LKA_Left_Lane_A_laneQuality.
 *
 * @ingroup SIG_LKA_Left_Lane_A_laneQuality
 */

/**
 * Value table LKA_Left_Lane_A_laneQuality entry Very.
 *
 * High quality
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneQuality
 */
#define LKA_Left_Lane_A_laneQuality_Very 3

/**
 * Value table LKA_Left_Lane_A_laneQuality entry High.
 *
 * quality
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneQuality
 */
#define LKA_Left_Lane_A_laneQuality_High 2

/**
 * Value table LKA_Left_Lane_A_laneQuality entry Low.
 *
 * quality
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneQuality
 */
#define LKA_Left_Lane_A_laneQuality_Low 1

/**
 * Value table LKA_Left_Lane_A_laneQuality entry Undecided.
 *
 * @ingroup ENUM_LKA_Left_Lane_A_laneQuality
 */
#define LKA_Left_Lane_A_laneQuality_Undecided 0

/**
 * @defgroup SIG_LKA_Left_Lane_A_laneModelC0 Signal laneModelC0 of Message LKA_Left_Lane_A (0x501)
 *
 * C0 coefficient which is Lane_Position. Positive to the left.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_A
 * @{
 */

/**
 * Signal laneModelC0 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_A_laneModelC0 and \ref GET_LKA_Left_Lane_A_laneModelC0 instead.
 */
#define SIG_LKA_Left_Lane_A_laneModelC0 0, 1, 6, 11

/**
 * Signal laneModelC0 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_A_laneModelC0 or \ref INIT_LKA_Left_Lane_A instead.
 */
#define SETUP_LKA_Left_Lane_A_laneModelC0 0, 1, 6, 11, 0

/**
 * Get signal laneModelC0 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_A_laneModelC0(buf)                                                                           \
    (0 | (uint16_t)(-(uint16_t)((buf[2] >> 0) & 0x01) << 11) | (uint8_t)(+(uint8_t)((buf[0] >> 6) & 0x03) << 0) |      \
     (uint16_t)(+(uint16_t)((buf[1] >> 0) & 0xff) << 2) | (uint16_t)(+(uint16_t)((buf[2] >> 0) & 0x01) << 10))

/**
 * Set signal laneModelC0 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_A_laneModelC0(buf, val)                                                                      \
    {                                                                                                                  \
        buf[0] &= ~(0x03 << 6);                                                                                        \
        buf[0] |= (((uint8_t)(val) >> 0) & 0x03) << 6;                                                                 \
        buf[1] &= ~(0xff << 0);                                                                                        \
        buf[1] |= ((uint8_t)((uint16_t)(val) >> 2) & 0xff) << 0;                                                       \
        buf[2] &= ~(0x01 << 0);                                                                                        \
        buf[2] |= ((uint8_t)((uint16_t)(val) >> 10) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC0 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_A_laneModelC0(buf) SET_LKA_Left_Lane_A_laneModelC0(buf, 0)

/**
 * Signal laneModelC0 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_A_laneModelC0(x, fmt) ((x)*fmt / 100)

/**
 * Signal laneModelC0 raw initial value.
 */
#define START_LKA_Left_Lane_A_laneModelC0 0

/**
 * Signal laneModelC0 raw minimum value.
 */
#define MIN_LKA_Left_Lane_A_laneModelC0 -1000

/**
 * Signal laneModelC0 raw maximum value.
 */
#define MAX_LKA_Left_Lane_A_laneModelC0 1000

/**
 * Signal laneModelC0 raw offset value.
 */
#define OFF_LKA_Left_Lane_A_laneModelC0 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_A_laneModelC2 Signal laneModelC2 of Message LKA_Left_Lane_A (0x501)
 *
 * C2 coefficient which Lane Curvature can be calculated from. Positive if curved to left.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_A
 * @{
 */

/**
 * Signal laneModelC2 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_A_laneModelC2 and \ref GET_LKA_Left_Lane_A_laneModelC2 instead.
 */
#define SIG_LKA_Left_Lane_A_laneModelC2 0, 1, 17, 16

/**
 * Signal laneModelC2 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_A_laneModelC2 or \ref INIT_LKA_Left_Lane_A instead.
 */
#define SETUP_LKA_Left_Lane_A_laneModelC2 0, 1, 17, 16, 0

/**
 * Get signal laneModelC2 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_A_laneModelC2(buf)                                                                           \
    (0 | (uint8_t)(+(uint8_t)((buf[2] >> 1) & 0x7f) << 0) | (uint16_t)(+(uint16_t)((buf[3] >> 0) & 0xff) << 7) |       \
     (uint16_t)(+(uint16_t)((buf[4] >> 0) & 0x01) << 15))

/**
 * Set signal laneModelC2 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_A_laneModelC2(buf, val)                                                                      \
    {                                                                                                                  \
        buf[2] &= ~(0x7f << 1);                                                                                        \
        buf[2] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[3] &= ~(0xff << 0);                                                                                        \
        buf[3] |= ((uint8_t)((uint16_t)(val) >> 7) & 0xff) << 0;                                                       \
        buf[4] &= ~(0x01 << 0);                                                                                        \
        buf[4] |= ((uint8_t)((uint16_t)(val) >> 15) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC2 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_A_laneModelC2(buf) SET_LKA_Left_Lane_A_laneModelC2(buf, 0)

/**
 * Signal laneModelC2 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_A_laneModelC2(x, fmt) ((x)*fmt * 500 / 511770726)

/**
 * Signal laneModelC2 raw initial value.
 */
#define START_LKA_Left_Lane_A_laneModelC2 0

/**
 * Signal laneModelC2 raw minimum value.
 */
#define MIN_LKA_Left_Lane_A_laneModelC2 -32753

/**
 * Signal laneModelC2 raw maximum value.
 */
#define MAX_LKA_Left_Lane_A_laneModelC2 32753

/**
 * Signal laneModelC2 raw offset value.
 */
#define OFF_LKA_Left_Lane_A_laneModelC2 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_A_laneModelC3 Signal laneModelC3 of Message LKA_Left_Lane_A (0x501)
 *
 * C3 coefficient which Lane Curvature Derivative can be calculated from. Sign is According to Curvature.
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_A
 * @{
 */

/**
 * Signal laneModelC3 configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_A_laneModelC3 and \ref GET_LKA_Left_Lane_A_laneModelC3 instead.
 */
#define SIG_LKA_Left_Lane_A_laneModelC3 0, 1, 33, 16

/**
 * Signal laneModelC3 setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_A_laneModelC3 or \ref INIT_LKA_Left_Lane_A instead.
 */
#define SETUP_LKA_Left_Lane_A_laneModelC3 0, 1, 33, 16, 0

/**
 * Get signal laneModelC3 from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_A_laneModelC3(buf)                                                                           \
    (0 | (uint8_t)(+(uint8_t)((buf[4] >> 1) & 0x7f) << 0) | (uint16_t)(+(uint16_t)((buf[5] >> 0) & 0xff) << 7) |       \
     (uint16_t)(+(uint16_t)((buf[6] >> 0) & 0x01) << 15))

/**
 * Set signal laneModelC3 in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_A_laneModelC3(buf, val)                                                                      \
    {                                                                                                                  \
        buf[4] &= ~(0x7f << 1);                                                                                        \
        buf[4] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[5] &= ~(0xff << 0);                                                                                        \
        buf[5] |= ((uint8_t)((uint16_t)(val) >> 7) & 0xff) << 0;                                                       \
        buf[6] &= ~(0x01 << 0);                                                                                        \
        buf[6] |= ((uint8_t)((uint16_t)(val) >> 15) & 0x01) << 0;                                                      \
    }

/**
 * Set signal laneModelC3 in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_A_laneModelC3(buf) SET_LKA_Left_Lane_A_laneModelC3(buf, 0)

/**
 * Signal laneModelC3 value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_A_laneModelC3(x, fmt) ((x)*fmt / 268435456)

/**
 * Signal laneModelC3 raw initial value.
 */
#define START_LKA_Left_Lane_A_laneModelC3 0

/**
 * Signal laneModelC3 raw minimum value.
 */
#define MIN_LKA_Left_Lane_A_laneModelC3 -32749

/**
 * Signal laneModelC3 raw maximum value.
 */
#define MAX_LKA_Left_Lane_A_laneModelC3 32749

/**
 * Signal laneModelC3 raw offset value.
 */
#define OFF_LKA_Left_Lane_A_laneModelC3 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_A_laneWidthMarking Signal laneWidthMarking of Message LKA_Left_Lane_A (0x501)
 *
 * Lane width
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_A
 * @{
 */

/**
 * Signal laneWidthMarking configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_A_laneWidthMarking and \ref GET_LKA_Left_Lane_A_laneWidthMarking instead.
 */
#define SIG_LKA_Left_Lane_A_laneWidthMarking 0, 0, 49, 8

/**
 * Signal laneWidthMarking setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_A_laneWidthMarking or \ref INIT_LKA_Left_Lane_A instead.
 */
#define SETUP_LKA_Left_Lane_A_laneWidthMarking 0, 0, 49, 8, 0

/**
 * Get signal laneWidthMarking from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_A_laneWidthMarking(buf)                                                                      \
    (0 | (uint8_t)(+(uint8_t)((buf[6] >> 1) & 0x7f) << 0) | (uint8_t)(+(uint8_t)((buf[7] >> 0) & 0x01) << 7))

/**
 * Set signal laneWidthMarking in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_A_laneWidthMarking(buf, val)                                                                 \
    {                                                                                                                  \
        buf[6] &= ~(0x7f << 1);                                                                                        \
        buf[6] |= (((uint8_t)(val) >> 0) & 0x7f) << 1;                                                                 \
        buf[7] &= ~(0x01 << 0);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 7) & 0x01) << 0;                                                                 \
    }

/**
 * Set signal laneWidthMarking in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_A_laneWidthMarking(buf) SET_LKA_Left_Lane_A_laneWidthMarking(buf, 0)

/**
 * Signal laneWidthMarking value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_A_laneWidthMarking(x, fmt) ((x)*fmt / 100)

/**
 * Signal laneWidthMarking raw initial value.
 */
#define START_LKA_Left_Lane_A_laneWidthMarking 0

/**
 * Signal laneWidthMarking raw minimum value.
 */
#define MIN_LKA_Left_Lane_A_laneWidthMarking 0

/**
 * Signal laneWidthMarking raw maximum value.
 */
#define MAX_LKA_Left_Lane_A_laneWidthMarking 250

/**
 * Signal laneWidthMarking raw offset value.
 */
#define OFF_LKA_Left_Lane_A_laneWidthMarking 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_A_laneConfidence Signal laneConfidence of Message LKA_Left_Lane_A (0x501)
 *
 * Lane Confidence
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_A
 * @{
 */

/**
 * Signal laneConfidence configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_A_laneConfidence and \ref GET_LKA_Left_Lane_A_laneConfidence instead.
 */
#define SIG_LKA_Left_Lane_A_laneConfidence 0, 0, 57, 4

/**
 * Signal laneConfidence setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_A_laneConfidence or \ref INIT_LKA_Left_Lane_A instead.
 */
#define SETUP_LKA_Left_Lane_A_laneConfidence 0, 0, 57, 4, 0

/**
 * Get signal laneConfidence from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_A_laneConfidence(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 1) & 0x0f) << 0))

/**
 * Set signal laneConfidence in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_A_laneConfidence(buf, val)                                                                   \
    {                                                                                                                  \
        buf[7] &= ~(0x0f << 1);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0x0f) << 1;                                                                 \
    }

/**
 * Set signal laneConfidence in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_A_laneConfidence(buf) SET_LKA_Left_Lane_A_laneConfidence(buf, 0)

/**
 * Signal laneConfidence value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_A_laneConfidence(x, fmt) ((x)*fmt / 10)

/**
 * Signal laneConfidence raw initial value.
 */
#define START_LKA_Left_Lane_A_laneConfidence 0

/**
 * Signal laneConfidence raw minimum value.
 */
#define MIN_LKA_Left_Lane_A_laneConfidence 0

/**
 * Signal laneConfidence raw maximum value.
 */
#define MAX_LKA_Left_Lane_A_laneConfidence 10

/**
 * Signal laneConfidence raw offset value.
 */
#define OFF_LKA_Left_Lane_A_laneConfidence 0

/**
 * @}
 */

/**
 * @defgroup SIG_LKA_Left_Lane_A_Reserved1_LKAlaneA Signal Reserved1_LKAlaneA of Message LKA_Left_Lane_A (0x501)
 *
 * Received by the ECUs:
 * - \ref ECU_Matrix
 *
 * @ingroup MSG_LKA_Left_Lane_A
 * @{
 */

/**
 * Signal Reserved1_LKAlaneA configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_LKA_Left_Lane_A_Reserved1_LKAlaneA and \ref GET_LKA_Left_Lane_A_Reserved1_LKAlaneA instead.
 */
#define SIG_LKA_Left_Lane_A_Reserved1_LKAlaneA 0, 0, 61, 3

/**
 * Signal Reserved1_LKAlaneA setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_LKA_Left_Lane_A_Reserved1_LKAlaneA or \ref INIT_LKA_Left_Lane_A instead.
 */
#define SETUP_LKA_Left_Lane_A_Reserved1_LKAlaneA 0, 0, 61, 3, 0

/**
 * Get signal Reserved1_LKAlaneA from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_LKA_Left_Lane_A_Reserved1_LKAlaneA(buf) (0 | (uint8_t)(+(uint8_t)((buf[7] >> 5) & 0x07) << 0))

/**
 * Set signal Reserved1_LKAlaneA in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_LKA_Left_Lane_A_Reserved1_LKAlaneA(buf, val)                                                               \
    {                                                                                                                  \
        buf[7] &= ~(0x07 << 5);                                                                                        \
        buf[7] |= (((uint8_t)(val) >> 0) & 0x07) << 5;                                                                 \
    }

/**
 * Set signal Reserved1_LKAlaneA in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_LKA_Left_Lane_A_Reserved1_LKAlaneA(buf) SET_LKA_Left_Lane_A_Reserved1_LKAlaneA(buf, 0)

/**
 * Signal Reserved1_LKAlaneA value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_LKA_Left_Lane_A_Reserved1_LKAlaneA(x, fmt) ((x)*fmt)

/**
 * Signal Reserved1_LKAlaneA raw initial value.
 */
#define START_LKA_Left_Lane_A_Reserved1_LKAlaneA 0

/**
 * Signal Reserved1_LKAlaneA raw minimum value.
 */
#define MIN_LKA_Left_Lane_A_Reserved1_LKAlaneA 0

/**
 * Signal Reserved1_LKAlaneA raw maximum value.
 */
#define MAX_LKA_Left_Lane_A_Reserved1_LKAlaneA 0

/**
 * Signal Reserved1_LKAlaneA raw offset value.
 */
#define OFF_LKA_Left_Lane_A_Reserved1_LKAlaneA 0

/**
 * @}
 */

#endif
