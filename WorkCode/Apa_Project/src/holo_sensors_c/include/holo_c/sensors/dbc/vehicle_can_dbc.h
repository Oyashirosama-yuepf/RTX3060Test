/** \file
 * CAN DBC C-Headers
 *
 * These headers were generated by dbc2c.awk on 2017年 10月 17日 星期二 10:43:19 CST.
 *
 * The dbc2c.awk script parses Vector .dbc files, and generates C-style
 * headers with Doxygen documentation from a set of templates.
 *
 * The following databases were parsed:
 * - \ref DB_holo
 */

/**
 * @defgroup DB_holo CAN Database holo
 *
 * Path to file: output/holo.dbc
 *
 * Provides the following ECUs:
 */

/**
 * @defgroup MSG_emergency_brake_control Message emergency_brake_control (0x305)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_emergency_brake_control_emergency_brake_enable
 * - \ref SIG_emergency_brake_control_emergency_brake_value
 *
 * @{
 */

typedef unsigned char ubyte;
typedef unsigned int uword;

/**
 * Message emergency_brake_control configuration tuple.
 */
#define MSG_emergency_brake_control                 0x305, 0, 8

/**
 * Message emergency_brake_control id.
 */
#define ID_emergency_brake_control                  0x305

/**
 * Message emergency_brake_control extended id bit.
 */
#define EXT_emergency_brake_control                 0

/**
 * Message emergency_brake_control Data Length Count.
 */
#define DLC_emergency_brake_control                 8

/**
 * Message emergency_brake_control cycle time.
 */
#define CYCLE_emergency_brake_control               0

/**
 * Message emergency_brake_control fast cycle time.
 */
#define FAST_emergency_brake_control                0

/**
 * Initialise message emergency_brake_control buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_emergency_brake_control(buf) { \
	INITSIG_emergency_brake_control_emergency_brake_enable(buf); \
	INITSIG_emergency_brake_control_emergency_brake_value(buf); \
}

/**
 * @defgroup MSG_epb_status Message epb_status (0x403)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_epb_status_epb_status
 *
 * @{
 */

/**
 * Message epb_status configuration tuple.
 */
#define MSG_epb_status                              0x403, 0, 8

/**
 * Message epb_status id.
 */
#define ID_epb_status                               0x403

/**
 * Message epb_status extended id bit.
 */
#define EXT_epb_status                              0

/**
 * Message epb_status Data Length Count.
 */
#define DLC_epb_status                              8

/**
 * Message epb_status cycle time.
 */
#define CYCLE_epb_status                            0

/**
 * Message epb_status fast cycle time.
 */
#define FAST_epb_status                             0

/**
 * Initialise message epb_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_epb_status(buf) { \
	INITSIG_epb_status_epb_status(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_gear_status Message gear_status (0x404)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_gear_status_actual_gear
 *
 * @{
 */

/**
 * Message gear_status configuration tuple.
 */
#define MSG_gear_status                             0x404, 0, 8

/**
 * Message gear_status id.
 */
#define ID_gear_status                              0x404

/**
 * Message gear_status extended id bit.
 */
#define EXT_gear_status                             0

/**
 * Message gear_status Data Length Count.
 */
#define DLC_gear_status                             8

/**
 * Message gear_status cycle time.
 */
#define CYCLE_gear_status                           0

/**
 * Message gear_status fast cycle time.
 */
#define FAST_gear_status                            0

/**
 * Initialise message gear_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_gear_status(buf) { \
	INITSIG_gear_status_actual_gear(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_light_control Message light_control (0x304)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_light_control_warning_blinker
 * - \ref SIG_light_control_right_turn
 * - \ref SIG_light_control_left_turn
 * - \ref SIG_light_control_enable
 *
 * @{
 */

/**
 * Message light_control configuration tuple.
 */
#define MSG_light_control                           0x304, 0, 8

/**
 * Message light_control id.
 */
#define ID_light_control                            0x304

/**
 * Message light_control extended id bit.
 */
#define EXT_light_control                           0

/**
 * Message light_control Data Length Count.
 */
#define DLC_light_control                           8

/**
 * Message light_control cycle time.
 */
#define CYCLE_light_control                         0

/**
 * Message light_control fast cycle time.
 */
#define FAST_light_control                          0

/**
 * Initialise message light_control buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_light_control(buf) { \
	INITSIG_light_control_warning_blinker(buf); \
	INITSIG_light_control_right_turn(buf); \
	INITSIG_light_control_left_turn(buf); \
	INITSIG_light_control_enable(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_gear_control Message gear_control (0x303)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_gear_control_position
 * - \ref SIG_gear_control_enable
 *
 * @{
 */

/**
 * Message gear_control configuration tuple.
 */
#define MSG_gear_control                            0x303, 0, 8

/**
 * Message gear_control id.
 */
#define ID_gear_control                             0x303

/**
 * Message gear_control extended id bit.
 */
#define EXT_gear_control                            0

/**
 * Message gear_control Data Length Count.
 */
#define DLC_gear_control                            8

/**
 * Message gear_control cycle time.
 */
#define CYCLE_gear_control                          0

/**
 * Message gear_control fast cycle time.
 */
#define FAST_gear_control                           0

/**
 * Initialise message gear_control buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_gear_control(buf) { \
	INITSIG_gear_control_position(buf); \
	INITSIG_gear_control_enable(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_longtudinal_command Message longtudinal_command (0x300)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_longtudinal_command_acceleration_value
 * - \ref SIG_longtudinal_command_enable
 *
 * @{
 */

/**
 * Message longtudinal_command configuration tuple.
 */
#define MSG_longtudinal_command                     0x300, 0, 8

/**
 * Message longtudinal_command id.
 */
#define ID_longtudinal_command                      0x300

/**
 * Message longtudinal_command extended id bit.
 */
#define EXT_longtudinal_command                     0

/**
 * Message longtudinal_command Data Length Count.
 */
#define DLC_longtudinal_command                     8

/**
 * Message longtudinal_command cycle time.
 */
#define CYCLE_longtudinal_command                   0

/**
 * Message longtudinal_command fast cycle time.
 */
#define FAST_longtudinal_command                    0

/**
 * Initialise message longtudinal_command buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_longtudinal_command(buf) { \
	INITSIG_longtudinal_command_acceleration_value(buf); \
	INITSIG_longtudinal_command_enable(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_light_status Message light_status (0x400)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_light_status_WarningBlinker
 * - \ref SIG_light_status_Turnleft
 * - \ref SIG_light_status_TurnRight
 *
 * @{
 */

/**
 * Message light_status configuration tuple.
 */
#define MSG_light_status                            0x400, 0, 8

/**
 * Message light_status id.
 */
#define ID_light_status                             0x400

/**
 * Message light_status extended id bit.
 */
#define EXT_light_status                            0

/**
 * Message light_status Data Length Count.
 */
#define DLC_light_status                            8

/**
 * Message light_status cycle time.
 */
#define CYCLE_light_status                          0

/**
 * Message light_status fast cycle time.
 */
#define FAST_light_status                           0

/**
 * Initialise message light_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_light_status(buf) { \
	INITSIG_light_status_WarningBlinker(buf); \
	INITSIG_light_status_Turnleft(buf); \
	INITSIG_light_status_TurnRight(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_yawrate_status Message yawrate_status (0x40c)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_yawrate_status_lateral_acc
 * - \ref SIG_yawrate_status_longitude_acc
 * - \ref SIG_yawrate_status_yawrate
 * - \ref SIG_yawrate_status_yawrate_direction
 *
 * @{
 */

/**
 * Message yawrate_status configuration tuple.
 */
#define MSG_yawrate_status                          0x40c, 0, 7

/**
 * Message yawrate_status id.
 */
#define ID_yawrate_status                           0x40c

/**
 * Message yawrate_status extended id bit.
 */
#define EXT_yawrate_status                          0

/**
 * Message yawrate_status Data Length Count.
 */
#define DLC_yawrate_status                          7

/**
 * Message yawrate_status cycle time.
 */
#define CYCLE_yawrate_status                        0

/**
 * Message yawrate_status fast cycle time.
 */
#define FAST_yawrate_status                         0

/**
 * Initialise message yawrate_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_yawrate_status(buf) { \
	INITSIG_yawrate_status_lateral_acc(buf); \
	INITSIG_yawrate_status_longitude_acc(buf); \
	INITSIG_yawrate_status_yawrate(buf); \
	INITSIG_yawrate_status_yawrate_direction(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_brake_status Message brake_status (0x401)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_brake_status_brake_torque
 * - \ref SIG_brake_status_brake_status
 * - \ref SIG_brake_status_brake_pressure_status
 *
 * @{
 */

/**
 * Message brake_status configuration tuple.
 */
#define MSG_brake_status                            0x401, 0, 8

/**
 * Message brake_status id.
 */
#define ID_brake_status                             0x401

/**
 * Message brake_status extended id bit.
 */
#define EXT_brake_status                            0

/**
 * Message brake_status Data Length Count.
 */
#define DLC_brake_status                            8

/**
 * Message brake_status cycle time.
 */
#define CYCLE_brake_status                          0

/**
 * Message brake_status fast cycle time.
 */
#define FAST_brake_status                           0

/**
 * Initialise message brake_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_brake_status(buf) { \
	INITSIG_brake_status_brake_torque(buf); \
	INITSIG_brake_status_brake_status(buf); \
	INITSIG_brake_status_brake_pressure_status(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_wheel_speed_status Message wheel_speed_status (0x40b)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_wheel_speed_status_rl_wheelspeed
 * - \ref SIG_wheel_speed_status_rr_wheelspeed
 * - \ref SIG_wheel_speed_status_fl_wheelspeed
 * - \ref SIG_wheel_speed_status_fr_wheelspeed
 *
 * @{
 */

/**
 * Message wheel_speed_status configuration tuple.
 */
#define MSG_wheel_speed_status                      0x40b, 0, 8

/**
 * Message wheel_speed_status id.
 */
#define ID_wheel_speed_status                       0x40b

/**
 * Message wheel_speed_status extended id bit.
 */
#define EXT_wheel_speed_status                      0

/**
 * Message wheel_speed_status Data Length Count.
 */
#define DLC_wheel_speed_status                      8

/**
 * Message wheel_speed_status cycle time.
 */
#define CYCLE_wheel_speed_status                    0

/**
 * Message wheel_speed_status fast cycle time.
 */
#define FAST_wheel_speed_status                     0

/**
 * Initialise message wheel_speed_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_wheel_speed_status(buf) { \
	INITSIG_wheel_speed_status_rl_wheelspeed(buf); \
	INITSIG_wheel_speed_status_rr_wheelspeed(buf); \
	INITSIG_wheel_speed_status_fl_wheelspeed(buf); \
	INITSIG_wheel_speed_status_fr_wheelspeed(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_vehicle_speed_status Message vehicle_speed_status (0x40a)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_vehicle_speed_status_real_vehiclespeed
 *
 * @{
 */

/**
 * Message vehicle_speed_status configuration tuple.
 */
#define MSG_vehicle_speed_status                    0x40a, 0, 8

/**
 * Message vehicle_speed_status id.
 */
#define ID_vehicle_speed_status                     0x40a

/**
 * Message vehicle_speed_status extended id bit.
 */
#define EXT_vehicle_speed_status                    0

/**
 * Message vehicle_speed_status Data Length Count.
 */
#define DLC_vehicle_speed_status                    8

/**
 * Message vehicle_speed_status cycle time.
 */
#define CYCLE_vehicle_speed_status                  0

/**
 * Message vehicle_speed_status fast cycle time.
 */
#define FAST_vehicle_speed_status                   0

/**
 * Initialise message vehicle_speed_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_vehicle_speed_status(buf) { \
	INITSIG_vehicle_speed_status_real_vehiclespeed(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_door_status Message door_status (0x402)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_door_status_rear_left
 * - \ref SIG_door_status_rear_right
 * - \ref SIG_door_status_front_right
 * - \ref SIG_door_status_front_left
 *
 * @{
 */

/**
 * Message door_status configuration tuple.
 */
#define MSG_door_status                             0x402, 0, 8

/**
 * Message door_status id.
 */
#define ID_door_status                              0x402

/**
 * Message door_status extended id bit.
 */
#define EXT_door_status                             0

/**
 * Message door_status Data Length Count.
 */
#define DLC_door_status                             8

/**
 * Message door_status cycle time.
 */
#define CYCLE_door_status                           0

/**
 * Message door_status fast cycle time.
 */
#define FAST_door_status                            0

/**
 * Initialise message door_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_door_status(buf) { \
	INITSIG_door_status_rear_left(buf); \
	INITSIG_door_status_rear_right(buf); \
	INITSIG_door_status_front_right(buf); \
	INITSIG_door_status_front_left(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_lateral_angle_status Message lateral_angle_status (0x407)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_lateral_angle_status_angle_status
 *
 * @{
 */

/**
 * Message lateral_angle_status configuration tuple.
 */
#define MSG_lateral_angle_status                    0x407, 0, 8

/**
 * Message lateral_angle_status id.
 */
#define ID_lateral_angle_status                     0x407

/**
 * Message lateral_angle_status extended id bit.
 */
#define EXT_lateral_angle_status                    0

/**
 * Message lateral_angle_status Data Length Count.
 */
#define DLC_lateral_angle_status                    8

/**
 * Message lateral_angle_status cycle time.
 */
#define CYCLE_lateral_angle_status                  0

/**
 * Message lateral_angle_status fast cycle time.
 */
#define FAST_lateral_angle_status                   0

/**
 * Initialise message lateral_angle_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_lateral_angle_status(buf) { \
	INITSIG_lateral_angle_status_angle_status(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_lateral_control_angle Message lateral_control_angle (0x301)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_lateral_control_angle_angle_value
 * - \ref SIG_lateral_control_angle_direction
 * - \ref SIG_lateral_control_angle_enable
 *
 * @{
 */

/**
 * Message lateral_control_angle configuration tuple.
 */
#define MSG_lateral_control_angle                   0x301, 0, 8

/**
 * Message lateral_control_angle id.
 */
#define ID_lateral_control_angle                    0x301

/**
 * Message lateral_control_angle extended id bit.
 */
#define EXT_lateral_control_angle                   0

/**
 * Message lateral_control_angle Data Length Count.
 */
#define DLC_lateral_control_angle                   8

/**
 * Message lateral_control_angle cycle time.
 */
#define CYCLE_lateral_control_angle                 0

/**
 * Message lateral_control_angle fast cycle time.
 */
#define FAST_lateral_control_angle                  0

/**
 * Initialise message lateral_control_angle buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_lateral_control_angle(buf) { \
	INITSIG_lateral_control_angle_angle_velocity(buf); \
	INITSIG_lateral_control_angle_angle_value(buf); \
	INITSIG_lateral_control_angle_direction(buf); \
	INITSIG_lateral_control_angle_enable(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_switch_status Message switch_status (0x409)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_switch_status_io
 * - \ref SIG_switch_status_mode
 * - \ref SIG_switch_status_set
 * - \ref SIG_switch_status_plus
 * - \ref SIG_switch_status_minus
 * - \ref SIG_switch_status_res
 *
 * @{
 */

/**
 * Message switch_status configuration tuple.
 */
#define MSG_switch_status                           0x409, 0, 8

/**
 * Message switch_status id.
 */
#define ID_switch_status                            0x409

/**
 * Message switch_status extended id bit.
 */
#define EXT_switch_status                           0

/**
 * Message switch_status Data Length Count.
 */
#define DLC_switch_status                           8

/**
 * Message switch_status cycle time.
 */
#define CYCLE_switch_status                         0

/**
 * Message switch_status fast cycle time.
 */
#define FAST_switch_status                          0

/**
 * Initialise message switch_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_switch_status(buf) { \
	INITSIG_switch_status_io(buf); \
	INITSIG_switch_status_mode(buf); \
	INITSIG_switch_status_set(buf); \
	INITSIG_switch_status_plus(buf); \
	INITSIG_switch_status_minus(buf); \
	INITSIG_switch_status_res(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_lateral_control_torque Message lateral_control_torque (0x302)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_lateral_control_torque_torque_value
 * - \ref SIG_lateral_control_torque_direction
 * - \ref SIG_lateral_control_torque_enable
 *
 * @{
 */

/**
 * Message lateral_control_torque configuration tuple.
 */
#define MSG_lateral_control_torque                  0x302, 0, 8

/**
 * Message lateral_control_torque id.
 */
#define ID_lateral_control_torque                   0x302

/**
 * Message lateral_control_torque extended id bit.
 */
#define EXT_lateral_control_torque                  0

/**
 * Message lateral_control_torque Data Length Count.
 */
#define DLC_lateral_control_torque                  8

/**
 * Message lateral_control_torque cycle time.
 */
#define CYCLE_lateral_control_torque                0

/**
 * Message lateral_control_torque fast cycle time.
 */
#define FAST_lateral_control_torque                 0

/**
 * Initialise message lateral_control_torque buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_lateral_control_torque(buf) { \
	INITSIG_lateral_control_torque_torque_value(buf); \
	INITSIG_lateral_control_torque_direction(buf); \
	INITSIG_lateral_control_torque_enable(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_lateral_torque_status Message lateral_torque_status (0x406)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_lateral_torque_status_torque_status
 * - \ref SIG_lateral_torque_status_actual_torque
 * - \ref SIG_lateral_torque_status_torque_direction
 *
 * @{
 */

/**
 * Message lateral_torque_status configuration tuple.
 */
#define MSG_lateral_torque_status                   0x406, 0, 8

/**
 * Message lateral_torque_status id.
 */
#define ID_lateral_torque_status                    0x406

/**
 * Message lateral_torque_status extended id bit.
 */
#define EXT_lateral_torque_status                   0

/**
 * Message lateral_torque_status Data Length Count.
 */
#define DLC_lateral_torque_status                   8

/**
 * Message lateral_torque_status cycle time.
 */
#define CYCLE_lateral_torque_status                 0

/**
 * Message lateral_torque_status fast cycle time.
 */
#define FAST_lateral_torque_status                  0

/**
 * Initialise message lateral_torque_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_lateral_torque_status(buf) { \
	INITSIG_lateral_torque_status_torque_status(buf); \
	INITSIG_lateral_torque_status_actual_torque(buf); \
	INITSIG_lateral_torque_status_torque_direction(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_steering_status Message steering_status (0x408)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_steering_status_status
 * - \ref SIG_steering_status_steering_angle
 * - \ref SIG_steering_status_steering_angle_direction
 * - \ref SIG_steering_status_steering_velocity_direction
 * - \ref SIG_steering_status_steering_velocity
 *
 * @{
 */

/**
 * Message steering_status configuration tuple.
 */
#define MSG_steering_status                         0x408, 0, 8

/**
 * Message steering_status id.
 */
#define ID_steering_status                          0x408

/**
 * Message steering_status extended id bit.
 */
#define EXT_steering_status                         0

/**
 * Message steering_status Data Length Count.
 */
#define DLC_steering_status                         8

/**
 * Message steering_status cycle time.
 */
#define CYCLE_steering_status                       0

/**
 * Message steering_status fast cycle time.
 */
#define FAST_steering_status                        0

/**
 * Initialise message steering_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_steering_status(buf) { \
	INITSIG_steering_status_status(buf); \
	INITSIG_steering_status_steering_angle(buf); \
	INITSIG_steering_status_steering_angle_direction(buf); \
	INITSIG_steering_status_steering_velocity_direction(buf); \
	INITSIG_steering_status_steering_velocity(buf); \
}

/**
 * @}
 */

/**
 * @defgroup MSG_longitudinal_status Message longitudinal_status (0x405)
 *
 * Contains signal groups:
 *
 * Contains signals:
 * - \ref SIG_longitudinal_status_longitudinal_status
 *
 * @{
 */

/**
 * Message longitudinal_status configuration tuple.
 */
#define MSG_longitudinal_status                     0x405, 0, 8

/**
 * Message longitudinal_status id.
 */
#define ID_longitudinal_status                      0x405

/**
 * Message longitudinal_status extended id bit.
 */
#define EXT_longitudinal_status                     0

/**
 * Message longitudinal_status Data Length Count.
 */
#define DLC_longitudinal_status                     8

/**
 * Message longitudinal_status cycle time.
 */
#define CYCLE_longitudinal_status                   0

/**
 * Message longitudinal_status fast cycle time.
 */
#define FAST_longitudinal_status                    0

/**
 * Initialise message longitudinal_status buffer.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INIT_longitudinal_status(buf) { \
	INITSIG_longitudinal_status_longitudinal_status(buf); \
}

/**
 * @}
 */

/**
 * @defgroup SIG_epb_status_epb_status Signal epb_status of Message epb_status (0x403)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_epb_status
 * @{
 */

/**
 * Signal epb_status configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_epb_status_epb_status and \ref GET_epb_status_epb_status instead.
 */
#define SIG_epb_status_epb_status                   0, 0, 61, 2

/**
 * Signal epb_status setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_epb_status_epb_status or \ref INIT_epb_status instead.
 */
#define SETUP_epb_status_epb_status                 0, 0, 61, 2, 0

/**
 * Get signal epb_status from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_epb_status_epb_status(buf) (0 \
	| (ubyte)(+(ubyte)((buf[7] >> 5) & 0x03) << 0) \
)

/**
 * Set signal epb_status in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_epb_status_epb_status(buf, val) { \
	buf[7] &= ~(0x03 << 5); \
	buf[7] |= (((ubyte)(val) >> 0) & 0x03) << 5; \
}

/**
 * Set signal epb_status in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_epb_status_epb_status(buf) \
	SET_epb_status_epb_status(buf, 0)

/**
 * Signal epb_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_epb_status_epb_status(x, fmt) \
	((x) * fmt)

/**
 * Signal epb_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_epb_status_epb_status(x, fmt) \
	((x) * fmt)

/**
 * Signal epb_status raw initial value.
 */
#define START_epb_status_epb_status                 0

/**
 * Signal epb_status raw minimum value.
 */
#define MIN_epb_status_epb_status                   0

/**
 * Signal epb_status raw maximum value.
 */
#define MAX_epb_status_epb_status                   3

/**
 * Signal epb_status raw offset value.
 */
#define OFF_epb_status_epb_status                   0

/**
 * @}
 */

/**
 * @defgroup SIG_gear_status_actual_gear Signal actual_gear of Message gear_status (0x404)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_gear_status
 * @{
 */

/**
 * Signal actual_gear configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_gear_status_actual_gear and \ref GET_gear_status_actual_gear instead.
 */
#define SIG_gear_status_actual_gear                 0, 0, 42, 4

/**
 * Signal actual_gear setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_gear_status_actual_gear or \ref INIT_gear_status instead.
 */
#define SETUP_gear_status_actual_gear               0, 0, 42, 4, 0

/**
 * Get signal actual_gear from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_gear_status_actual_gear(buf) (0 \
	| (ubyte)(+(ubyte)((buf[5] >> 2) & 0x0f) << 0) \
)

/**
 * Set signal actual_gear in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_gear_status_actual_gear(buf, val) { \
	buf[5] &= ~(0x0f << 2); \
	buf[5] |= (((ubyte)(val) >> 0) & 0x0f) << 2; \
}

/**
 * Set signal actual_gear in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_gear_status_actual_gear(buf) \
	SET_gear_status_actual_gear(buf, 0)

/**
 * Signal actual_gear value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_gear_status_actual_gear(x, fmt) \
	((x) * fmt)

/**
 * Signal actual_gear value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_gear_status_actual_gear(x, fmt) \
	((x) * fmt)

/**
 * Signal actual_gear raw initial value.
 */
#define START_gear_status_actual_gear               0

/**
 * Signal actual_gear raw minimum value.
 */
#define MIN_gear_status_actual_gear                 0

/**
 * Signal actual_gear raw maximum value.
 */
#define MAX_gear_status_actual_gear                 15

/**
 * Signal actual_gear raw offset value.
 */
#define OFF_gear_status_actual_gear                 0

/**
 * @}
 */

/**
 * @defgroup SIG_light_control_warning_blinker Signal warning_blinker of Message light_control (0x304)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_light_control
 * @{
 */

/**
 * Signal warning_blinker configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_light_control_warning_blinker and \ref GET_light_control_warning_blinker instead.
 */
#define SIG_light_control_warning_blinker           0, 1, 16, 1

/**
 * Signal warning_blinker setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_light_control_warning_blinker or \ref INIT_light_control instead.
 */
#define SETUP_light_control_warning_blinker         0, 1, 16, 1, 0

/**
 * Get signal warning_blinker from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_light_control_warning_blinker(buf) (0 \
	| (ubyte)(-(ubyte)((buf[2] >> 0) & 0x01) << 1) \
	| (ubyte)(+(ubyte)((buf[2] >> 0) & 0x01) << 0) \
)

/**
 * Set signal warning_blinker in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_light_control_warning_blinker(buf, val) { \
	buf[2] &= ~(0x01 << 0); \
	buf[2] |= (((ubyte)(val) >> 0) & 0x01) << 0; \
}

/**
 * Set signal warning_blinker in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_light_control_warning_blinker(buf) \
	SET_light_control_warning_blinker(buf, 0)

/**
 * Signal warning_blinker value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_light_control_warning_blinker(x, fmt) \
	((x) * fmt)

/**
 * Signal warning_blinker raw initial value.
 */
#define START_light_control_warning_blinker         0

/**
 * Signal warning_blinker raw minimum value.
 */
#define MIN_light_control_warning_blinker           0

/**
 * Signal warning_blinker raw maximum value.
 */
#define MAX_light_control_warning_blinker           1

/**
 * Signal warning_blinker raw offset value.
 */
#define OFF_light_control_warning_blinker           0

/**
 * @}
 */

/**
 * @defgroup SIG_light_control_right_turn Signal right_turn of Message light_control (0x304)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_light_control
 * @{
 */

/**
 * Signal right_turn configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_light_control_right_turn and \ref GET_light_control_right_turn instead.
 */
#define SIG_light_control_right_turn                0, 1, 8, 1

/**
 * Signal right_turn setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_light_control_right_turn or \ref INIT_light_control instead.
 */
#define SETUP_light_control_right_turn              0, 1, 8, 1, 0

/**
 * Get signal right_turn from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_light_control_right_turn(buf) (0 \
	| (ubyte)(-(ubyte)((buf[1] >> 0) & 0x01) << 1) \
	| (ubyte)(+(ubyte)((buf[1] >> 0) & 0x01) << 0) \
)

/**
 * Set signal right_turn in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_light_control_right_turn(buf, val) { \
	buf[1] &= ~(0x01 << 0); \
	buf[1] |= (((ubyte)(val) >> 0) & 0x01) << 0; \
}

/**
 * Set signal right_turn in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_light_control_right_turn(buf) \
	SET_light_control_right_turn(buf, 0)

/**
 * Signal right_turn value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_light_control_right_turn(x, fmt) \
	((x) * fmt)

/**
 * Signal right_turn raw initial value.
 */
#define START_light_control_right_turn              0

/**
 * Signal right_turn raw minimum value.
 */
#define MIN_light_control_right_turn                0

/**
 * Signal right_turn raw maximum value.
 */
#define MAX_light_control_right_turn                1

/**
 * Signal right_turn raw offset value.
 */
#define OFF_light_control_right_turn                0

/**
 * @}
 */

/**
 * @defgroup SIG_light_control_left_turn Signal left_turn of Message light_control (0x304)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_light_control
 * @{
 */

/**
 * Signal left_turn configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_light_control_left_turn and \ref GET_light_control_left_turn instead.
 */
#define SIG_light_control_left_turn                 0, 1, 0, 1

/**
 * Signal left_turn setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_light_control_left_turn or \ref INIT_light_control instead.
 */
#define SETUP_light_control_left_turn               0, 1, 0, 1, 0

/**
 * Get signal left_turn from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_light_control_left_turn(buf) (0 \
	| (ubyte)(-(ubyte)((buf[0] >> 0) & 0x01) << 1) \
	| (ubyte)(+(ubyte)((buf[0] >> 0) & 0x01) << 0) \
)

/**
 * Set signal left_turn in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_light_control_left_turn(buf, val) { \
	buf[0] &= ~(0x01 << 0); \
	buf[0] |= (((ubyte)(val) >> 0) & 0x01) << 0; \
}

/**
 * Set signal left_turn in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_light_control_left_turn(buf) \
	SET_light_control_left_turn(buf, 0)

/**
 * Signal left_turn value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_light_control_left_turn(x, fmt) \
	((x) * fmt)

/**
 * Signal left_turn raw initial value.
 */
#define START_light_control_left_turn               0

/**
 * Signal left_turn raw minimum value.
 */
#define MIN_light_control_left_turn                 0

/**
 * Signal left_turn raw maximum value.
 */
#define MAX_light_control_left_turn                 1

/**
 * Signal left_turn raw offset value.
 */
#define OFF_light_control_left_turn                 0

/**
 * @}
 */

/**
 * @defgroup SIG_light_control_enable Signal enable of Message light_control (0x304)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_light_control
 * @{
 */

/**
 * Signal enable configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_light_control_enable and \ref GET_light_control_enable instead.
 */
#define SIG_light_control_enable                    0, 1, 24, 1

/**
 * Signal enable setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_light_control_enable or \ref INIT_light_control instead.
 */
#define SETUP_light_control_enable                  0, 1, 24, 1, 0

/**
 * Get signal enable from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_light_control_enable(buf) (0 \
	| (ubyte)(-(ubyte)((buf[3] >> 0) & 0x01) << 1) \
	| (ubyte)(+(ubyte)((buf[3] >> 0) & 0x01) << 0) \
)

/**
 * Set signal enable in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_light_control_enable(buf, val) { \
	buf[3] &= ~(0x01 << 0); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 0; \
}

/**
 * Set signal enable in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_light_control_enable(buf) \
	SET_light_control_enable(buf, 0)

/**
 * Signal enable value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_light_control_enable(x, fmt) \
	((x) * fmt)

/**
 * Signal enable raw initial value.
 */
#define START_light_control_enable                  0

/**
 * Signal enable raw minimum value.
 */
#define MIN_light_control_enable                    0

/**
 * Signal enable raw maximum value.
 */
#define MAX_light_control_enable                    1

/**
 * Signal enable raw offset value.
 */
#define OFF_light_control_enable                    0

/**
 * @}
 */

/**
 * @defgroup SIG_gear_control_position Signal position of Message gear_control (0x303)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_gear_control
 * @{
 */

/**
 * Signal position configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_gear_control_position and \ref GET_gear_control_position instead.
 */
#define SIG_gear_control_position                   0, 0, 8, 4

/**
 * Signal position setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_gear_control_position or \ref INIT_gear_control instead.
 */
#define SETUP_gear_control_position                 0, 0, 8, 4, 0

/**
 * Get signal position from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_gear_control_position(buf) (0 \
	| (ubyte)(+(ubyte)((buf[1] >> 0) & 0x0f) << 0) \
)

/**
 * Set signal position in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_gear_control_position(buf, val) { \
	buf[1] &= ~(0x0f << 0); \
	buf[1] |= (((ubyte)(val) >> 0) & 0x0f) << 0; \
}

/**
 * Set signal position in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_gear_control_position(buf) \
	SET_gear_control_position(buf, 0)

/**
 * Signal position value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_gear_control_position(x, fmt) \
	((x) * fmt)

/**
 * Signal position raw initial value.
 */
#define START_gear_control_position                 0

/**
 * Signal position raw minimum value.
 */
#define MIN_gear_control_position                   0

/**
 * Signal position raw maximum value.
 */
#define MAX_gear_control_position                   15

/**
 * Signal position raw offset value.
 */
#define OFF_gear_control_position                   0

/**
 * @}
 */

/**
 * @defgroup SIG_gear_control_enable Signal enable of Message gear_control (0x303)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_gear_control
 * @{
 */

/**
 * Signal enable configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_gear_control_enable and \ref GET_gear_control_enable instead.
 */
#define SIG_gear_control_enable                     0, 0, 0, 1

/**
 * Signal enable setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_gear_control_enable or \ref INIT_gear_control instead.
 */
#define SETUP_gear_control_enable                   0, 0, 0, 1, 0

/**
 * Get signal enable from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_gear_control_enable(buf) (0 \
	| (ubyte)(+(ubyte)((buf[0] >> 0) & 0x01) << 0) \
)

/**
 * Set signal enable in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_gear_control_enable(buf, val) { \
	buf[0] &= ~(0x01 << 0); \
	buf[0] |= (((ubyte)(val) >> 0) & 0x01) << 0; \
}

/**
 * Set signal enable in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_gear_control_enable(buf) \
	SET_gear_control_enable(buf, 0)

/**
 * Signal enable value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_gear_control_enable(x, fmt) \
	((x) * fmt)

/**
 * Signal enable raw initial value.
 */
#define START_gear_control_enable                   0

/**
 * Signal enable raw minimum value.
 */
#define MIN_gear_control_enable                     0

/**
 * Signal enable raw maximum value.
 */
#define MAX_gear_control_enable                     1

/**
 * Signal enable raw offset value.
 */
#define OFF_gear_control_enable                     0

/**
 * @}
 */

/**
 * @defgroup SIG_longtudinal_command_acceleration_value Signal acceleration_value of Message longtudinal_command (0x300)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_longtudinal_command
 * @{
 */

/**
 * Signal acceleration_value configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_longtudinal_command_acceleration_value and \ref GET_longtudinal_command_acceleration_value instead.
 */
#define SIG_longtudinal_command_acceleration_value        0, 0, 24, 11

/**
 * Signal acceleration_value setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_longtudinal_command_acceleration_value or \ref INIT_longtudinal_command instead.
 */
#define SETUP_longtudinal_command_acceleration_value      0, 0, 24, 11, 0

/**
 * Get signal acceleration_value from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_longtudinal_command_acceleration_value(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[4] >> 0) & 0x07) << 8) \
)

/**
 * Set signal acceleration_value in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_longtudinal_command_acceleration_value(buf, val) { \
	buf[3] &= ~(0xff << 0); \
	buf[3] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[4] &= ~(0x07 << 0); \
	buf[4] |= ((ubyte)((uword)(val) >> 8) & 0x07) << 0; \
}

/**
 * Set signal acceleration_value in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_longtudinal_command_acceleration_value(buf) \
	SET_longtudinal_command_acceleration_value(buf, 0)

/**
 * Signal acceleration_value value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_longtudinal_command_acceleration_value(x, fmt) \
	((x) * fmt / 200 + fmt * (-361) / 50)

/**
 * Signal acceleration_value raw initial value.
 */
#define START_longtudinal_command_acceleration_value      0

/**
 * Signal acceleration_value raw minimum value.
 */
#define MIN_longtudinal_command_acceleration_value        0

/**
 * Signal acceleration_value raw maximum value.
 */
#define MAX_longtudinal_command_acceleration_value        2045

/**
 * Signal acceleration_value raw offset value.
 */
#define OFF_longtudinal_command_acceleration_value        -1444

/**
 * @}
 */

/**
 * @defgroup SIG_longtudinal_command_enable Signal enable of Message longtudinal_command (0x300)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_longtudinal_command
 * @{
 */

/**
 * Signal enable configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_longtudinal_command_enable and \ref GET_longtudinal_command_enable instead.
 */
#define SIG_longtudinal_command_enable              0, 0, 60, 3

/**
 * Signal enable setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_longtudinal_command_enable or \ref INIT_longtudinal_command instead.
 */
#define SETUP_longtudinal_command_enable            0, 0, 60, 3, 0

/**
 * Get signal enable from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_longtudinal_command_enable(buf) (0 \
	| (ubyte)(+(ubyte)((buf[7] >> 4) & 0x07) << 0) \
)

/**
 * Set signal enable in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_longtudinal_command_enable(buf, val) { \
	buf[7] &= ~(0x07 << 4); \
	buf[7] |= (((ubyte)(val) >> 0) & 0x07) << 4; \
}

/**
 * Set signal enable in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_longtudinal_command_enable(buf) \
	SET_longtudinal_command_enable(buf, 0)

/**
 * Signal enable value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_longtudinal_command_enable(x, fmt) \
	((x) * fmt)

/**
 * Signal enable raw initial value.
 */
#define START_longtudinal_command_enable            0

/**
 * Signal enable raw minimum value.
 */
#define MIN_longtudinal_command_enable              0

/**
 * Signal enable raw maximum value.
 */
#define MAX_longtudinal_command_enable              7

/**
 * Signal enable raw offset value.
 */
#define OFF_longtudinal_command_enable              0

/**
 * @}
 */

/**
 * @defgroup SIG_emergency_brake_control_emergency_brake_enable Signal emergency_brake_enable of Message emergency_brake_control (0x305)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_emergency_brake_control
 * @{
 */

/**
 * Signal emergency_brake_enable configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_emergency_brake_control_emergency_brake_enable and \ref GET_emergency_brake_control_emergency_brake_enable instead.
 */
#define SIG_emergency_brake_control_emergency_brake_enable        0, 0, 28, 1

/**
 * Signal emergency_brake_enable setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_emergency_brake_control_emergency_brake_enable or \ref INIT_emergency_brake_control instead.
 */
#define SETUP_emergency_brake_control_emergency_brake_enable      0, 0, 28, 1, 0

/**
 * Get signal emergency_brake_enable from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_emergency_brake_control_emergency_brake_enable(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 4) & 0x01) << 0) \
)

/**
 * Set signal emergency_brake_enable in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_emergency_brake_control_emergency_brake_enable(buf, val) { \
	buf[3] &= ~(0x01 << 4); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 4; \
}

/**
 * Set signal emergency_brake_enable in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_emergency_brake_control_emergency_brake_enable(buf) \
	SET_emergency_brake_control_emergency_brake_enable(buf, 0)

/**
 * Signal emergency_brake_enable value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_emergency_brake_control_emergency_brake_enable(x, fmt) \
	((x) * fmt)

/**
 * Signal emergency_brake_enable raw initial value.
 */
#define START_emergency_brake_control_emergency_brake_enable      0

/**
 * Signal emergency_brake_enable raw minimum value.
 */
#define MIN_emergency_brake_control_emergency_brake_enable        0

/**
 * Signal emergency_brake_enable raw maximum value.
 */
#define MAX_emergency_brake_control_emergency_brake_enable        1

/**
 * Signal emergency_brake_enable raw offset value.
 */
#define OFF_emergency_brake_control_emergency_brake_enable        0

/**
 * @}
 */

/**
 * @defgroup SIG_emergency_brake_control_emergency_brake_value Signal emergency_brake_value of Message emergency_brake_control (0x305)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_emergency_brake_control
 * @{
 */

/**
 * Signal emergency_brake_value configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_emergency_brake_control_emergency_brake_value and \ref GET_emergency_brake_control_emergency_brake_value instead.
 */
#define SIG_emergency_brake_control_emergency_brake_value        0, 0, 29, 10

/**
 * Signal emergency_brake_value setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_emergency_brake_control_emergency_brake_value or \ref INIT_emergency_brake_control instead.
 */
#define SETUP_emergency_brake_control_emergency_brake_value      0, 0, 29, 10, 0

/**
 * Get signal emergency_brake_value from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_emergency_brake_control_emergency_brake_value(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 5) & 0x07) << 0) \
	| (uword)(+(uword)((buf[4] >> 0) & 0x7f) << 3) \
)

/**
 * Set signal emergency_brake_value in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_emergency_brake_control_emergency_brake_value(buf, val) { \
	buf[3] &= ~(0x07 << 5); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x07) << 5; \
	buf[4] &= ~(0x7f << 0); \
	buf[4] |= ((ubyte)((uword)(val) >> 3) & 0x7f) << 0; \
}

/**
 * Set signal emergency_brake_value in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_emergency_brake_control_emergency_brake_value(buf) \
	SET_emergency_brake_control_emergency_brake_value(buf, 0)

/**
 * Signal emergency_brake_value value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_emergency_brake_control_emergency_brake_value(x, fmt) \
	((x) * fmt * 3 / 125 + fmt * (-1000000000) / 49960031)

/**
 * Signal emergency_brake_value raw initial value.
 */
#define START_emergency_brake_control_emergency_brake_value      0

/**
 * Signal emergency_brake_value raw minimum value.
 */
#define MIN_emergency_brake_control_emergency_brake_value        0

/**
 * Signal emergency_brake_value raw maximum value.
 */
#define MAX_emergency_brake_control_emergency_brake_value        1023

/**
 * Signal emergency_brake_value raw offset value.
 */
#define OFF_emergency_brake_control_emergency_brake_value        -834

/**
 * @}
 */

/**
 * @defgroup SIG_light_status_WarningBlinker Signal WarningBlinker of Message light_status (0x400)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_light_status
 * @{
 */

/**
 * Signal WarningBlinker configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_light_status_WarningBlinker and \ref GET_light_status_WarningBlinker instead.
 */
#define SIG_light_status_WarningBlinker             0, 0, 20, 1

/**
 * Signal WarningBlinker setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_light_status_WarningBlinker or \ref INIT_light_status instead.
 */
#define SETUP_light_status_WarningBlinker           0, 0, 20, 1, 0

/**
 * Get signal WarningBlinker from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_light_status_WarningBlinker(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 4) & 0x01) << 0) \
)

/**
 * Set signal WarningBlinker in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_light_status_WarningBlinker(buf, val) { \
	buf[2] &= ~(0x01 << 4); \
	buf[2] |= (((ubyte)(val) >> 0) & 0x01) << 4; \
}

/**
 * Set signal WarningBlinker in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_light_status_WarningBlinker(buf) \
	SET_light_status_WarningBlinker(buf, 0)

/**
 * Signal WarningBlinker value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_light_status_WarningBlinker(x, fmt) \
	((x) * fmt)

/**
 * Signal WarningBlinker value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_light_status_WarningBlinker(x, fmt) \
	((x) * fmt)

/**
 * Signal WarningBlinker raw initial value.
 */
#define START_light_status_WarningBlinker           0

/**
 * Signal WarningBlinker raw minimum value.
 */
#define MIN_light_status_WarningBlinker             0

/**
 * Signal WarningBlinker raw maximum value.
 */
#define MAX_light_status_WarningBlinker             1

/**
 * Signal WarningBlinker raw offset value.
 */
#define OFF_light_status_WarningBlinker             0

/**
 * @}
 */

/**
 * @defgroup SIG_light_status_Turnleft Signal Turnleft of Message light_status (0x400)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_light_status
 * @{
 */

/**
 * Signal Turnleft configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_light_status_Turnleft and \ref GET_light_status_Turnleft instead.
 */
#define SIG_light_status_Turnleft                   0, 0, 23, 1

/**
 * Signal Turnleft setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_light_status_Turnleft or \ref INIT_light_status instead.
 */
#define SETUP_light_status_Turnleft                 0, 0, 23, 1, 0

/**
 * Get signal Turnleft from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_light_status_Turnleft(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 7) & 0x01) << 0) \
)

/**
 * Set signal Turnleft in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_light_status_Turnleft(buf, val) { \
	buf[2] &= ~(0x01 << 7); \
	buf[2] |= (((ubyte)(val) >> 0) & 0x01) << 7; \
}

/**
 * Set signal Turnleft in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_light_status_Turnleft(buf) \
	SET_light_status_Turnleft(buf, 0)

/**
 * Signal Turnleft value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_light_status_Turnleft(x, fmt) \
	((x) * fmt)

/**
 * Signal Turnleft value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_light_status_Turnleft(x, fmt) \
	((x) * fmt)

/**
 * Signal Turnleft raw initial value.
 */
#define START_light_status_Turnleft                 0

/**
 * Signal Turnleft raw minimum value.
 */
#define MIN_light_status_Turnleft                   0

/**
 * Signal Turnleft raw maximum value.
 */
#define MAX_light_status_Turnleft                   1

/**
 * Signal Turnleft raw offset value.
 */
#define OFF_light_status_Turnleft                   0

/**
 * @}
 */

/**
 * @defgroup SIG_light_status_TurnRight Signal TurnRight of Message light_status (0x400)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_light_status
 * @{
 */

/**
 * Signal TurnRight configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_light_status_TurnRight and \ref GET_light_status_TurnRight instead.
 */
#define SIG_light_status_TurnRight                  0, 0, 24, 1

/**
 * Signal TurnRight setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_light_status_TurnRight or \ref INIT_light_status instead.
 */
#define SETUP_light_status_TurnRight                0, 0, 24, 1, 0

/**
 * Get signal TurnRight from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_light_status_TurnRight(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 0) & 0x01) << 0) \
)

/**
 * Set signal TurnRight in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_light_status_TurnRight(buf, val) { \
	buf[3] &= ~(0x01 << 0); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 0; \
}

/**
 * Set signal TurnRight in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_light_status_TurnRight(buf) \
	SET_light_status_TurnRight(buf, 0)

/**
 * Signal TurnRight value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_light_status_TurnRight(x, fmt) \
	((x) * fmt)

/**
 * Signal TurnRight value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_light_status_TurnRight(x, fmt) \
	((x) * fmt)

/**
 * Signal TurnRight raw initial value.
 */
#define START_light_status_TurnRight                0

/**
 * Signal TurnRight raw minimum value.
 */
#define MIN_light_status_TurnRight                  0

/**
 * Signal TurnRight raw maximum value.
 */
#define MAX_light_status_TurnRight                  1

/**
 * Signal TurnRight raw offset value.
 */
#define OFF_light_status_TurnRight                  0

/**
 * @}
 */

/**
 * @defgroup SIG_yawrate_status_lateral_acc Signal lateral_acc of Message yawrate_status (0x40c)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_yawrate_status
 * @{
 */

/**
 * Signal lateral_acc configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_yawrate_status_lateral_acc and \ref GET_yawrate_status_lateral_acc instead.
 */
#define SIG_yawrate_status_lateral_acc              0, 0, 16, 8

/**
 * Signal lateral_acc setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_yawrate_status_lateral_acc or \ref INIT_yawrate_status instead.
 */
#define SETUP_yawrate_status_lateral_acc            0, 0, 16, 8, 0

/**
 * Get signal lateral_acc from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_yawrate_status_lateral_acc(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 0) & 0xff) << 0) \
)

/**
 * Set signal lateral_acc in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_yawrate_status_lateral_acc(buf, val) { \
	buf[2] &= ~(0xff << 0); \
	buf[2] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
}

/**
 * Set signal lateral_acc in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_yawrate_status_lateral_acc(buf) \
	SET_yawrate_status_lateral_acc(buf, 0)

/**
 * Signal lateral_acc value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_yawrate_status_lateral_acc(x, fmt) \
	((x) * fmt / 100 + fmt * (-127) / 100)

/**
 * Signal lateral_acc value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_yawrate_status_lateral_acc(x, fmt) \
	(((x) + fmt * 127 / 100) * fmt * 100 )

/**
 * Signal lateral_acc raw initial value.
 */
#define START_yawrate_status_lateral_acc            0

/**
 * Signal lateral_acc raw minimum value.
 */
#define MIN_yawrate_status_lateral_acc              0

/**
 * Signal lateral_acc raw maximum value.
 */
#define MAX_yawrate_status_lateral_acc              254

/**
 * Signal lateral_acc raw offset value.
 */
#define OFF_yawrate_status_lateral_acc              -127

/**
 * @}
 */

/**
 * @defgroup SIG_yawrate_status_longitude_acc Signal longitude_acc of Message yawrate_status (0x40c)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_yawrate_status
 * @{
 */

/**
 * Signal longitude_acc configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_yawrate_status_longitude_acc and \ref GET_yawrate_status_longitude_acc instead.
 */
#define SIG_yawrate_status_longitude_acc            0, 0, 24, 10

/**
 * Signal longitude_acc setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_yawrate_status_longitude_acc or \ref INIT_yawrate_status instead.
 */
#define SETUP_yawrate_status_longitude_acc          0, 0, 24, 10, 0

/**
 * Get signal longitude_acc from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_yawrate_status_longitude_acc(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[4] >> 0) & 0x03) << 8) \
)

/**
 * Set signal longitude_acc in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_yawrate_status_longitude_acc(buf, val) { \
	buf[3] &= ~(0xff << 0); \
	buf[3] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[4] &= ~(0x03 << 0); \
	buf[4] |= ((ubyte)((uword)(val) >> 8) & 0x03) << 0; \
}

/**
 * Set signal longitude_acc in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_yawrate_status_longitude_acc(buf) \
	SET_yawrate_status_longitude_acc(buf, 0)

/**
 * Signal longitude_acc value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_yawrate_status_longitude_acc(x, fmt) \
	((x) * fmt / 32 + fmt * (-16))

/**
 * Signal longitude_acc value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_yawrate_status_longitude_acc(x, fmt) \
	(((x) + fmt * 16) * fmt * 32 )

/**
 * Signal longitude_acc raw initial value.
 */
#define START_yawrate_status_longitude_acc          0

/**
 * Signal longitude_acc raw minimum value.
 */
#define MIN_yawrate_status_longitude_acc            0

/**
 * Signal longitude_acc raw maximum value.
 */
#define MAX_yawrate_status_longitude_acc            1021

/**
 * Signal longitude_acc raw offset value.
 */
#define OFF_yawrate_status_longitude_acc            -512

/**
 * @}
 */

/**
 * @defgroup SIG_yawrate_status_yawrate Signal yawrate of Message yawrate_status (0x40c)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_yawrate_status
 * @{
 */

/**
 * Signal yawrate configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_yawrate_status_yawrate and \ref GET_yawrate_status_yawrate instead.
 */
#define SIG_yawrate_status_yawrate                  0, 0, 40, 14

/**
 * Signal yawrate setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_yawrate_status_yawrate or \ref INIT_yawrate_status instead.
 */
#define SETUP_yawrate_status_yawrate                0, 0, 40, 14, 0

/**
 * Get signal yawrate from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_yawrate_status_yawrate(buf) (0 \
	| (ubyte)(+(ubyte)((buf[5] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[6] >> 0) & 0x3f) << 8) \
)

/**
 * Set signal yawrate in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_yawrate_status_yawrate(buf, val) { \
	buf[5] &= ~(0xff << 0); \
	buf[5] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[6] &= ~(0x3f << 0); \
	buf[6] |= ((ubyte)((uword)(val) >> 8) & 0x3f) << 0; \
}

/**
 * Set signal yawrate in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_yawrate_status_yawrate(buf) \
	SET_yawrate_status_yawrate(buf, 0)

/**
 * Signal yawrate value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_yawrate_status_yawrate(x, fmt) \
	((x) * fmt / 100)

/**
 * Signal yawrate value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_yawrate_status_yawrate(x, fmt) \
	((x) * fmt * 100)

/**
 * Signal yawrate raw initial value.
 */
#define START_yawrate_status_yawrate                0

/**
 * Signal yawrate raw minimum value.
 */
#define MIN_yawrate_status_yawrate                  0

/**
 * Signal yawrate raw maximum value.
 */
#define MAX_yawrate_status_yawrate                  16382

/**
 * Signal yawrate raw offset value.
 */
#define OFF_yawrate_status_yawrate                  0

/**
 * @}
 */

/**
 * @defgroup SIG_yawrate_status_yawrate_direction Signal yawrate_direction of Message yawrate_status (0x40c)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_yawrate_status
 * @{
 */

/**
 * Signal yawrate_direction configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_yawrate_status_yawrate_direction and \ref GET_yawrate_status_yawrate_direction instead.
 */
#define SIG_yawrate_status_yawrate_direction        0, 0, 54, 1

/**
 * Signal yawrate_direction setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_yawrate_status_yawrate_direction or \ref INIT_yawrate_status instead.
 */
#define SETUP_yawrate_status_yawrate_direction      0, 0, 54, 1, 0

/**
 * Get signal yawrate_direction from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_yawrate_status_yawrate_direction(buf) (0 \
	| (ubyte)(+(ubyte)((buf[6] >> 6) & 0x01) << 0) \
)

/**
 * Set signal yawrate_direction in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_yawrate_status_yawrate_direction(buf, val) { \
	buf[6] &= ~(0x01 << 6); \
	buf[6] |= (((ubyte)(val) >> 0) & 0x01) << 6; \
}

/**
 * Set signal yawrate_direction in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_yawrate_status_yawrate_direction(buf) \
	SET_yawrate_status_yawrate_direction(buf, 0)

/**
 * Signal yawrate_direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_yawrate_status_yawrate_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal yawrate_direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_yawrate_status_yawrate_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal yawrate_direction raw initial value.
 */
#define START_yawrate_status_yawrate_direction      0

/**
 * Signal yawrate_direction raw minimum value.
 */
#define MIN_yawrate_status_yawrate_direction        0

/**
 * Signal yawrate_direction raw maximum value.
 */
#define MAX_yawrate_status_yawrate_direction        1

/**
 * Signal yawrate_direction raw offset value.
 */
#define OFF_yawrate_status_yawrate_direction        0

/**
 * @}
 */

/**
 * @defgroup SIG_brake_status_brake_torque Signal brake_torque of Message brake_status (0x401)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_brake_status
 * @{
 */

/**
 * Signal brake_torque configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_brake_status_brake_torque and \ref GET_brake_status_brake_torque instead.
 */
#define SIG_brake_status_brake_torque               0, 0, 16, 10

/**
 * Signal brake_torque setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_brake_status_brake_torque or \ref INIT_brake_status instead.
 */
#define SETUP_brake_status_brake_torque             0, 0, 16, 10, 0

/**
 * Get signal brake_torque from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_brake_status_brake_torque(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[3] >> 0) & 0x03) << 8) \
)

/**
 * Set signal brake_torque in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_brake_status_brake_torque(buf, val) { \
	buf[2] &= ~(0xff << 0); \
	buf[2] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[3] &= ~(0x03 << 0); \
	buf[3] |= ((ubyte)((uword)(val) >> 8) & 0x03) << 0; \
}

/**
 * Set signal brake_torque in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_brake_status_brake_torque(buf) \
	SET_brake_status_brake_torque(buf, 0)

/**
 * Signal brake_torque value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_brake_status_brake_torque(x, fmt) \
	((x) * fmt * 3 / 10 + fmt * (-30))

/**
 * Signal brake_torque value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_brake_status_brake_torque(x, fmt) \
	(((x) + fmt * 30) * fmt * 10 / 3)

/**
 * Signal brake_torque raw initial value.
 */
#define START_brake_status_brake_torque             0

/**
 * Signal brake_torque raw minimum value.
 */
#define MIN_brake_status_brake_torque               0

/**
 * Signal brake_torque raw maximum value.
 */
#define MAX_brake_status_brake_torque               1022

/**
 * Signal brake_torque raw offset value.
 */
#define OFF_brake_status_brake_torque               -100

/**
 * @}
 */

/**
 * @defgroup SIG_brake_status_brake_status Signal brake_status of Message brake_status (0x401)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_brake_status
 * @{
 */

/**
 * Signal brake_status configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_brake_status_brake_status and \ref GET_brake_status_brake_status instead.
 */
#define SIG_brake_status_brake_status               0, 0, 26, 1

/**
 * Signal brake_status setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_brake_status_brake_status or \ref INIT_brake_status instead.
 */
#define SETUP_brake_status_brake_status             0, 0, 26, 1, 0

/**
 * Get signal brake_status from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_brake_status_brake_status(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 2) & 0x01) << 0) \
)

/**
 * Set signal brake_status in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_brake_status_brake_status(buf, val) { \
	buf[3] &= ~(0x01 << 2); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 2; \
}

/**
 * Set signal brake_status in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_brake_status_brake_status(buf) \
	SET_brake_status_brake_status(buf, 0)

/**
 * Signal brake_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_brake_status_brake_status(x, fmt) \
	((x) * fmt)

/**
 * Signal brake_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_brake_status_brake_status(x, fmt) \
	((x) * fmt)

/**
 * Signal brake_status raw initial value.
 */
#define START_brake_status_brake_status             0

/**
 * Signal brake_status raw minimum value.
 */
#define MIN_brake_status_brake_status               0

/**
 * Signal brake_status raw maximum value.
 */
#define MAX_brake_status_brake_status               1

/**
 * Signal brake_status raw offset value.
 */
#define OFF_brake_status_brake_status               0

/**
 * @}
 */

/**
 * @defgroup SIG_brake_status_brake_pressure_status Signal brake_pressure_status of Message brake_status (0x401)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_brake_status
 * @{
 */

/**
 * Signal brake_pressure_status configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_brake_status_brake_pressure_status and \ref GET_brake_status_brake_pressure_status instead.
 */
#define SIG_brake_status_brake_pressure_status        0, 0, 61, 1

/**
 * Signal brake_pressure_status setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_brake_status_brake_pressure_status or \ref INIT_brake_status instead.
 */
#define SETUP_brake_status_brake_pressure_status      0, 0, 61, 1, 0

/**
 * Get signal brake_pressure_status from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_brake_status_brake_pressure_status(buf) (0 \
	| (ubyte)(+(ubyte)((buf[7] >> 5) & 0x01) << 0) \
)

/**
 * Set signal brake_pressure_status in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_brake_status_brake_pressure_status(buf, val) { \
	buf[7] &= ~(0x01 << 5); \
	buf[7] |= (((ubyte)(val) >> 0) & 0x01) << 5; \
}

/**
 * Set signal brake_pressure_status in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_brake_status_brake_pressure_status(buf) \
	SET_brake_status_brake_pressure_status(buf, 0)

/**
 * Signal brake_pressure_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_brake_status_brake_pressure_status(x, fmt) \
	((x) * fmt)

/**
 * Signal brake_pressure_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_brake_status_brake_pressure_status(x, fmt) \
	((x) * fmt)

/**
 * Signal brake_pressure_status raw initial value.
 */
#define START_brake_status_brake_pressure_status      0

/**
 * Signal brake_pressure_status raw minimum value.
 */
#define MIN_brake_status_brake_pressure_status        0

/**
 * Signal brake_pressure_status raw maximum value.
 */
#define MAX_brake_status_brake_pressure_status        1

/**
 * Signal brake_pressure_status raw offset value.
 */
#define OFF_brake_status_brake_pressure_status        0

/**
 * @}
 */

/**
 * @defgroup SIG_wheel_speed_status_rl_wheelspeed Signal rl_wheelspeed of Message wheel_speed_status (0x40b)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_wheel_speed_status
 * @{
 */

/**
 * Signal rl_wheelspeed configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_wheel_speed_status_rl_wheelspeed and \ref GET_wheel_speed_status_rl_wheelspeed instead.
 */
#define SIG_wheel_speed_status_rl_wheelspeed        0, 0, 0, 16

/**
 * Signal rl_wheelspeed setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_wheel_speed_status_rl_wheelspeed or \ref INIT_wheel_speed_status instead.
 */
#define SETUP_wheel_speed_status_rl_wheelspeed      0, 0, 0, 16, 0

/**
 * Get signal rl_wheelspeed from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_wheel_speed_status_rl_wheelspeed(buf) (0 \
	| (ubyte)(+(ubyte)((buf[0] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[1] >> 0) & 0xff) << 8) \
)

/**
 * Set signal rl_wheelspeed in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_wheel_speed_status_rl_wheelspeed(buf, val) { \
	buf[0] &= ~(0xff << 0); \
	buf[0] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[1] &= ~(0xff << 0); \
	buf[1] |= ((ubyte)((uword)(val) >> 8) & 0xff) << 0; \
}

/**
 * Set signal rl_wheelspeed in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_wheel_speed_status_rl_wheelspeed(buf) \
	SET_wheel_speed_status_rl_wheelspeed(buf, 0)

/**
 * Signal rl_wheelspeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_wheel_speed_status_rl_wheelspeed(x, fmt) \
	((x) * fmt * 3 / 400)

/**
 * Signal rl_wheelspeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_wheel_speed_status_rl_wheelspeed(x, fmt) \
	((x) * fmt * 400 / 3)

/**
 * Signal rl_wheelspeed raw initial value.
 */
#define START_wheel_speed_status_rl_wheelspeed      0

/**
 * Signal rl_wheelspeed raw minimum value.
 */
#define MIN_wheel_speed_status_rl_wheelspeed        0

/**
 * Signal rl_wheelspeed raw maximum value.
 */
#define MAX_wheel_speed_status_rl_wheelspeed        65532

/**
 * Signal rl_wheelspeed raw offset value.
 */
#define OFF_wheel_speed_status_rl_wheelspeed        0

/**
 * @}
 */

/**
 * @defgroup SIG_wheel_speed_status_rr_wheelspeed Signal rr_wheelspeed of Message wheel_speed_status (0x40b)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_wheel_speed_status
 * @{
 */

/**
 * Signal rr_wheelspeed configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_wheel_speed_status_rr_wheelspeed and \ref GET_wheel_speed_status_rr_wheelspeed instead.
 */
#define SIG_wheel_speed_status_rr_wheelspeed        0, 0, 16, 16

/**
 * Signal rr_wheelspeed setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_wheel_speed_status_rr_wheelspeed or \ref INIT_wheel_speed_status instead.
 */
#define SETUP_wheel_speed_status_rr_wheelspeed      0, 0, 16, 16, 0

/**
 * Get signal rr_wheelspeed from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_wheel_speed_status_rr_wheelspeed(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[3] >> 0) & 0xff) << 8) \
)

/**
 * Set signal rr_wheelspeed in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_wheel_speed_status_rr_wheelspeed(buf, val) { \
	buf[2] &= ~(0xff << 0); \
	buf[2] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[3] &= ~(0xff << 0); \
	buf[3] |= ((ubyte)((uword)(val) >> 8) & 0xff) << 0; \
}

/**
 * Set signal rr_wheelspeed in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_wheel_speed_status_rr_wheelspeed(buf) \
	SET_wheel_speed_status_rr_wheelspeed(buf, 0)

/**
 * Signal rr_wheelspeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_wheel_speed_status_rr_wheelspeed(x, fmt) \
	((x) * fmt * 3 / 400)

/**
 * Signal rr_wheelspeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_wheel_speed_status_rr_wheelspeed(x, fmt) \
	((x) * fmt * 400 / 3)

/**
 * Signal rr_wheelspeed raw initial value.
 */
#define START_wheel_speed_status_rr_wheelspeed      0

/**
 * Signal rr_wheelspeed raw minimum value.
 */
#define MIN_wheel_speed_status_rr_wheelspeed        0

/**
 * Signal rr_wheelspeed raw maximum value.
 */
#define MAX_wheel_speed_status_rr_wheelspeed        65532

/**
 * Signal rr_wheelspeed raw offset value.
 */
#define OFF_wheel_speed_status_rr_wheelspeed        0

/**
 * @}
 */

/**
 * @defgroup SIG_wheel_speed_status_fl_wheelspeed Signal fl_wheelspeed of Message wheel_speed_status (0x40b)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_wheel_speed_status
 * @{
 */

/**
 * Signal fl_wheelspeed configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_wheel_speed_status_fl_wheelspeed and \ref GET_wheel_speed_status_fl_wheelspeed instead.
 */
#define SIG_wheel_speed_status_fl_wheelspeed        0, 0, 32, 16

/**
 * Signal fl_wheelspeed setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_wheel_speed_status_fl_wheelspeed or \ref INIT_wheel_speed_status instead.
 */
#define SETUP_wheel_speed_status_fl_wheelspeed      0, 0, 32, 16, 0

/**
 * Get signal fl_wheelspeed from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_wheel_speed_status_fl_wheelspeed(buf) (0 \
	| (ubyte)(+(ubyte)((buf[4] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[5] >> 0) & 0xff) << 8) \
)

/**
 * Set signal fl_wheelspeed in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_wheel_speed_status_fl_wheelspeed(buf, val) { \
	buf[4] &= ~(0xff << 0); \
	buf[4] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[5] &= ~(0xff << 0); \
	buf[5] |= ((ubyte)((uword)(val) >> 8) & 0xff) << 0; \
}

/**
 * Set signal fl_wheelspeed in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_wheel_speed_status_fl_wheelspeed(buf) \
	SET_wheel_speed_status_fl_wheelspeed(buf, 0)

/**
 * Signal fl_wheelspeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_wheel_speed_status_fl_wheelspeed(x, fmt) \
	((x) * fmt * 3 / 400)

/**
 * Signal fl_wheelspeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_wheel_speed_status_fl_wheelspeed(x, fmt) \
	((x) * fmt * 400 / 3)

/**
 * Signal fl_wheelspeed raw initial value.
 */
#define START_wheel_speed_status_fl_wheelspeed      0

/**
 * Signal fl_wheelspeed raw minimum value.
 */
#define MIN_wheel_speed_status_fl_wheelspeed        0

/**
 * Signal fl_wheelspeed raw maximum value.
 */
#define MAX_wheel_speed_status_fl_wheelspeed        65532

/**
 * Signal fl_wheelspeed raw offset value.
 */
#define OFF_wheel_speed_status_fl_wheelspeed        0

/**
 * @}
 */

/**
 * @defgroup SIG_wheel_speed_status_fr_wheelspeed Signal fr_wheelspeed of Message wheel_speed_status (0x40b)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_wheel_speed_status
 * @{
 */

/**
 * Signal fr_wheelspeed configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_wheel_speed_status_fr_wheelspeed and \ref GET_wheel_speed_status_fr_wheelspeed instead.
 */
#define SIG_wheel_speed_status_fr_wheelspeed        0, 0, 48, 16

/**
 * Signal fr_wheelspeed setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_wheel_speed_status_fr_wheelspeed or \ref INIT_wheel_speed_status instead.
 */
#define SETUP_wheel_speed_status_fr_wheelspeed      0, 0, 48, 16, 0

/**
 * Get signal fr_wheelspeed from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_wheel_speed_status_fr_wheelspeed(buf) (0 \
	| (ubyte)(+(ubyte)((buf[6] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[7] >> 0) & 0xff) << 8) \
)

/**
 * Set signal fr_wheelspeed in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_wheel_speed_status_fr_wheelspeed(buf, val) { \
	buf[6] &= ~(0xff << 0); \
	buf[6] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[7] &= ~(0xff << 0); \
	buf[7] |= ((ubyte)((uword)(val) >> 8) & 0xff) << 0; \
}

/**
 * Set signal fr_wheelspeed in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_wheel_speed_status_fr_wheelspeed(buf) \
	SET_wheel_speed_status_fr_wheelspeed(buf, 0)

/**
 * Signal fr_wheelspeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_wheel_speed_status_fr_wheelspeed(x, fmt) \
	((x) * fmt * 3 / 400)

/**
 * Signal fr_wheelspeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_wheel_speed_status_fr_wheelspeed(x, fmt) \
	((x) * fmt * 400 / 3)

/**
 * Signal fr_wheelspeed raw initial value.
 */
#define START_wheel_speed_status_fr_wheelspeed      0

/**
 * Signal fr_wheelspeed raw minimum value.
 */
#define MIN_wheel_speed_status_fr_wheelspeed        0

/**
 * Signal fr_wheelspeed raw maximum value.
 */
#define MAX_wheel_speed_status_fr_wheelspeed        65532

/**
 * Signal fr_wheelspeed raw offset value.
 */
#define OFF_wheel_speed_status_fr_wheelspeed        0

/**
 * @}
 */

/**
 * @defgroup SIG_vehicle_speed_status_real_vehiclespeed Signal real_vehiclespeed of Message vehicle_speed_status (0x40a)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_vehicle_speed_status
 * @{
 */

/**
 * Signal real_vehiclespeed configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_vehicle_speed_status_real_vehiclespeed and \ref GET_vehicle_speed_status_real_vehiclespeed instead.
 */
#define SIG_vehicle_speed_status_real_vehiclespeed        0, 0, 32, 16

/**
 * Signal real_vehiclespeed setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_vehicle_speed_status_real_vehiclespeed or \ref INIT_vehicle_speed_status instead.
 */
#define SETUP_vehicle_speed_status_real_vehiclespeed      0, 0, 32, 16, 0

/**
 * Get signal real_vehiclespeed from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_vehicle_speed_status_real_vehiclespeed(buf) (0 \
	| (ubyte)(+(ubyte)((buf[4] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[5] >> 0) & 0xff) << 8) \
)

/**
 * Set signal real_vehiclespeed in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_vehicle_speed_status_real_vehiclespeed(buf, val) { \
	buf[4] &= ~(0xff << 0); \
	buf[4] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[5] &= ~(0xff << 0); \
	buf[5] |= ((ubyte)((uword)(val) >> 8) & 0xff) << 0; \
}

/**
 * Set signal real_vehiclespeed in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_vehicle_speed_status_real_vehiclespeed(buf) \
	SET_vehicle_speed_status_real_vehiclespeed(buf, 0)

/**
 * Signal real_vehiclespeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_vehicle_speed_status_real_vehiclespeed(x, fmt) \
	((x) * fmt / 100)

/**
 * Signal real_vehiclespeed value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_vehicle_speed_status_real_vehiclespeed(x, fmt) \
	((x) * fmt * 100)

/**
 * Signal real_vehiclespeed raw initial value.
 */
#define START_vehicle_speed_status_real_vehiclespeed      0

/**
 * Signal real_vehiclespeed raw minimum value.
 */
#define MIN_vehicle_speed_status_real_vehiclespeed        0

/**
 * Signal real_vehiclespeed raw maximum value.
 */
#define MAX_vehicle_speed_status_real_vehiclespeed        65532

/**
 * Signal real_vehiclespeed raw offset value.
 */
#define OFF_vehicle_speed_status_real_vehiclespeed        0

/**
 * @}
 */

/**
 * @defgroup SIG_door_status_rear_left Signal rear_left of Message door_status (0x402)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_door_status
 * @{
 */

/**
 * Signal rear_left configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_door_status_rear_left and \ref GET_door_status_rear_left instead.
 */
#define SIG_door_status_rear_left                   0, 0, 20, 1

/**
 * Signal rear_left setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_door_status_rear_left or \ref INIT_door_status instead.
 */
#define SETUP_door_status_rear_left                 0, 0, 20, 1, 0

/**
 * Get signal rear_left from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_door_status_rear_left(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 4) & 0x01) << 0) \
)

/**
 * Set signal rear_left in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_door_status_rear_left(buf, val) { \
	buf[2] &= ~(0x01 << 4); \
	buf[2] |= (((ubyte)(val) >> 0) & 0x01) << 4; \
}

/**
 * Set signal rear_left in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_door_status_rear_left(buf) \
	SET_door_status_rear_left(buf, 0)

/**
 * Signal rear_left value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_door_status_rear_left(x, fmt) \
	((x) * fmt)

/**
 * Signal rear_left value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_door_status_rear_left(x, fmt) \
	((x) * fmt)

/**
 * Signal rear_left raw initial value.
 */
#define START_door_status_rear_left                 0

/**
 * Signal rear_left raw minimum value.
 */
#define MIN_door_status_rear_left                   0

/**
 * Signal rear_left raw maximum value.
 */
#define MAX_door_status_rear_left                   1

/**
 * Signal rear_left raw offset value.
 */
#define OFF_door_status_rear_left                   0

/**
 * @}
 */

/**
 * @defgroup SIG_door_status_rear_right Signal rear_right of Message door_status (0x402)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_door_status
 * @{
 */

/**
 * Signal rear_right configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_door_status_rear_right and \ref GET_door_status_rear_right instead.
 */
#define SIG_door_status_rear_right                  0, 0, 21, 1

/**
 * Signal rear_right setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_door_status_rear_right or \ref INIT_door_status instead.
 */
#define SETUP_door_status_rear_right                0, 0, 21, 1, 0

/**
 * Get signal rear_right from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_door_status_rear_right(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 5) & 0x01) << 0) \
)

/**
 * Set signal rear_right in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_door_status_rear_right(buf, val) { \
	buf[2] &= ~(0x01 << 5); \
	buf[2] |= (((ubyte)(val) >> 0) & 0x01) << 5; \
}

/**
 * Set signal rear_right in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_door_status_rear_right(buf) \
	SET_door_status_rear_right(buf, 0)

/**
 * Signal rear_right value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_door_status_rear_right(x, fmt) \
	((x) * fmt)

/**
 * Signal rear_right value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_door_status_rear_right(x, fmt) \
	((x) * fmt)


/**
 * Signal rear_right raw initial value.
 */
#define START_door_status_rear_right                0

/**
 * Signal rear_right raw minimum value.
 */
#define MIN_door_status_rear_right                  0

/**
 * Signal rear_right raw maximum value.
 */
#define MAX_door_status_rear_right                  1

/**
 * Signal rear_right raw offset value.
 */
#define OFF_door_status_rear_right                  0

/**
 * @}
 */

/**
 * @defgroup SIG_door_status_front_right Signal front_right of Message door_status (0x402)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_door_status
 * @{
 */

/**
 * Signal front_right configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_door_status_front_right and \ref GET_door_status_front_right instead.
 */
#define SIG_door_status_front_right                 0, 0, 24, 1

/**
 * Signal front_right setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_door_status_front_right or \ref INIT_door_status instead.
 */
#define SETUP_door_status_front_right               0, 0, 24, 1, 0

/**
 * Get signal front_right from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_door_status_front_right(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 0) & 0x01) << 0) \
)

/**
 * Set signal front_right in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_door_status_front_right(buf, val) { \
	buf[3] &= ~(0x01 << 0); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 0; \
}

/**
 * Set signal front_right in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_door_status_front_right(buf) \
	SET_door_status_front_right(buf, 0)

/**
 * Signal front_right value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_door_status_front_right(x, fmt) \
	((x) * fmt)

/**
 * Signal front_right value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_door_status_front_right(x, fmt) \
	((x) * fmt)

/**
 * Signal front_right raw initial value.
 */
#define START_door_status_front_right               0

/**
 * Signal front_right raw minimum value.
 */
#define MIN_door_status_front_right                 0

/**
 * Signal front_right raw maximum value.
 */
#define MAX_door_status_front_right                 1

/**
 * Signal front_right raw offset value.
 */
#define OFF_door_status_front_right                 0

/**
 * @}
 */

/**
 * @defgroup SIG_door_status_front_left Signal front_left of Message door_status (0x402)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_door_status
 * @{
 */

/**
 * Signal front_left configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_door_status_front_left and \ref GET_door_status_front_left instead.
 */
#define SIG_door_status_front_left                  0, 0, 26, 1

/**
 * Signal front_left setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_door_status_front_left or \ref INIT_door_status instead.
 */
#define SETUP_door_status_front_left                0, 0, 26, 1, 0

/**
 * Get signal front_left from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_door_status_front_left(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 2) & 0x01) << 0) \
)

/**
 * Set signal front_left in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_door_status_front_left(buf, val) { \
	buf[3] &= ~(0x01 << 2); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 2; \
}

/**
 * Set signal front_left in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_door_status_front_left(buf) \
	SET_door_status_front_left(buf, 0)

/**
 * Signal front_left value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_door_status_front_left(x, fmt) \
	((x) * fmt)

/**
 * Signal front_left value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_door_status_front_left(x, fmt) \
	((x) * fmt)

/**
 * Signal front_left raw initial value.
 */
#define START_door_status_front_left                0

/**
 * Signal front_left raw minimum value.
 */
#define MIN_door_status_front_left                  0

/**
 * Signal front_left raw maximum value.
 */
#define MAX_door_status_front_left                  1

/**
 * Signal front_left raw offset value.
 */
#define OFF_door_status_front_left                  0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_angle_status_angle_status Signal angle_status of Message lateral_angle_status (0x407)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_angle_status
 * @{
 */

/**
 * Signal angle_status configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_angle_status_angle_status and \ref GET_lateral_angle_status_angle_status instead.
 */
#define SIG_lateral_angle_status_angle_status        0, 0, 30, 4

/**
 * Signal angle_status setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_angle_status_angle_status or \ref INIT_lateral_angle_status instead.
 */
#define SETUP_lateral_angle_status_angle_status      0, 0, 30, 4, 0

/**
 * Get signal angle_status from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_angle_status_angle_status(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 6) & 0x03) << 0) \
	| (ubyte)(+(ubyte)((buf[4] >> 0) & 0x03) << 2) \
)

/**
 * Set signal angle_status in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_angle_status_angle_status(buf, val) { \
	buf[3] &= ~(0x03 << 6); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x03) << 6; \
	buf[4] &= ~(0x03 << 0); \
	buf[4] |= (((ubyte)(val) >> 2) & 0x03) << 0; \
}

/**
 * Set signal angle_status in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_angle_status_angle_status(buf) \
	SET_lateral_angle_status_angle_status(buf, 0)

/**
 * Signal angle_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_angle_status_angle_status(x, fmt) \
	((x) * fmt)

/**
 * Signal angle_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_lateral_angle_status_angle_status(x, fmt) \
	((x) * fmt)

/**
 * Signal angle_status raw initial value.
 */
#define START_lateral_angle_status_angle_status      0

/**
 * Signal angle_status raw minimum value.
 */
#define MIN_lateral_angle_status_angle_status        0

/**
 * Signal angle_status raw maximum value.
 */
#define MAX_lateral_angle_status_angle_status        15

/**
 * Signal angle_status raw offset value.
 */
#define OFF_lateral_angle_status_angle_status        0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_control_angle_angle_velocity Signal angle_velocity of Message lateral_control_angle (0x301)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_control_angle
 * @{
 */

/**
 * Signal angle_velocity configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_control_angle_angle_velocity and \ref GET_lateral_control_angle_angle_velocity instead.
 */
#define SIG_lateral_control_angle_angle_velocity        0, 0, 40, 10

/**
 * Signal angle_velocity setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_control_angle_angle_velocity or \ref INIT_lateral_control_angle instead.
 */
#define SETUP_lateral_control_angle_angle_velocity      0, 0, 40, 10, 0

/**
 * Get signal angle_velocity from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_control_angle_angle_velocity(buf) (0 \
	| (ubyte)(+(ubyte)((buf[5] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[6] >> 0) & 0x03) << 8) \
)

/**
 * Set signal angle_velocity in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_control_angle_angle_velocity(buf, val) { \
	buf[5] &= ~(0xff << 0); \
	buf[5] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[6] &= ~(0x03 << 0); \
	buf[6] |= ((ubyte)((uword)(val) >> 8) & 0x03) << 0; \
}

/**
 * Set signal angle_velocity in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_control_angle_angle_velocity(buf) \
	SET_lateral_control_angle_angle_velocity(buf, 0)

/**
 * Signal angle_velocity value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_control_angle_angle_velocity(x, fmt) \
	((x) * fmt)

/**
 * Signal angle_velocity raw initial value.
 */
#define START_lateral_control_angle_angle_velocity      0

/**
 * Signal angle_velocity raw minimum value.
 */
#define MIN_lateral_control_angle_angle_velocity        0

/**
 * Signal angle_velocity raw maximum value.
 */
#define MAX_lateral_control_angle_angle_velocity        1023

/**
 * Signal angle_velocity raw offset value.
 */
#define OFF_lateral_control_angle_angle_velocity        0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_control_angle_angle_value Signal angle_value of Message lateral_control_angle (0x301)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_control_angle
 * @{
 */

/**
 * Signal angle_value configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_control_angle_angle_value and \ref GET_lateral_control_angle_angle_value instead.
 */
#define SIG_lateral_control_angle_angle_value        0, 0, 16, 13

/**
 * Signal angle_value setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_control_angle_angle_value or \ref INIT_lateral_control_angle instead.
 */
#define SETUP_lateral_control_angle_angle_value      0, 0, 16, 13, 0

/**
 * Get signal angle_value from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_control_angle_angle_value(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[3] >> 0) & 0x1f) << 8) \
)

/**
 * Set signal angle_value in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_control_angle_angle_value(buf, val) { \
	buf[2] &= ~(0xff << 0); \
	buf[2] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[3] &= ~(0x1f << 0); \
	buf[3] |= ((ubyte)((uword)(val) >> 8) & 0x1f) << 0; \
}

/**
 * Set signal angle_value in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_control_angle_angle_value(buf) \
	SET_lateral_control_angle_angle_value(buf, 0)

/**
 * Signal angle_value value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_control_angle_angle_value(x, fmt) \
	((x) * fmt / 10)

/**
 * Signal angle_value raw initial value.
 */
#define START_lateral_control_angle_angle_value      0

/**
 * Signal angle_value raw minimum value.
 */
#define MIN_lateral_control_angle_angle_value        0

/**
 * Signal angle_value raw maximum value.
 */
#define MAX_lateral_control_angle_angle_value        8191

/**
 * Signal angle_value raw offset value.
 */
#define OFF_lateral_control_angle_angle_value        0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_control_angle_direction Signal direction of Message lateral_control_angle (0x301)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_control_angle
 * @{
 */

/**
 * Signal direction configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_control_angle_direction and \ref GET_lateral_control_angle_direction instead.
 */
#define SIG_lateral_control_angle_direction         0, 0, 31, 1

/**
 * Signal direction setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_control_angle_direction or \ref INIT_lateral_control_angle instead.
 */
#define SETUP_lateral_control_angle_direction       0, 0, 31, 1, 0

/**
 * Get signal direction from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_control_angle_direction(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 7) & 0x01) << 0) \
)

/**
 * Set signal direction in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_control_angle_direction(buf, val) { \
	buf[3] &= ~(0x01 << 7); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 7; \
}

/**
 * Set signal direction in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_control_angle_direction(buf) \
	SET_lateral_control_angle_direction(buf, 0)

/**
 * Signal direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_control_angle_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal direction raw initial value.
 */
#define START_lateral_control_angle_direction       0

/**
 * Signal direction raw minimum value.
 */
#define MIN_lateral_control_angle_direction         0

/**
 * Signal direction raw maximum value.
 */
#define MAX_lateral_control_angle_direction         1

/**
 * Signal direction raw offset value.
 */
#define OFF_lateral_control_angle_direction         0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_control_angle_enable Signal enable of Message lateral_control_angle (0x301)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_control_angle
 * @{
 */

/**
 * Signal enable configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_control_angle_enable and \ref GET_lateral_control_angle_enable instead.
 */
#define SIG_lateral_control_angle_enable            0, 0, 32, 4

/**
 * Signal enable setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_control_angle_enable or \ref INIT_lateral_control_angle instead.
 */
#define SETUP_lateral_control_angle_enable          0, 0, 32, 4, 0

/**
 * Get signal enable from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_control_angle_enable(buf) (0 \
	| (ubyte)(+(ubyte)((buf[4] >> 0) & 0x0f) << 0) \
)

/**
 * Set signal enable in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_control_angle_enable(buf, val) { \
	buf[4] &= ~(0x0f << 0); \
	buf[4] |= (((ubyte)(val) >> 0) & 0x0f) << 0; \
}

/**
 * Set signal enable in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_control_angle_enable(buf) \
	SET_lateral_control_angle_enable(buf, 0)

/**
 * Signal enable value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_control_angle_enable(x, fmt) \
	((x) * fmt)

/**
 * Signal enable raw initial value.
 */
#define START_lateral_control_angle_enable          0

/**
 * Signal enable raw minimum value.
 */
#define MIN_lateral_control_angle_enable            0

/**
 * Signal enable raw maximum value.
 */
#define MAX_lateral_control_angle_enable            15

/**
 * Signal enable raw offset value.
 */
#define OFF_lateral_control_angle_enable            0

/**
 * @}
 */

/**
 * @defgroup SIG_switch_status_io Signal io of Message switch_status (0x409)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_switch_status
 * @{
 */

/**
 * Signal io configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_switch_status_io and \ref GET_switch_status_io instead.
 */
#define SIG_switch_status_io                        0, 0, 12, 1

/**
 * Signal io setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_switch_status_io or \ref INIT_switch_status instead.
 */
#define SETUP_switch_status_io                      0, 0, 12, 1, 0

/**
 * Get signal io from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_switch_status_io(buf) (0 \
	| (ubyte)(+(ubyte)((buf[1] >> 4) & 0x01) << 0) \
)

/**
 * Set signal io in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_switch_status_io(buf, val) { \
	buf[1] &= ~(0x01 << 4); \
	buf[1] |= (((ubyte)(val) >> 0) & 0x01) << 4; \
}

/**
 * Set signal io in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_switch_status_io(buf) \
	SET_switch_status_io(buf, 0)

/**
 * Signal io value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_switch_status_io(x, fmt) \
	((x) * fmt)

/**
 * Signal io value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_switch_status_io(x, fmt) \
	((x) * fmt)

/**
 * Signal io raw initial value.
 */
#define START_switch_status_io                      0

/**
 * Signal io raw minimum value.
 */
#define MIN_switch_status_io                        0

/**
 * Signal io raw maximum value.
 */
#define MAX_switch_status_io                        1

/**
 * Signal io raw offset value.
 */
#define OFF_switch_status_io                        0

/**
 * @}
 */

/**
 * @defgroup SIG_switch_status_mode Signal mode of Message switch_status (0x409)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_switch_status
 * @{
 */

/**
 * Signal mode configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_switch_status_mode and \ref GET_switch_status_mode instead.
 */
#define SIG_switch_status_mode                      0, 0, 15, 1

/**
 * Signal mode setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_switch_status_mode or \ref INIT_switch_status instead.
 */
#define SETUP_switch_status_mode                    0, 0, 15, 1, 0

/**
 * Get signal mode from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_switch_status_mode(buf) (0 \
	| (ubyte)(+(ubyte)((buf[1] >> 7) & 0x01) << 0) \
)

/**
 * Set signal mode in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_switch_status_mode(buf, val) { \
	buf[1] &= ~(0x01 << 7); \
	buf[1] |= (((ubyte)(val) >> 0) & 0x01) << 7; \
}

/**
 * Set signal mode in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_switch_status_mode(buf) \
	SET_switch_status_mode(buf, 0)

/**
 * Signal mode value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_switch_status_mode(x, fmt) \
	((x) * fmt)

/**
 * Signal mode value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_switch_status_mode(x, fmt) \
	((x) * fmt)

/**
 * Signal mode raw initial value.
 */
#define START_switch_status_mode                    0

/**
 * Signal mode raw minimum value.
 */
#define MIN_switch_status_mode                      0

/**
 * Signal mode raw maximum value.
 */
#define MAX_switch_status_mode                      1

/**
 * Signal mode raw offset value.
 */
#define OFF_switch_status_mode                      0

/**
 * @}
 */

/**
 * @defgroup SIG_switch_status_set Signal set of Message switch_status (0x409)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_switch_status
 * @{
 */

/**
 * Signal set configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_switch_status_set and \ref GET_switch_status_set instead.
 */
#define SIG_switch_status_set                       0, 0, 16, 1

/**
 * Signal set setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_switch_status_set or \ref INIT_switch_status instead.
 */
#define SETUP_switch_status_set                     0, 0, 16, 1, 0

/**
 * Get signal set from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_switch_status_set(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 0) & 0x01) << 0) \
)

/**
 * Set signal set in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_switch_status_set(buf, val) { \
	buf[2] &= ~(0x01 << 0); \
	buf[2] |= (((ubyte)(val) >> 0) & 0x01) << 0; \
}

/**
 * Set signal set in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_switch_status_set(buf) \
	SET_switch_status_set(buf, 0)

/**
 * Signal set value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_switch_status_set(x, fmt) \
	((x) * fmt)

/**
 * Signal set value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_switch_status_set(x, fmt) \
	((x) * fmt)

/**
 * Signal set raw initial value.
 */
#define START_switch_status_set                     0

/**
 * Signal set raw minimum value.
 */
#define MIN_switch_status_set                       0

/**
 * Signal set raw maximum value.
 */
#define MAX_switch_status_set                       1

/**
 * Signal set raw offset value.
 */
#define OFF_switch_status_set                       0

/**
 * @}
 */

/**
 * @defgroup SIG_switch_status_plus Signal plus of Message switch_status (0x409)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_switch_status
 * @{
 */

/**
 * Signal plus configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_switch_status_plus and \ref GET_switch_status_plus instead.
 */
#define SIG_switch_status_plus                      0, 0, 17, 1

/**
 * Signal plus setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_switch_status_plus or \ref INIT_switch_status instead.
 */
#define SETUP_switch_status_plus                    0, 0, 17, 1, 0

/**
 * Get signal plus from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_switch_status_plus(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 1) & 0x01) << 0) \
)

/**
 * Set signal plus in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_switch_status_plus(buf, val) { \
	buf[2] &= ~(0x01 << 1); \
	buf[2] |= (((ubyte)(val) >> 0) & 0x01) << 1; \
}

/**
 * Set signal plus in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_switch_status_plus(buf) \
	SET_switch_status_plus(buf, 0)

/**
 * Signal plus value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_switch_status_plus(x, fmt) \
	((x) * fmt)

/**
 * Signal plus value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_switch_status_plus(x, fmt) \
	((x) * fmt)

/**
 * Signal plus raw initial value.
 */
#define START_switch_status_plus                    0

/**
 * Signal plus raw minimum value.
 */
#define MIN_switch_status_plus                      0

/**
 * Signal plus raw maximum value.
 */
#define MAX_switch_status_plus                      1

/**
 * Signal plus raw offset value.
 */
#define OFF_switch_status_plus                      0

/**
 * @}
 */

/**
 * @defgroup SIG_switch_status_minus Signal minus of Message switch_status (0x409)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_switch_status
 * @{
 */

/**
 * Signal minus configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_switch_status_minus and \ref GET_switch_status_minus instead.
 */
#define SIG_switch_status_minus                     0, 0, 18, 1

/**
 * Signal minus setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_switch_status_minus or \ref INIT_switch_status instead.
 */
#define SETUP_switch_status_minus                   0, 0, 18, 1, 0

/**
 * Get signal minus from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_switch_status_minus(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 2) & 0x01) << 0) \
)

/**
 * Set signal minus in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_switch_status_minus(buf, val) { \
	buf[2] &= ~(0x01 << 2); \
	buf[2] |= (((ubyte)(val) >> 0) & 0x01) << 2; \
}

/**
 * Set signal minus in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_switch_status_minus(buf) \
	SET_switch_status_minus(buf, 0)

/**
 * Signal minus value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_switch_status_minus(x, fmt) \
	((x) * fmt)

/**
 * Signal minus value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_switch_status_minus(x, fmt) \
	((x) * fmt)

/**
 * Signal minus raw initial value.
 */
#define START_switch_status_minus                   0

/**
 * Signal minus raw minimum value.
 */
#define MIN_switch_status_minus                     0

/**
 * Signal minus raw maximum value.
 */
#define MAX_switch_status_minus                     1

/**
 * Signal minus raw offset value.
 */
#define OFF_switch_status_minus                     0

/**
 * @}
 */

/**
 * @defgroup SIG_switch_status_res Signal res of Message switch_status (0x409)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_switch_status
 * @{
 */

/**
 * Signal res configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_switch_status_res and \ref GET_switch_status_res instead.
 */
#define SIG_switch_status_res                       0, 0, 19, 1

/**
 * Signal res setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_switch_status_res or \ref INIT_switch_status instead.
 */
#define SETUP_switch_status_res                     0, 0, 19, 1, 0

/**
 * Get signal res from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_switch_status_res(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 3) & 0x01) << 0) \
)

/**
 * Set signal res in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_switch_status_res(buf, val) { \
	buf[2] &= ~(0x01 << 3); \
	buf[2] |= (((ubyte)(val) >> 0) & 0x01) << 3; \
}

/**
 * Set signal res in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_switch_status_res(buf) \
	SET_switch_status_res(buf, 0)

/**
 * Signal res value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_switch_status_res(x, fmt) \
	((x) * fmt)

/**
 * Signal res value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_switch_status_res(x, fmt) \
	((x) * fmt)

/**
 * Signal res raw initial value.
 */
#define START_switch_status_res                     0

/**
 * Signal res raw minimum value.
 */
#define MIN_switch_status_res                       0

/**
 * Signal res raw maximum value.
 */
#define MAX_switch_status_res                       1

/**
 * Signal res raw offset value.
 */
#define OFF_switch_status_res                       0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_control_torque_torque_value Signal torque_value of Message lateral_control_torque (0x302)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_control_torque
 * @{
 */

/**
 * Signal torque_value configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_control_torque_torque_value and \ref GET_lateral_control_torque_torque_value instead.
 */
#define SIG_lateral_control_torque_torque_value        0, 0, 16, 9

/**
 * Signal torque_value setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_control_torque_torque_value or \ref INIT_lateral_control_torque instead.
 */
#define SETUP_lateral_control_torque_torque_value      0, 0, 16, 9, 0

/**
 * Get signal torque_value from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_control_torque_torque_value(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[3] >> 0) & 0x01) << 8) \
)

/**
 * Set signal torque_value in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_control_torque_torque_value(buf, val) { \
	buf[2] &= ~(0xff << 0); \
	buf[2] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[3] &= ~(0x01 << 0); \
	buf[3] |= ((ubyte)((uword)(val) >> 8) & 0x01) << 0; \
}

/**
 * Set signal torque_value in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_control_torque_torque_value(buf) \
	SET_lateral_control_torque_torque_value(buf, 0)

/**
 * Signal torque_value value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_control_torque_torque_value(x, fmt) \
	((x) * fmt / 100)

/**
 * Signal torque_value raw initial value.
 */
#define START_lateral_control_torque_torque_value      0

/**
 * Signal torque_value raw minimum value.
 */
#define MIN_lateral_control_torque_torque_value        0

/**
 * Signal torque_value raw maximum value.
 */
#define MAX_lateral_control_torque_torque_value        511

/**
 * Signal torque_value raw offset value.
 */
#define OFF_lateral_control_torque_torque_value        0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_control_torque_direction Signal direction of Message lateral_control_torque (0x302)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_control_torque
 * @{
 */

/**
 * Signal direction configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_control_torque_direction and \ref GET_lateral_control_torque_direction instead.
 */
#define SIG_lateral_control_torque_direction        0, 0, 31, 1

/**
 * Signal direction setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_control_torque_direction or \ref INIT_lateral_control_torque instead.
 */
#define SETUP_lateral_control_torque_direction      0, 0, 31, 1, 0

/**
 * Get signal direction from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_control_torque_direction(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 7) & 0x01) << 0) \
)

/**
 * Set signal direction in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_control_torque_direction(buf, val) { \
	buf[3] &= ~(0x01 << 7); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 7; \
}

/**
 * Set signal direction in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_control_torque_direction(buf) \
	SET_lateral_control_torque_direction(buf, 0)

/**
 * Signal direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_control_torque_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal direction raw initial value.
 */
#define START_lateral_control_torque_direction      0

/**
 * Signal direction raw minimum value.
 */
#define MIN_lateral_control_torque_direction        0

/**
 * Signal direction raw maximum value.
 */
#define MAX_lateral_control_torque_direction        1

/**
 * Signal direction raw offset value.
 */
#define OFF_lateral_control_torque_direction        0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_control_torque_enable Signal enable of Message lateral_control_torque (0x302)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_control_torque
 * @{
 */

/**
 * Signal enable configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_control_torque_enable and \ref GET_lateral_control_torque_enable instead.
 */
#define SIG_lateral_control_torque_enable           0, 0, 32, 4

/**
 * Signal enable setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_control_torque_enable or \ref INIT_lateral_control_torque instead.
 */
#define SETUP_lateral_control_torque_enable         0, 0, 32, 4, 0

/**
 * Get signal enable from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_control_torque_enable(buf) (0 \
	| (ubyte)(+(ubyte)((buf[4] >> 0) & 0x0f) << 0) \
)

/**
 * Set signal enable in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_control_torque_enable(buf, val) { \
	buf[4] &= ~(0x0f << 0); \
	buf[4] |= (((ubyte)(val) >> 0) & 0x0f) << 0; \
}

/**
 * Set signal enable in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_control_torque_enable(buf) \
	SET_lateral_control_torque_enable(buf, 0)

/**
 * Signal enable value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_control_torque_enable(x, fmt) \
	((x) * fmt)

/**
 * Signal enable raw initial value.
 */
#define START_lateral_control_torque_enable         0

/**
 * Signal enable raw minimum value.
 */
#define MIN_lateral_control_torque_enable           0

/**
 * Signal enable raw maximum value.
 */
#define MAX_lateral_control_torque_enable           15

/**
 * Signal enable raw offset value.
 */
#define OFF_lateral_control_torque_enable           0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_torque_status_torque_status Signal torque_status of Message lateral_torque_status (0x406)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_torque_status
 * @{
 */

/**
 * Signal torque_status configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_torque_status_torque_status and \ref GET_lateral_torque_status_torque_status instead.
 */
#define SIG_lateral_torque_status_torque_status        0, 0, 32, 4

/**
 * Signal torque_status setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_torque_status_torque_status or \ref INIT_lateral_torque_status instead.
 */
#define SETUP_lateral_torque_status_torque_status      0, 0, 32, 4, 0

/**
 * Get signal torque_status from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_torque_status_torque_status(buf) (0 \
	| (ubyte)(+(ubyte)((buf[4] >> 0) & 0x0f) << 0) \
)

/**
 * Set signal torque_status in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_torque_status_torque_status(buf, val) { \
	buf[4] &= ~(0x0f << 0); \
	buf[4] |= (((ubyte)(val) >> 0) & 0x0f) << 0; \
}

/**
 * Set signal torque_status in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_torque_status_torque_status(buf) \
	SET_lateral_torque_status_torque_status(buf, 0)

/**
 * Signal torque_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_torque_status_torque_status(x, fmt) \
	((x) * fmt)

/**
 * Signal torque_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_lateral_torque_status_torque_status(x, fmt) \
	((x) * fmt)

/**
 * Signal torque_status raw initial value.
 */
#define START_lateral_torque_status_torque_status      0

/**
 * Signal torque_status raw minimum value.
 */
#define MIN_lateral_torque_status_torque_status        0

/**
 * Signal torque_status raw maximum value.
 */
#define MAX_lateral_torque_status_torque_status        15

/**
 * Signal torque_status raw offset value.
 */
#define OFF_lateral_torque_status_torque_status        0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_torque_status_actual_torque Signal actual_torque of Message lateral_torque_status (0x406)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_torque_status
 * @{
 */

/**
 * Signal actual_torque configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_torque_status_actual_torque and \ref GET_lateral_torque_status_actual_torque instead.
 */
#define SIG_lateral_torque_status_actual_torque        0, 0, 40, 10

/**
 * Signal actual_torque setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_torque_status_actual_torque or \ref INIT_lateral_torque_status instead.
 */
#define SETUP_lateral_torque_status_actual_torque      0, 0, 40, 10, 0

/**
 * Get signal actual_torque from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_torque_status_actual_torque(buf) (0 \
	| (ubyte)(+(ubyte)((buf[5] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[6] >> 0) & 0x03) << 8) \
)

/**
 * Set signal actual_torque in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_torque_status_actual_torque(buf, val) { \
	buf[5] &= ~(0xff << 0); \
	buf[5] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[6] &= ~(0x03 << 0); \
	buf[6] |= ((ubyte)((uword)(val) >> 8) & 0x03) << 0; \
}

/**
 * Set signal actual_torque in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_torque_status_actual_torque(buf) \
	SET_lateral_torque_status_actual_torque(buf, 0)

/**
 * Signal actual_torque value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_torque_status_actual_torque(x, fmt) \
	((x) * fmt / 100)

/**
 * Signal actual_torque value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_lateral_torque_status_actual_torque(x, fmt) \
	((x) * fmt * 100)

/**
 * Signal actual_torque raw initial value.
 */
#define START_lateral_torque_status_actual_torque      0

/**
 * Signal actual_torque raw minimum value.
 */
#define MIN_lateral_torque_status_actual_torque        0

/**
 * Signal actual_torque raw maximum value.
 */
#define MAX_lateral_torque_status_actual_torque        800

/**
 * Signal actual_torque raw offset value.
 */
#define OFF_lateral_torque_status_actual_torque        0

/**
 * @}
 */

/**
 * @defgroup SIG_lateral_torque_status_torque_direction Signal torque_direction of Message lateral_torque_status (0x406)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_lateral_torque_status
 * @{
 */

/**
 * Signal torque_direction configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_lateral_torque_status_torque_direction and \ref GET_lateral_torque_status_torque_direction instead.
 */
#define SIG_lateral_torque_status_torque_direction        0, 0, 55, 1

/**
 * Signal torque_direction setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_lateral_torque_status_torque_direction or \ref INIT_lateral_torque_status instead.
 */
#define SETUP_lateral_torque_status_torque_direction      0, 0, 55, 1, 0

/**
 * Get signal torque_direction from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_lateral_torque_status_torque_direction(buf) (0 \
	| (ubyte)(+(ubyte)((buf[6] >> 7) & 0x01) << 0) \
)

/**
 * Set signal torque_direction in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_lateral_torque_status_torque_direction(buf, val) { \
	buf[6] &= ~(0x01 << 7); \
	buf[6] |= (((ubyte)(val) >> 0) & 0x01) << 7; \
}

/**
 * Set signal torque_direction in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_lateral_torque_status_torque_direction(buf) \
	SET_lateral_torque_status_torque_direction(buf, 0)

/**
 * Signal torque_direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_lateral_torque_status_torque_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal torque_direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_lateral_torque_status_torque_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal torque_direction raw initial value.
 */
#define START_lateral_torque_status_torque_direction      0

/**
 * Signal torque_direction raw minimum value.
 */
#define MIN_lateral_torque_status_torque_direction        0

/**
 * Signal torque_direction raw maximum value.
 */
#define MAX_lateral_torque_status_torque_direction        1

/**
 * Signal torque_direction raw offset value.
 */
#define OFF_lateral_torque_status_torque_direction        0

/**
 * @}
 */

/**
 * @defgroup SIG_steering_status_status Signal status of Message steering_status (0x408)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_steering_status
 * @{
 */

/**
 * Signal status configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_steering_status_status and \ref GET_steering_status_status instead.
 */
#define SIG_steering_status_status                  0, 0, 12, 1

/**
 * Signal status setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_steering_status_status or \ref INIT_steering_status instead.
 */
#define SETUP_steering_status_status                0, 0, 12, 1, 0

/**
 * Get signal status from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_steering_status_status(buf) (0 \
	| (ubyte)(+(ubyte)((buf[1] >> 4) & 0x01) << 0) \
)

/**
 * Set signal status in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_steering_status_status(buf, val) { \
	buf[1] &= ~(0x01 << 4); \
	buf[1] |= (((ubyte)(val) >> 0) & 0x01) << 4; \
}

/**
 * Set signal status in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_steering_status_status(buf) \
	SET_steering_status_status(buf, 0)

/**
 * Signal status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_steering_status_status(x, fmt) \
	((x) * fmt)

/**
 * Signal status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_steering_status_status(x, fmt) \
	((x) * fmt)

/**
 * Signal status raw initial value.
 */
#define START_steering_status_status                0

/**
 * Signal status raw minimum value.
 */
#define MIN_steering_status_status                  0

/**
 * Signal status raw maximum value.
 */
#define MAX_steering_status_status                  1

/**
 * Signal status raw offset value.
 */
#define OFF_steering_status_status                  0

/**
 * @}
 */

/**
 * @defgroup SIG_steering_status_steering_angle Signal steering_angle of Message steering_status (0x408)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_steering_status
 * @{
 */

/**
 * Signal steering_angle configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_steering_status_steering_angle and \ref GET_steering_status_steering_angle instead.
 */
#define SIG_steering_status_steering_angle          0, 0, 16, 13

/**
 * Signal steering_angle setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_steering_status_steering_angle or \ref INIT_steering_status instead.
 */
#define SETUP_steering_status_steering_angle        0, 0, 16, 13, 0

/**
 * Get signal steering_angle from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_steering_status_steering_angle(buf) (0 \
	| (ubyte)(+(ubyte)((buf[2] >> 0) & 0xff) << 0) \
	| (uword)(+(uword)((buf[3] >> 0) & 0x1f) << 8) \
)

/**
 * Set signal steering_angle in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_steering_status_steering_angle(buf, val) { \
	buf[2] &= ~(0xff << 0); \
	buf[2] |= (((ubyte)(val) >> 0) & 0xff) << 0; \
	buf[3] &= ~(0x1f << 0); \
	buf[3] |= ((ubyte)((uword)(val) >> 8) & 0x1f) << 0; \
}

/**
 * Set signal steering_angle in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_steering_status_steering_angle(buf) \
	SET_steering_status_steering_angle(buf, 0)

/**
 * Signal steering_angle value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_steering_status_steering_angle(x, fmt) \
	((x) * fmt / 10)

/**
 * Signal steering_angle value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_steering_status_steering_angle(x, fmt) \
	((x) * fmt * 10)

/**
 * Signal steering_angle raw initial value.
 */
#define START_steering_status_steering_angle        0

/**
 * Signal steering_angle raw minimum value.
 */
#define MIN_steering_status_steering_angle          0

/**
 * Signal steering_angle raw maximum value.
 */
#define MAX_steering_status_steering_angle          8000

/**
 * Signal steering_angle raw offset value.
 */
#define OFF_steering_status_steering_angle          0

/**
 * @}
 */

/**
 * @defgroup SIG_steering_status_steering_angle_direction Signal steering_angle_direction of Message steering_status (0x408)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_steering_status
 * @{
 */

/**
 * Signal steering_angle_direction configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_steering_status_steering_angle_direction and \ref GET_steering_status_steering_angle_direction instead.
 */
#define SIG_steering_status_steering_angle_direction        0, 0, 29, 1

/**
 * Signal steering_angle_direction setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_steering_status_steering_angle_direction or \ref INIT_steering_status instead.
 */
#define SETUP_steering_status_steering_angle_direction      0, 0, 29, 1, 0

/**
 * Get signal steering_angle_direction from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_steering_status_steering_angle_direction(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 5) & 0x01) << 0) \
)

/**
 * Set signal steering_angle_direction in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_steering_status_steering_angle_direction(buf, val) { \
	buf[3] &= ~(0x01 << 5); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 5; \
}

/**
 * Set signal steering_angle_direction in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_steering_status_steering_angle_direction(buf) \
	SET_steering_status_steering_angle_direction(buf, 0)

/**
 * Signal steering_angle_direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_steering_status_steering_angle_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal steering_angle_direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_steering_status_steering_angle_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal steering_angle_direction raw initial value.
 */
#define START_steering_status_steering_angle_direction      0

/**
 * Signal steering_angle_direction raw minimum value.
 */
#define MIN_steering_status_steering_angle_direction        0

/**
 * Signal steering_angle_direction raw maximum value.
 */
#define MAX_steering_status_steering_angle_direction        1

/**
 * Signal steering_angle_direction raw offset value.
 */
#define OFF_steering_status_steering_angle_direction        0

/**
 * @}
 */

/**
 * @defgroup SIG_steering_status_steering_velocity_direction Signal steering_velocity_direction of Message steering_status (0x408)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_steering_status
 * @{
 */

/**
 * Signal steering_velocity_direction configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_steering_status_steering_velocity_direction and \ref GET_steering_status_steering_velocity_direction instead.
 */
#define SIG_steering_status_steering_velocity_direction        0, 0, 30, 1

/**
 * Signal steering_velocity_direction setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_steering_status_steering_velocity_direction or \ref INIT_steering_status instead.
 */
#define SETUP_steering_status_steering_velocity_direction      0, 0, 30, 1, 0

/**
 * Get signal steering_velocity_direction from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_steering_status_steering_velocity_direction(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 6) & 0x01) << 0) \
)

/**
 * Set signal steering_velocity_direction in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_steering_status_steering_velocity_direction(buf, val) { \
	buf[3] &= ~(0x01 << 6); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 6; \
}

/**
 * Set signal steering_velocity_direction in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_steering_status_steering_velocity_direction(buf) \
	SET_steering_status_steering_velocity_direction(buf, 0)

/**
 * Signal steering_velocity_direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_steering_status_steering_velocity_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal steering_velocity_direction value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_steering_status_steering_velocity_direction(x, fmt) \
	((x) * fmt)

/**
 * Signal steering_velocity_direction raw initial value.
 */
#define START_steering_status_steering_velocity_direction      0

/**
 * Signal steering_velocity_direction raw minimum value.
 */
#define MIN_steering_status_steering_velocity_direction        0

/**
 * Signal steering_velocity_direction raw maximum value.
 */
#define MAX_steering_status_steering_velocity_direction        1

/**
 * Signal steering_velocity_direction raw offset value.
 */
#define OFF_steering_status_steering_velocity_direction        0

/**
 * @}
 */

/**
 * @defgroup SIG_steering_status_steering_velocity Signal steering_velocity of Message steering_status (0x408)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_steering_status
 * @{
 */

/**
 * Signal steering_velocity configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_steering_status_steering_velocity and \ref GET_steering_status_steering_velocity instead.
 */
#define SIG_steering_status_steering_velocity        0, 0, 31, 9

/**
 * Signal steering_velocity setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_steering_status_steering_velocity or \ref INIT_steering_status instead.
 */
#define SETUP_steering_status_steering_velocity      0, 0, 31, 9, 0

/**
 * Get signal steering_velocity from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_steering_status_steering_velocity(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 7) & 0x01) << 0) \
	| (uword)(+(uword)((buf[4] >> 0) & 0xff) << 1) \
)

/**
 * Set signal steering_velocity in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_steering_status_steering_velocity(buf, val) { \
	buf[3] &= ~(0x01 << 7); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x01) << 7; \
	buf[4] &= ~(0xff << 0); \
	buf[4] |= ((ubyte)((uword)(val) >> 1) & 0xff) << 0; \
}

/**
 * Set signal steering_velocity in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_steering_status_steering_velocity(buf) \
	SET_steering_status_steering_velocity(buf, 0)

/**
 * Signal steering_velocity value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_steering_status_steering_velocity(x, fmt) \
	((x) * fmt * 5)

/**
 * Signal steering_velocity value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_steering_status_steering_velocity(x, fmt) \
	((x) * fmt / 5)

/**
 * Signal steering_velocity raw initial value.
 */
#define START_steering_status_steering_velocity      0

/**
 * Signal steering_velocity raw minimum value.
 */
#define MIN_steering_status_steering_velocity        0

/**
 * Signal steering_velocity raw maximum value.
 */
#define MAX_steering_status_steering_velocity        500

/**
 * Signal steering_velocity raw offset value.
 */
#define OFF_steering_status_steering_velocity        0

/**
 * @}
 */

/**
 * @defgroup SIG_longitudinal_status_longitudinal_status Signal longitudinal_status of Message longitudinal_status (0x405)
 *
 * Received by the ECUs:
 *
 * @ingroup MSG_longitudinal_status
 * @{
 */

/**
 * Signal longitudinal_status configuration tuple.
 *
 * @deprecated
 *	Use \ref SET_longitudinal_status_longitudinal_status and \ref GET_longitudinal_status_longitudinal_status instead.
 */
#define SIG_longitudinal_status_longitudinal_status        0, 0, 24, 3

/**
 * Signal longitudinal_status setup tuple.
 *
 * @deprecated
 *	Use \ref INITSIG_longitudinal_status_longitudinal_status or \ref INIT_longitudinal_status instead.
 */
#define SETUP_longitudinal_status_longitudinal_status      0, 0, 24, 3, 0

/**
 * Get signal longitudinal_status from buffer.
 *
 * @param buf
 *	The can message buffer containing the signal
 * @return
 *	The raw signal
 */
#define GET_longitudinal_status_longitudinal_status(buf) (0 \
	| (ubyte)(+(ubyte)((buf[3] >> 0) & 0x07) << 0) \
)

/**
 * Set signal longitudinal_status in buffer.
 *
 * @param buf
 *	The can message buffer to add the signal to
 * @param val
 *	The raw value to set the signal to
 */
#define SET_longitudinal_status_longitudinal_status(buf, val) { \
	buf[3] &= ~(0x07 << 0); \
	buf[3] |= (((ubyte)(val) >> 0) & 0x07) << 0; \
}

/**
 * Set signal longitudinal_status in buffer to its initial value.
 *
 * @param buf
 *	The can message buffer to initialise
 */
#define INITSIG_longitudinal_status_longitudinal_status(buf) \
	SET_longitudinal_status_longitudinal_status(buf, 0)

/**
 * Signal longitudinal_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The raw signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define CALC_longitudinal_status_longitudinal_status(x, fmt) \
	((x) * fmt)

/**
 * Signal longitudinal_status value conversion with 16 bit factor and offset.
 *
 * @param x
 *	The physical signal value
 * @param fmt
 *	A factor to adjust values, e.g. 10 to get one additional
 *	digit or 1 / 1000 to dispay a fraction
 * @return
 *	The signal value as a human readable number
 */
#define PHYS_RAW_longitudinal_status_longitudinal_status(x, fmt) \
	((x) * fmt)


/**
 * Signal longitudinal_status raw initial value.
 */
#define START_longitudinal_status_longitudinal_status      0

/**
 * Signal longitudinal_status raw minimum value.
 */
#define MIN_longitudinal_status_longitudinal_status        0

/**
 * Signal longitudinal_status raw maximum value.
 */
#define MAX_longitudinal_status_longitudinal_status        7

/**
 * Signal longitudinal_status raw offset value.
 */
#define OFF_longitudinal_status_longitudinal_status        0

/**
 * @}
 */

